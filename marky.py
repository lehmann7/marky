#!/usr/bin/env python3
# -*- coding: utf-8 -*-

########################################################################
# marky Markdown Preprocessor ###########################################
########################################################################

# Quick Make Example Project
############################
#
#  > mkdir project
#  > cp /path/to/marky.py project
#  > cd project
#  > chmod +x marky.py
#  > ./marky.py --init
#  > make scan html-all pdf-all httpd
#
# Open: project/pdf/*.pdf
# Goto: http://localhost:8000/

########################################################################

import sys
import argparse
import glob
import os
import base64
import yaml

########################################################################

if not sys.version_info.major == 3 and sys.version_info.minor >= 6:
	try:
		raise ValueError("marky requires Python 3.6 or higher.")
	except Exception as ex:
		print("# ERROR", type(ex), str(ex))
		sys.exit(1)

########################################################################

_MARKY_VERSION = (0, 9)

########################################################################
# SECTION IS AUTO-PACKAGED USING ./marky.py --pack --force
########################################################################
###!!!:::marky_pack_data:::!!!###
pack_Makefile = '''
IyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMj
IyMjIyMjIyMjIyMjIyMjIyMjCgouUEhPTlk6IGhlbHAKaGVscDoKCSMgbWFya3kgREVQRU5E
RU5DSUVTCgkjIyMjIyMjIyMjIyMjIyMjIyMjIwoJIyAqIHBhbmRvYyA+PSAyLjEwCgkjICog
cGlwIGluc3RhbGwgcGFuZG9jLWZpZ25vcwoJIyAqIHBpcCBpbnN0YWxsIHBhbmRvYy1lcW5v
cwoJIyAqIHBpcCBpbnN0YWxsIHBhbmRvYy1zZWNub3MKCSMgKiBwaXAgaW5zdGFsbCBwYW5k
b2MtdGFibGVub3MKCSMgKiBwaXAgaW5zdGFsbCBwYW5kb2MteG5vcwoJIyAqIHBpcCBpbnN0
YWxsIHB5eWFtbAoJIwoJIyBBVFRFTlRJT04KCSMjIyMjIyMjIyMjCgkjIEFsbCBmaWxlcyBp
biBgYnVpbGQvKi5tZGAgYW5kIGBodG1sLyouaHRtbGAgYXJlIGF1dG8tZ2VuZXJhdGVkIQoJ
IyBVc2VyIGZpbGVzIGAqLm1kYCBoYXZlIHRvIGJlIHBsYWNlZCBpbiBgbWQvKi5tZGAhCgkj
IGBtYWtlIGNsZWFuYCBkZWxldGVzIGFsbCBmaWxlcyBpbiBgYnVpbGQvYCwgYGh0bWwvYCBh
bmQgYHBkZi9gLgoJIwoJIyBtYXJreSBVVElMUwoJIyMjIyMjIyMjIyMjIwoJIyAqIG1ha2Ug
aGVscCAgICAgICAgICAgIC0gc2hvdyB0aGlzICpIZWxwIE1lc3NhZ2UqCgkjICogbWFrZSB0
cmVlICAgICAgICAgICAgLSBzaG93IHRoZSAqUHJvamVjdCBUcmVlKgoJIyAqIG1ha2UgaHR0
cGQgICAgICAgICAgIC0gcnVuIHB5dGhvbiAtbSBodHRwZC5zZXJ2ZXIgaW4gYGh0bWwvYAoJ
IyAqIG1ha2UgY2xlYW4gICAgICAgICAgIC0gZGVsZXRlOiBgYnVpbGQvKmAsIGBodG1sLypg
LCBgcGRmLypgCgkjICogbWFrZSBzY2FuICAgICAgICAgICAgLSBidWlsZCBtYWtlIGRlcHM6
IGBidWlsZC8qLm1ha2VgCgkjICogbWFrZSBsaXN0ICAgICAgICAgICAgLSBsaXN0IGFsbCBz
Y2FubmVkIGZpbGVzIGFuZCB0YXJnZXRzCgkjCgkjIG1hcmt5IEJVSUxEIEFMTAoJIyMjIyMj
IyMjIyMjIyMjIyMKCSMgKiBtYWtlIGJ1aWxkICAgICAgICAgICAtPiBgYnVpbGQvKi57aHRt
bCxwZGZ9Lm1kYAoJIyAqIG1ha2UgdGV4ICAgICAgICAgICAgIC0+IGBidWlsZC8qLnRleGAK
CSMgKiBtYWtlIGh0bWwgICAgICAgICAgICAtPiBgaHRtbC8qLmh0bWxgCgkjICogbWFrZSBw
ZGYgICAgICAgICAgICAgLT4gYHBkZi8qLnBkZmAKCSMgKiBtYWtlIGFsbCAgICAgICAgICAg
ICAtPiBgaHRtbC8qLmh0bWxgLCBgcGRmLyoucGRmYAoJIwoJIyBtYXJreSBCVUlMRCBGSUxF
CgkjIyMjIyMjIyMjIyMjIyMjIyMKCSMgKiBtYWtlIGJ1aWxkL2ZpbGUgICAgICAtPiBgYnVp
bGQvZmlsZS57aHRtbCxwZGZ9Lm1kYAoJIyAqIG1ha2UgYnVpbGQvZmlsZS50ZXggIC0+IGBi
dWlsZC9maWxlLnRleGAKCSMgKiBtYWtlIGh0bWwvZmlsZSAgICAgICAtPiBgaHRtbC9maWxl
Lmh0bWxgCgkjICogbWFrZSBwZGYvZmlsZSAgICAgICAgLT4gYHBkZi9wZGYuaHRtbGAKCSMK
CSMgRVhBTVBMRQoJIyMjIyMjIyMjCgkjIDEuIHJ1biBgbWFrZSBzY2FuOyBtYWtlIGh0bWwv
ZmlsZS5odG1sIGh0dHBkYDoKCSMgICAgKiBnZW5lcmF0ZSBgYnVpbGQvZmlsZS5tYWtlYAoJ
IyAgICAqIHRyYW5zZm9ybSBgbWQvZmlsZS5tZGAgLT4gYGh0bWwvZmlsZS5odG1sYAoJIyAg
ICAqIHN0YXJ0IGEgcHl0aG9uIGh0dHBkIHNlcnZlciBpbiBgaHRtbGAKCSMgMi4gcnVuIGBt
YWtlIHNjYW47IG1ha2UgcGRmL2ZpbGUucGRmYAoJIyAgICAqIGdlbmVyYXRlIGBidWlsZC9m
aWxlLm1ha2VgCgkjICAgICogdHJhbnNmb3JtIGBtZC9maWxlLm1kYCAtPiBgcGRmL2ZpbGUu
cGRmYAoJIwoKLlBIT05ZOiB0cmVlCnRyZWU6CgkjIFBST0pFQ1QgVFJFRQoJIyMjIyMjIyMj
IyMjIyMKCSMgPHdvcmtpbmdfZGlyPgoJIyB8LSBtYXJreS5weSAgICAgICAgICAgIC0gbWFy
a3kgZXhlY3V0YWJsZQoJIyB8LSBNYWtlZmlsZSAgICAgICAgKCopIC0gbWFya3kgTWFrZWZp
bGUKCSMgfC0gcGFuZG9jLXJ1biAgICAgICgqKSAtIHBhbmRvYyB3cmFwcGVyCgkjIHwtIG1k
LyAgICAgICAgICAgICAoKikgLSB1c2VyIE1hcmtkb3duIGRpcgoJIyB8ICB8LSAqLm1kICAg
ICAgICAgICAgIC0gdXNlciBNYXJrZG93biB0ZXh0CgkjIHwtIGRhdGEvICAgICAgICAgICAo
KikgLSB1c2VyIGRhdGEgZGlyCgkjIHwgIHwtICouKiAgICAgICAgICAgICAgICB1c2VyIGRh
dGEgZmlsZXMKCSMgfC0gYnVpbGQvICAgICAgICAgICgqKSAtIGJ1aWxkIE1hcmtkb3duIGRp
cgoJIyB8ICB8LSAqLnB5ICAgICAgICAgKCopIC0gTWFya2Rvd24gbWFya3kgY29kZQoJIyB8
ICB8LSAqLm1ha2UgICAgICAgKCopIC0gTWFrZWZpbGUgcnVsZXMKCSMgfCAgfC0gKi5odG1s
Lm1kICAgICgqKSAtIE1hcmtkb3duIGZvciBodG1sIGZvcm1hdAoJIyB8ICB8LSAqLnBkZi5t
ZCAgICAgKCopIC0gTWFya2Rvd24gZm9yIHBkZiBmb3JtYXQKCSMgfC0gaHRtbC8qLmh0bWwg
ICAgICgqKSAtIHJlbmRlcmVkIGh0bWwgZGlyCgkjIHwtIHBkZi8qLnBkZiAgICAgICAoKikg
LSByZW5kZXJlZCBwZGYgZGlyCgkjCgkjICgqKSBkaXJlY3Rvcmllcy9maWxlcyBhcmUgYXV0
by1nZW5lcmF0ZWQgdXNpbmcKCSMgICAgYC4vbWFya3kucHkgLS1pbml0OyBtYWtlIHNjYW47
IG1ha2UgYWxswrQKCSMKCi5QSE9OWTogY2xlYW4KY2xlYW46CglybSAtcmYgLi9idWlsZC8q
IC4vaHRtbC8qIC4vcGRmLyoKCi5QSE9OWTogaHR0cGQKaHR0cGQ6CgljZCBodG1sICYmIHB5
dGhvbiAtbSBodHRwLnNlcnZlcgoKLlBIT05ZOiBzY2FuCnNjYW46CgkuL21hcmt5LnB5IC0t
c2NhbgoKIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMj
IyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjCgphbGxfbWQ6PQphbGxfYnVpbGQ6PQphbGxfaHRt
bDo9CmFsbF9wZGY6PQphbGxfdGV4Oj0KCi1pbmNsdWRlIGJ1aWxkLyoubWFrZSBidWlsZC8q
Ki8qLm1ha2UKCiMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMj
IyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIwoKLlBIT05ZOiBsaW5rCmJ1aWxkOiAkKGFs
bF9idWlsZCkKCi5QSE9OWTogaHRtbApodG1sOiAkKGFsbF9odG1sKQoKLlBIT05ZOiBwZGYK
cGRmOiAkKGFsbF9wZGYpCgouUEhPTlk6IHRleAp0ZXg6ICQoYWxsX3RleCkKCi5QSE9OWTog
YWxsCmFsbDogaHRtbCBwZGYKCi5QSE9OWTogbGlzdApsaXN0OgoJIyBtYXJreSBUQVJHRVRT
CgkjIyMjIyMjIyMjIyMjIyMKCSMgKiBgbWFrZSBzY2FuYCAtLSBGSUxFUzokKGFsbF9tZCkK
CSMgKiBgbWFrZSBidWlsZGAgLS0gYG1ha2UkKGFsbF9idWlsZClgCgkjICogYG1ha2UgaHRt
bGAgLS0gYG1ha2UkKGFsbF9odG1sKWAKCSMgKiBgbWFrZSBwZGZgIC0tIGBtYWtlJChhbGxf
cGRmKWAKCSMgKiBgbWFrZSB0ZXhgIC0tIGBtYWtlJChhbGxfdGV4KWAKCSMK
'''
pack_pandoc_run = '''
IyEvYmluL2Jhc2gKClsgJCMgPT0gMCBdICYmIGVjaG8gIiIiCiMgVXNhZ2U6ICQwOiA8Rk9S
TUFUPiA8SU5GSUxFPiA8T1VURklMRT4KIyBFeGFtcGxlOgojICQwIGh0bWwgYnVpbGQvZmls
ZS5odG1sLm1kIGh0bWwvZmlsZS5odG1sCiMgJDAgcGRmIGJ1aWxkL2ZpbGUucGRmLm1kIHBk
Zi9maWxlLnBkZgoiIiIgJiYgZXhpdCAxCgpQQU5ET0M9cGFuZG9jCgpNREVYVD1cCmFsbF9z
eW1ib2xzX2VzY2FwYWJsZStcCmludHJhd29yZF91bmRlcnNjb3JlcytcCmVzY2FwZWRfbGlu
ZV9icmVha3MrXApzcGFjZV9pbl9hdHhfaGVhZGVyK1wKbGlzdHNfd2l0aG91dF9wcmVjZWRp
bmdfYmxhbmtsaW5lK1wKaW5saW5lX2NvZGVfYXR0cmlidXRlcytcCnN0cmlrZW91dCtcCnlh
bWxfbWV0YWRhdGFfYmxvY2srXApwaXBlX3RhYmxlcytcCmxpbmVfYmxvY2tzK1wKaW1wbGlj
aXRfZmlndXJlcytcCmFiYnJldmlhdGlvbnMrXAppbmxpbmVfbm90ZXMKClBET1BUPSIiIgot
LXRhYmxlLW9mLWNvbnRlbnRzCi0tbnVtYmVyLXNlY3Rpb25zCiIiIgoKaWYgWyAkMSA9PSBo
dG1sIF0gOyB0aGVuCiRQQU5ET0MgIiQyIiBcCi0tZmlsdGVyIHBhbmRvYy14bm9zIFwKLS1j
aXRlcHJvYyBcCi0tZnJvbT1tYXJrZG93bityYXdfaHRtbCskTURFWFQgXAotLXRvPWh0bWw1
IFwKLS1zZWxmLWNvbnRhaW5lZCBcCi0tb3V0cHV0PSIkMyIgXAotLXJlc291cmNlLXBhdGg9
Ii4vYnVpbGQvIiBcCiRQRE9QVApmaQoKaWYgWyAkMSA9PSBwZGYgXSA7IHRoZW4KJFBBTkRP
QyAiJDIiIFwKLS1maWx0ZXIgcGFuZG9jLXhub3MgXAotLWNpdGVwcm9jIFwKLS1mcm9tPW1h
cmtkb3duK3Jhd190ZXgrJE1ERVhUIFwKLS10bz1sYXRleCBcCi0tb3V0cHV0PSIkMyIgXAot
LXJlc291cmNlLXBhdGg9Ii4vYnVpbGQvIiBcCi0tcGRmLWVuZ2luZT14ZWxhdGV4IFwKJFBE
T1BUCmZpCgppZiBbICQxID09IHRleCBdIDsgdGhlbgokUEFORE9DICIkMiIgXAotLWZpbHRl
ciBwYW5kb2MteG5vcyBcCi0tY2l0ZXByb2MgXAotLWZyb209bWFya2Rvd24rcmF3X3RleCsk
TURFWFQgXAotLXRvPWxhdGV4IFwKLS1vdXRwdXQ9IiQzIiBcCi0tcmVzb3VyY2UtcGF0aD0i
Li9idWlsZC8iIFwKJFBET1BUCmZpCg==
'''
pack_marky_md = '''
LS0tCnRpdGxlOiAiYG1hcmt5YCBEb2N1bWVudGF0aW9uICIKdGl0bGUtLXBkZjogIi0tIGBw
ZGZgIgp0aXRsZS0taHRtbDogIi0tIGBodG1sYCIKYmlibGlvZ3JhcGh5OiBkYXRhL21hcmt5
LmJpYgpoZWFkZXItaW5jbHVkZXMtLXBkZjogPgogICBcaHlwZXJzZXR1cHtjb2xvcmxpbmtz
PWZhbHNlLAogICBhbGxib3JkZXJjb2xvcnM9ezAgMCAwfSwKICAgcGRmYm9yZGVyc3R5bGU9
ey9TL1UvVyAxfX0KaGVhZGVyLWluY2x1ZGVzLS1odG1sOiA+CiAgIDxzdHlsZT4qIHsgYm94
LXNpemluZzogYm9yZGVyLWJveDsgfTwvc3R5bGU+Cnhub3MtY2xldmVyZWY6IHRydWUKeG5v
cy1jYXBpdGFsaXNlOiB0cnVlCmZvbnRzaXplOiAxMXB0CgotLS0KPD8KY29sID0gZm10Y29k
ZSgKCWh0bWw9IjxzcGFuIHN0eWxlPSdjb2xvcjp7MX07Jz57MH08L3NwYW4+IiwKCXBkZj1y
Ilx0ZXh0Y29sb3J7e3sxfX19e3t7MH19fSIKKQpkZWYgdGV4dF9wcm9jKGNtZCwgY3JvcD1U
cnVlKToKCWltcG9ydCBzdWJwcm9jZXNzIGFzIHNwCgl0ZXh0ID0gIiIKCWZvciBpIGluIHNw
LmNoZWNrX291dHB1dChjbWQuc3BsaXQoKSkuZGVjb2RlKCJ1dGYtOCIpLnNwbGl0KCJcbiIp
OgoJCWlmIG5vdCBjcm9wOgoJCQl0ZXh0ICs9IGkgKyAiXG4iCgkJZWxpZiBpLnN0YXJ0c3dp
dGgoIiMgIik6CgkJCXRleHQgKz0gaVsyOl0gKyAiXG4iCgkJZWxpZiBpID09ICIjIjoKCQkJ
dGV4dCArPSAiXG4iCgkJZWxpZiBpLnN0YXJ0c3dpdGgoIiMiKToKCQkJdGV4dCArPSBpICsg
IlxuIgoJcmV0dXJuIHRleHQKdmVyc2lvbiA9IHRleHRfcHJvYygicHl0aG9uIG1hcmt5LnB5
IC0tdmVyc2lvbiIsIGNyb3A9RmFsc2UpLnN0cmlwKCkKPz4KLS0tCgo+ICoqQWJzdHJhY3Qq
KiAtLSBgbWFya3lgIGlzIGEgcHJlcHJvY2Vzc29yIHdpdGggYW4gZWFzeSBhbmQgaW50dWl0
aXZlCj4gc3ludGF4IGZvciBleGVjdXRpb24gb2YgZW1iZWRkZWQge3tjb2woInB5aG9uIiwi
Ymx1ZSIpfX0gY29kZSBkdXJpbmcgcmVuZGVyaW5nCj4gYGh0bWxgIGFuZCBgcGRmYCBkb2N1
bWVudHMgZnJvbSBNYXJrZG93biB0ZXh0Lgo+IFRoaXMgZG9jdW1lbnQgaXMgY3JlYXRlZCB1
c2luZyBgbWFya3lgLCB2ZXJzaW9uICp7e3ZlcnNpb259fSouCj4gRm9yIG1vcmUgaW5mb3Jt
YXRpb24gcGxlYXNlIHJlZmVyIHRvIHRoZQo+IFtgbWFya3lgIHJlcG9zaXRvcnldKGh0dHBz
Oi8vZ2l0aHViLmNvbS9sZWhtYW5uNy9tYXJreSkuCgotLS0KCiMgYG1hcmt5YCBEeW5hbWlj
IE1hcmtkb3duCgpgbWFya3lgIGlzIGEgTWFya2Rvd24gcHJlcHJvY2Vzc29yIHdoaWNoIHRy
YW5zZm9ybXMgYSBNYXJrZG93biBkb2N1bWVudAp1c2luZyBweXRob24uIGBtYXJreWAgaW1w
bGVtZW50cyB0aHJlZSBzdGF0ZW1lbnRzIHdpdGggZXh0cmVtZWx5IGVhc3kKYW5kIGludHVp
dGl2ZSBzeW50YXgsIHdoaWNoIGFyZSBlbWJlZGRlZCBkaXJlY3RseSBpbiB0aGUgTWFya2Rv
d24gdGV4dDoKCjEuIGA8XD8uLi4/XD5gOiBQeXRob24gY29kZSBibG9jay4KMi4gYHtcey4u
Ln1cfWA6IGBmYC1zdHJpbmcgb3V0cHV0IGludG8gTWFya2Rvd24uCjMuIGBfX18oKWA6IEZ1
bmN0aW9uIGZvciBvdXRwdXQgaW50byBNYXJrZG93bi4KClVzaW5nIGA8XD8uLi4/XD5gIGFu
ZCBge1x7Li4ufVx9YCBweXRob24gcHJvY2Vzc2luZyBhbmQgYGZgLXN0cmluZyBvdXRwdXQK
aXMgZW1iZWRkZWQgZGlyZWN0bHkgaW5zaWRlIHRoZSBNYXJrZG93biB0ZXh0LiBVc2luZyB0
aGUgYF9fXygpYApmdW5jdGlvbiB0ZXh0IGlzIGdlbmVyYXRlZCBmcm9tIHB5dGhvbiBhbGdv
cml0aG1zIGFuZApkeW5hbWljYWxseSBpbnNlcnRlZCBpbnRvIHRoZSByZXN1bHRpbmcgTWFy
a2Rvd24uCgpUaGUgZm9sbG93aW5nIGV4YW1wbGUgY2FuIGJlIHByb2R1Y2VkIGJ5IGp1c3Qg
Y2FsbGluZwpgbWFrZSBwZGYvZmlsZWAgb3IgYG1ha2UgaHRtbC9maWxlYC4KCiMjIyMgRXhh
bXBsZTogYG1kL2ZpbGUubWRgIHstfQpgYGBtYXJrZG93bgotLS0KdGl0bGU6IEFuIEV4YW1w
bGUKLS0tCjxcPwpkZWYgY2FwX2ZpcnN0KHgpOgoJcmV0dXJuICIgIi5qb2luKFtpWzBdLnVw
cGVyKCkgKyBpWzE6XSBmb3IgaSBpbiBpLnNwbGl0KCldKQpmb3IgaSBpbiBbInZlcnkiLCAi
bm90IHNvIl06Cgk/XD4KKip7XHtjYXBfZmlyc3QoaSl9XH0gU2VjdGlvbioqCgpUbyBkYXkg
aXMgYSB7XHtpfVx9IHZlcnkgbmljZSBkYXkuClRoZSBzdW4gaXMgc2hpbmluZyB7XHtpfVx9
IGJyaWdodCBhbmQKdGhlIGJpcmRzIGFyZSBzaW5naW5nIHtce2l9XH0gbG91ZCBhbmQKZmx5
IHtce2l9XH0gaGlnaCBpbiB0aGUge1x7aX1cfSBibHVlIHNreS4KCTxcPwo/XD4KYGBgCiMj
IyMgT3V0cHV0IGBidWlsZC9maWxlLm1kYCB7LX0KYGBgbWFya2Rvd24KLS0tCnRpdGxlOiBB
biBFeGFtcGxlCi0tLQo8PwpkZWYgY2FwX2ZpcnN0KHgpOgoJcmV0dXJuICIgIi5qb2luKFtp
WzBdLnVwcGVyKCkgKyBpWzE6XSBmb3IgaSBpbiBpLnNwbGl0KCldKQpmb3IgaSBpbiBbInZl
cnkiLCAibm90IHNvIl06Cgk/PgoqKnt7Y2FwX2ZpcnN0KGkpfX0gU2VjdGlvbioqCgpUbyBk
YXkgaXMgYSB7e2l9fSB2ZXJ5IG5pY2UgZGF5LgpUaGUgc3VuIGlzIHNoaW5pbmcge3tpfX0g
YnJpZ2h0IGFuZAp0aGUgYmlyZHMgYXJlIHNpbmdpbmcge3tpfX0gbG91ZCBhbmQKZmx5IHt7
aX19IGhpZ2ggaW4gdGhlIHt7aX19IGJsdWUgc2t5LgoJPD8KPz4KYGBgCgojIEhvdyBkb2Vz
IGBtYXJreWAgd29yayBpbnRlcm5hbGx5PwoKYG1hcmt5YCB1c2VzIGFuIGV4dHJlbWVseSBz
aW1wbGUgbWVjaGFuaXNtIGZvciBnZW5lcmF0aW5nIGEgcHl0aG9uIHByb2dyYW1tCmZyb20g
dGhlIE1hcmtkb3duIHRleHQuIFVzaW5nIHRoZSBgPFw/Li4uP1w+YCBhbmQgYHtcey4uLn1c
fWAgc3RhdGVtZW50LApQeXRob24gY29kZSBpcyBlbWJlZGRlZCBpbnRvIHRoZSBNYXJrZG93
biB0ZXh0IGFuZCB0cmFuc2xhdGVkIGludG8gYSBzZXJpZXMKb2YgY2FsbHMgdG8gdGhlIGBf
X18oKWAgZnVuY3Rpb24gdXNpbmcgYGZgLXN0cmluZ3MgYXMgYXJndW1lbnRzLCB3aGVyZQpw
eXRob24gdmFyaWFibGVzIGFyZSByZWZlcmVuY2VkLiBUaGlzIHJlc3VsdHMgaW50byBhIHB5
dGhvbiBwcm9ncmFtCndoaWNoIGNhbiBnZW5lcmF0ZSBNYXJrZG93biB0ZXh0IGFsZ29yaXRo
bWljYWxseS4KCiMjIyMgRXhhbXBsZTogYG1kL2ZpbGUubWRgIHstfQpgYGBwaHAKKiBUaGlz
IGlzIHtmaXJzdH0uIDxcPwp4ID0gMSAjIHRoaXMgaXMgY29kZQpmb3IgaSBpbiByYW5nZSgz
KToKCWlmIHg6CgkJP1w+Cntce2krMX1cfS4gVGhlIHZhbHVlIGlzIHtce1x7eH1cfVx9Lgo8
XD8KCWVsc2U6CgkJP1w+e1x7aSsxfVx9LiBUaGUgdmFsdWUgaXMgemVyby4KPFw/Cgl4ID0g
MAo/XD4qIFRoaXMgaXMgbGFzdC4KYGBgClRoZSBmaWxlIHByb2R1Y2VzIHRoZSBmb2xsb3dp
bmcgTWFya2Rvd24gb3V0cHV0LgoKIyMjIyBPdXRwdXQ6IE1hcmtkb3duIHstfQpgYGBiYXNo
CiogVGhpcyBpcyB7Zmlyc3R9LiA8Pwp4ID0gMSAjIHRoaXMgaXMgY29kZQpmb3IgaSBpbiBy
YW5nZSgzKToKCWlmIHg6CgkJPz4Ke3tpKzF9fS4gVGhlIHZhbHVlIGlzIHt7e3h9fX0uCjw/
CgllbHNlOgoJCT8+e3tpKzF9fS4gVGhlIHZhbHVlIGlzIHplcm8uCjw/Cgl4ID0gMAo/Piog
VGhpcyBpcyBsYXN0LgpgYGAKCmBtYXJreWAgdHJhbnNmb3JtcyB0aGUgTWFya2Rvd24gaW50
byBQeXRob24gc291cmNlIGNvZGUuCkV4ZWN1dGlvbiBvZiB0aGUgUHl0aG9uIHNvdXJjZSBj
b2RlIHlpZWxkcyB0aGUgbmV3IE1hcmtkb3duIHRleHQuCgojIyMjIE91dHB1dDogYGJ1aWxk
L2ZpbGUucHlgIHstfQpgYGBweXRob24KX19fKHJmIiIiKiBUaGlzIGlzIHtce2ZpcnN0fVx9
LiAiIiIsIF9fXyk7CnggPSAxICMgdGhpcyBpcyBjb2RlCmZvciBpIGluIHJhbmdlKDMpOgoJ
aWYgeDoKCQlfX18ocmYiIiIKe2krMX0uIFRoZSB2YWx1ZSBpcyB7XHtce3h9XH1cfS4KIiIi
LCBfX18pOwoJZWxzZToKCQlfX18ocmYiIiJ7aSsxfS4gVGhlIHZhbHVlIGlzIHplcm8uCiIi
IiwgX19fKTsKCXggPSAwCl9fXyhyZiIiIiogVGhpcyBpcyBsYXN0LgoiIiIsIF9fXyk7CmBg
YAoKIyBRdWljayBTdGFydAoKIyMgYG1hcmt5YCBEZXBlbmRlbmNpZXMKCmBtYXJreWAgZGVw
ZW5kcyBvbiBgcGFuZG9jYCBhbmQgYHB5eWFtbGAuIGBwYW5kb2NgIGlzIHVzZWQgZm9yIHJl
bmRlcmluZwp0aGUgTWFya2Rvd24gaW50byBgaHRtbGAgYW5kIGBwZGZgLiBgbWFya3lgIHVz
ZXMKW3BhbmRvY10oaHR0cHM6Ly93d3cucGFuZG9jLm9yZy8pIGZvciByZW5kZXJpbmcgYGh0
bWxgIGFuZCBgcGRmYC4KYHBhbmRvYz49Mi4xMGAgcmVsZWFzZXMgY2FuIGJlIGZvdW5kClto
ZXJlXShodHRwczovL2dpdGh1Yi5jb20vamdtL3BhbmRvYy9yZWxlYXNlcykuClRoZSBvdGhl
ciBwYWNrYWdlcyBjYW4gYmUgaW5zdGFsbGVkIHdpdGggYHBpcGAuCgpgYGBiYXNoCnBpcCBp
bnN0YWxsIHBhbmRvYy1maWdub3MKcGlwIGluc3RhbGwgcGFuZG9jLWVxbm9zCnBpcCBpbnN0
YWxsIHBhbmRvYy1zZWNub3MKcGlwIGluc3RhbGwgcGFuZG9jLXRhYmxlbm9zCnBpcCBpbnN0
YWxsIHBhbmRvYy14bm9zCnBpcCBpbnN0YWxsIHB5eWFtbApgYGAKCiMjIGBtYXJreWAgV29y
a2Zsb3cKCldvcmtmbG93IGZvciBjcmVhdGluZyBgaHRtbGAgb3IgYHBkZmAgdXNpbmcgYG1h
cmt5YCBieQppbnZvY2F0aW9uIG9mIGBtYWtlIHNjYW5gIGFuZCBgbWFrZSBhbGxgLgoKKm1h
a2UqfDEuICp3cml0ZSogIHwgIHwyLiAqYnVpbGQqICAgICAgICAgIHwgIHwzLiAqcmVuZGVy
KgotLS0tLS18LS0tLS0tLS0tLS0tfC0tfC0tLS0tLS0tLS0tLS0tLS0tLS0tfC0tfC0tLS0t
LS0tLS0tLS0tLS0KYHBkZmAgfCAgICAgICAgICAgIHwgIHxgYnVpbGQvZmlsZS5odG1sLm1k
YHwtPnxgaHRtbC9maWxlLmh0bWxgCmAtYCAgIHxgbWQvZmlsZS5tZGB8LT58ICAgICAgICAg
ICAgICAgICAgICB8ICB8CmBoZm1sYHwgICAgICAgICAgICB8ICB8YGJ1aWxkL2ZpbGUucGRm
Lm1kYCB8LT58YHBkZi9maWxlLnBkZmAKCjEuICoqd3JpdGUqKjogdXNlciB3cml0ZXMgYSBN
YXJrZG93biB0ZXh0IGZpbGUgYW5kIHBsYWNlcyBpdCBpbiBgbWQvKi5tZGAKZGlyZWN0b3J5
IHdpdGggdGhlIGV4dGVuc2lvbiBgLm1kYC4KMi4gKipidWlsZCoqOiBtYXJreWAgdHJhbnNm
b3JtcyB0aGUgZmlsZXMgaW4gYG1kLyoubWRgIGludG8gcmVndWxhciBNYXJrZG93biB0ZXh0
CmFuZCBwbGFjZXMgdGhlIHRyYW5zZm9ybWVkIGZpbGVzIGluIGBidWlsZC9gLgozLiAqKnJl
bmRlcioqOiB0aGUgcmVndWxhciBNYXJrZG93biB0ZXh0IGluIHRoZSBmaWxlcyBgYnVpbGQv
Ki5tZGAgaXMgcmVuZGVyZWQgaW50bwpgaHRtbGAgYW5kIGBwZGZgIHVzaW5nIGBwYW5kb2Ng
LgoKVGhlIHRocmVlIHN0ZXBzIGFyZSBpbXBsZW1lbnRlZCBpbiBhIE1ha2VmaWxlLgoKIyMg
RG93bmxvYWQgYW5kIEluaXRpYWxpemUKCmBtYXJreWAgaXMgc3VwcGxpZWQgYXMgYSBzaW5n
bGUtZmlsZSBzY3JpcHQgd2hpY2ggYXV0b21hdGljYWxseQpzZXRzIHVwIHRoZSBwcm9qZWN0
IHN0cnVjdHVyZSBjb250YWluaW5nIGFsbCBzY3JpcHRzCnJlcXVpcmVkIGZvciBwcm9jZXNz
aW5nIGFuZCByZW5kZXJpbmcgTWFya2Rvd24uCgpGb3IgZXhhbXBsZSwgZG93bmxvYWQgYG1h
cmt5YCBmcm9tIGdpdGh1Yi4KYGBgYmFzaApnaXQgY2xvbmUgaHR0cHM6Ly9sZWhtYW5uNy5n
aXRodWIuY29tL21hcmt5LmdpdApjZCBtYXJreQpgYGAKCkFmdGVyIGRvd25sb2FkLCB0aGUg
YG1hcmt5YCBlbnZpcm9ubWVudCBpcyBpbml0aWFsaXplZCB1c2luZyBgbWFya3lgLgpgYGBi
YXNoCi4vbWFya3kucHkgLS1pbml0CiMgbWtkaXIgYnVpbGQvCiMgbWtkaXIgZGF0YQojIG1r
ZGlyIG1kLwojIFdSSVRFIE1ha2VmaWxlCiMgV1JJVEUgcGFuZG9jLXJ1bgojIFdSSVRFIG1k
L21hcmt5Lm1kCiMgV1JJVEUgLmdpdGlnbm9yZQojIFVTQUdFCm1ha2UgaGVscApgYGAKCiMj
IGBtYXJreWAgRW52aXJvbm1lbnQKCkR1cmluZyBpbml0aWFsaXphdGlvbiwgYG1hcmt5YCBj
cmVhdGVzIGRpcmVjdG9yaWVzIGFuZCBmaWxlcy4KQWZ0ZXIgaW5pdGlhbGl6YXRpb24sIHRo
ZSBmb2xsb3dpbmcgc3RydWN0dXJlIGlzIGF1dG8tZ2VuZXJhdGVkCmluIHRoZSBwcm9qZWN0
IGRpcmVjdG9yeS4gYG1hcmt5YCBzaG93cyB0aGUgcHJvamVjdCBzdHJ1Y3R1cmUKd2hlbiBp
bnZva2luZyBgbWFrZSB0cmVlYC4KYGBgYmFzaAo8PwpfX18odGV4dF9wcm9jKCJtYWtlIHRy
ZWUiKSkKPz4KYGBgCgpUaGUgc2NyaXB0IGBwYW5kb2MtcnVuYCBjYW4gYmUgYWRqdXN0ZWQg
aW4gY2FzZSBzcGVjaWZpYwpgcGFuZG9jYCBvcHRpb25zIGFyZSByZXF1aXJlZCBmb3IgcmVu
ZGVyaW5nIHRoZSBgaHRtbGAgYW5kIGBwZGZgIGRvY3VtZW50cy4KCiMjIERvY3VtZW50IFJl
bmRlcmluZwoKQnkgaW52b2tpbmcgYG1ha2UgYWxsYCBhbGwgZmlsZXMgYG1kLyoubWRgIGFy
ZSB0cmFuc2Zvcm1lZAppbnRvIGNvcnJlc3BvbmRpbmcgYGh0bWwvKi5odG1sYCBhbmQgYHBk
Zi8qLnBkZmAgZmlsZXMuIEJ5Cmludm9raW5nIGBtYWtlIGh0dHBkYCBhIHB5dGhvbiB3ZWIg
c2VydmVyIGlzIHN0YXJ0ZWQgaW4gYGh0bWwvYC4KCkFsbCB1c2VyLWdlbmVyYXRlZCBNYXJr
ZG93biBjb250ZW50IGdvZXMgaW50byBgbWQvKmAgdXNlci1nZW5lcmF0ZWQKZGF0YSBmaWxl
cyBnbyBpbnRvIGBkYXRhLypgLgoKKipBVFRFTlRJT046KiogVGhlIGZpbGVzIGluIHRoZSBk
aXJlY3RvcmllcyBgYnVpbGQvKmAgYXJlCioqYXV0by1nZW5lcmF0ZWQqKi4gQWxsIHVzZXIg
ZmlsZXMgaGF2ZSB0byBiZSBwbGFjZWQgaW5zaWRlIHRoZQpkaXJlY3RvcnkgYG1kLypgLiBJ
bnZva2luZyBgbWFrZSBjbGVhbmAgd2lsbCAqKmRlbGV0ZSBhbGwgZmlsZXMqKgppbiBgaHRt
bC9gLCBgYnVpbGQvYCBhbmQgYHBkZi9gLgoKIyMgSW50ZWdyYXRlZCBEb2N1bWVudGF0aW9u
CgpgbWFya3lgIGhhcyBhbiBpbnRlZ3JhdGVkIGVudmlyb25tZW50LiBVc2luZyBgbWFrZSBo
ZWxwYCBkaXNwbGF5cwphIHNob3J0IGluZm8gYWJvdXQgdGhlIGBtYXJreWAgZGVwZW5kZW5j
aWVzLCBtYWtlIHRhcmdldHMgYW5kCmV4YW1wbGVzLgpgYGBiYXNoCjw/Cl9fXyh0ZXh0X3By
b2MoIm1ha2UgaGVscCIpKQo/PgpgYGAKCiMgYG1hcmt5YCBGZWF0dXJlcwoKUGxhY2UgYSBu
ZXcgZmlsZSBpbiBgbWQvZmlsZS5tZGAgYW5kIHJ1biB0aGUgZm9sbG93aW5nIGNvbW1hbmRz
LgpgYGBiYXNoCnRvdWNoIG1kL2ZpbGUubWQKYGBgCgpgbWFya3lgIGRpc2NvdmVycyB0aGUg
bmV3IGRvY3VtZW50IHdoZW4gaW52b2tpbmcgYG1ha2Ugc2NhbmAuCmBgYGJhc2gKbWFrZSBz
Y2FuCiMgV1JJVEUgYnVpbGQvZmlsZS5tYWtlCmBgYAoKYG1hcmt5YCByZW5kZXJzIGBodG1s
YCBhbmQgYHBkZmAgdXNpbmcgbWFrZSB0YXJnZXRzLgpgYGBiYXNoCm1ha2UgaHRtbC9maWxl
Cm1ha2UgcGRmL2ZpbGUKYGBgCgojIyBNZXRhIERhdGEgaW4gRnJvbnQgTWF0dGVyCgpJZiBk
b2N1bWVudCBzdGFydHMgd2l0aCBgLS0tYCwgeWFtbCBpcyB1c2VkIHRvIHBhcnNlCnRoZSBm
cm9udCBtYXR0ZXIgYmxvY2sgZGVsaW1pdGVkIGJ5IGAtLS1gLgpBbGwgbWV0YSBkYXRhIGtl
eXMgd2lsbCBiZSBleHBvc2VkIGludG8gdGhlIHB5dGhvbiBzY29wZSBhcyBhIGxvY2FsCnZh
cmlhYmxlLCB1bmxlc3MgdGhlIHZhcmlhYmxlIGFscmVhZHkgZXhpc3RzLgoKYGBgbWQKLS0t
CnRpdGxlOiAiTXkgRG9jdW1ldCIKYXV0aG9yOiAuLi4KZGF0ZTogMjAyMi0wMS0wMQotLS0K
VGhlIHRpdGxlIG9mIHRoaXMgZG9jdW1lbnQgaXMge1x7dGl0bGV9XH0uCmBgYAoKIyMgRW1i
ZWRkaW5nIFB5dGhvbiBDb2RlCgpQeXRob24gY29kZSBibG9ja3MgYXJlIGVtYmVkZGVkIGlu
dG8gTWFya2Rvd24gdXNpbmcgYDxcPy4uLj9cPmAgYW5kIGB7XHsuLi59XH1gLgpBbGwgY29k
ZSBibG9ja3Mgc3BhbiBvbmUgbGFyZ2Ugc2NvcGUgc2hhcmluZyBmdW5jdGlvbnMgYW5kIGxv
Y2FsCnZhcmlhYmxlcy4gTWV0YSBkYXRhIGlzIGltcG9ydGVkIGZyb20gTWFya2Rvd24gZnJv
bnQgbWF0dGVyIGFzIGxvY2FsCnZhcmlhYmxlcyBpbiB0aGUgcHl0aG9uIHNjb3BlLiBUaGUg
YGltcG9ydGAgc3RhdGVtZW50IGNhbiBiZSB1c2VkIGluCnB5dGhvbiBjb2RlIGluIG9yZGVy
IHRvIGFjY2VzcyBpbnN0YWxsZWQgcHl0aG9uIHBhY2thZ2VzIGFzIHVzdWFsLgoKIyMjIFZp
c2libGUgQ29kZQoKVXNpbmcgYDxcPyEuLi4/XD5gIGNvZGUgaXMgZXhlY3V0ZWQgYW5kIGFs
c28gc2hvd24gaW4gTWFya2Rvd24uCgojIyMjIEV4YW1wbGUgey19CmBgYHB5dGhvbgo8XD8h
CnggPSA0MiAjIHZpc2libGUgY29kZQpwcmludCgiSGVsbG8gY29uc29sZSEiKQo/XD4KYGBg
CgojIyMjIFJ1biBhbmQgT3V0cHV0IHstfQpgYGBweXRob248PyEKeCA9IDQyICMgdmlzaWJs
ZSBjb2RlCj8+CmBgYAoKKipBVFRFTlRJT046KiogVXNpbmcgdGhlIGBwcmludCgpYCBmdW5j
dGlvbiB0aGUgdGV4dCB3aWxsIGJlIHByaW50ZWQKdG8gdGhlIGNvbnNvbGUgYW5kICoqbm90
KiogaW5zaWRlIHRoZSByZXN1bHRpbmcgTWFya2Rvd24gdGV4dC4KCiMjIyBIaWRkZW4gQ29k
ZQoKVXNpbmcgYDxcPy4uLj9cPmAgY29kZSBpcyBleGVjdXRlZCBidXQgbm90IHNob3duIGlu
IE1hcmtkb3duLgoKIyMjIyBFeGFtcGxlIHstfQpgYGBweXRob24KPFw/CnggPSA0MSAjIGhp
ZGRlbiBjb2RlCl9fXyhmIk91dHB1dCB0byBNYXJrZG93bi4geCA9IHt4fSEiKQo/XD4KYGBg
CiMjIyMgUnVuIGFuZCBPdXRwdXQgey19CmBgYHB5dGhvbgo8Pwp4ID0gNDEgIyBoaWRkZW4g
Y29kZQpfX18oZiJPdXRwdXQgdG8gTWFya2Rvd24uIHggPSB7eH0hIikKPz4KYGBgCgoqKkFU
VEVOVElPTjoqKiBVc2luZyB0aGUgYF9fXygpYCBmdW5jdGlvbiB0aGUgdGV4dCB3aWxsIGJl
IHByaW50ZWQKaW5zaWRlIHRoZSByZXN1bHRpbmcgTWFya2Rvd24gdGV4dCAqKmFuZCBub3Qq
KiBvbiB0aGUgY29uc29sZS4KCiMjIFRoZSBgX19fKClgIEZ1bmN0aW9uCgpVc2luZyB0aGUg
YHByaW50KClgIHN0YXRlbWVudCB0aGUgdGV4dCB3aWxsIGJlIHByaW50ZWQgdG8gdGhlIGNv
bnNvbGUuCldoZW4gdXNpbmcgdGhlIGBfX18oKWAgc3RhdGVtZW50IG5ldyBNYXJrZG93biB0
ZXh0IGlzCmluc2VydGVkIGR5bmFtaWNhbGx5IGludG8gdGhlIGRvY3VtZW50IGR1cmluZyBw
cmVwcm9jZXNzaW5nLgoKIyMjIyBFeGFtcGxlOiBMaW5lIEJyZWFrIHstfQpgYGBweXRob24K
PFw/CnggPSA0MCAjIGhpZGRlbiBjb2RlCl9fXygiT3V0cHV0IGluIiwgX19fKQpfX18oInNp
bmdsZSBsaW5lISAiLCBfX18pCl9fXyhmInggPSB7eH0iKQo/XD4KYGBgCiMjIyMgUnVuIGFu
ZCBPdXRwdXQgey19CmBgYGJhc2gKPD8KeCA9IDQwICMgaGlkZGVuIGNvZGUKX19fKCJPdXRw
dXQgaW4gIiwgX19fKQpfX18oInNpbmdsZSBsaW5lISAiLCBfX18pCl9fXyhmInggPSB7eH0i
KQo/PgpgYGAKCiMjIyMgRXhhbXBsZTogU2hpZnQsIENyb3AsIFJldHVybiB7LX0KYGBgcHl0
aG9uCjxcPwpyZXN1bHQgPSBfX18oIiIiCiAgICogdGV4dCBpcyBjcm9wcGVkIGFuZCBzaGlm
dGVkCiAgICAgICAgICogc2hpZnQgYW5kIGNyb3AKICAgICAgICAgICAgKiBjYW4gYmUgY29t
YmluZWQKICAgICAgICAgICogcmV0dXJuaW5nIHRoZSByZXN1bHQKIiIiLCBzaGlmdD0iIyMj
IyMjIyMiLCBjcm9wPVRydWUsIHJldD1UcnVlKQpfX18ocmVzdWx0KQo/XD4KYGBgCiMjIyMg
UnVuIGFuZCBPdXRwdXQgey19CmBgYGJhc2gKPD8KcmVzdWx0ID0gX19fKCIiIgogICAqIHRl
eHQgaXMgY3JvcHBlZCBhbmQgc2hpZnRlZAogICAgICAgICAqIHNoaWZ0IGFuZCBjcm9wCiAg
ICAgICAgICAgICogY2FuIGJlIGNvbWJpbmVkCiAgICAgICAgICAqIHJldHVybmluZyB0aGUg
cmVzdWx0CiIiIiwgc2hpZnQ9IiMjIyMjIyMjIiwgY3JvcD1UcnVlLCByZXQ9VHJ1ZSkKX19f
KHJlc3VsdCkKPz4KYGBgCgojIyBBbGdvcml0aG1pYyBUYWJsZSBFeGFtcGxlCgpAdGJsOmFs
Z3QgaXMgZ2VuZXJhdGVkIHVzaW5nIHRoZSBmb2xsb3dpbmcgcHl0aG9uIGNsb2RlIGJsb2Nr
LgoKYGBgcHl0aG9uPD8hCm4gPSA1CnRhYmxlID0gIiIKZGVjID0gWyIqJXMqIiwgIioqJXMq
KiIsICJ+fiVzfn4iLCAiYCVzYCIsCiAgICAgICByIiRcdGltZXNeJXMkIiwgIiRcaW5mdHlf
JXMkIl0KdGFibGUgKz0gInwiLmpvaW4oIlgiKm4pICsgIlxuIiArICJ8Ii5qb2luKCItIipu
KSArICJcbiIKZm9yIGkgaW4gcmFuZ2Uobik6CglmaWxsID0gW2NocihvcmQoIkEiKSsoMipp
KzMqayklMjYpIGZvciBrIGluIHJhbmdlKGkrMSldCglmaWxsID0gW2RlY1sobCtpKSVsZW4o
ZGVjKV0layBmb3IgbCwgayBpbiBlbnVtZXJhdGUoZmlsbCldCgl0ZXh0ID0gbGlzdCgiMCIp
Km4KCXRleHRbKG4+PjEpLShpPj4xKToobj4+MSkrKGk+PjEpXSA9IGZpbGwKCXRhYmxlICs9
ICJ8Ii5qb2luKHRleHQpICsgIlxuIgo/PgpgYGAKCnt7dGFibGV9fQoKVGFibGU6IFRhYmxl
IGlzIGdlbmVyYXRlZCB1c2luZyBjb2RlIGFuZCB0aGUgYF9fXygpYCBzdGF0ZW1lbnQuIHsj
dGJsOmFsZ3R9CgojIyBJbmxpbmUgRm9ybWF0dGVkIE91dHB1dAoKVGhlIGB7XHsuLi59XH1g
IHN0YXRlbWVudCB1c2VzIHNudGF4IHNpbWlsYXIgdG8gcHl0aG9uIGBmYC1zdHJpbmdzIGZv
cgpmb3JtYXR0ZWQgb3V0cHV0IG9mIHZhcmlhYmxlcyBhbmQgcmVzdWx0cyBvZiBleHByZXNz
aW9ucyBpbnRvIE1hcmtkb3duCnRleHQuIFRoZSBgbWFya3lgIG9wZXJhdG9yIGB7XHs8ZXhw
cmVzc2lvbj5bOjxmb3JtYXQ+XX1cfWAgdXNlcyB0aGUKc3ludGF4IG9mIFtgZmAtc3RyaW5n
c10oaHR0cHM6Ly9kb2NzLnB5dGhvbi5vcmcvMy9yZWZlcmVuY2UvbGV4aWNhbF9hbmFseXNp
cy5odG1sI2Ytc3RyaW5ncykuCgojIyMjIEV4YW1wbGUgMSB7LX0KYGBgYmFzaApgeGAgaXMg
e1x7eH1cfSBhbmQge1x7IiwiLmpvaW4oW3N0cihpKSBmb3IgaSBpbiByYW5nZSh4LTEwLHgp
XSl9XH0uCmBgYAojIyMjIE91dHB1dCB7LX0KPiBgeGAgaXMge3t4fX0gYW5kIHt7IiwiLmpv
aW4oW3N0cihpKSBmb3IgaSBpbiByYW5nZSh4LTEwLHgpXSl9fS4KCiMjIyMgRXhhbXBsZSAy
IHstfQpgYGBweXRob248PyEKeCA9IGludCgxKQp5ID0gZmxvYXQoMi4zKQp6ID0gMAphID0g
WzEsIDIsIDNdCmIgPSAoNCwgNSkKPz4KYGBgCmBgYG1hcmtkb3duClRoaXMgaXMgYSBwYXJh
Z3JhcGggYW5kIHggaXMge1x7eDowM2R9XH0gYW5kIHkgaXMge1x7eTouMmZ9XH0uCk90aGVy
IGNvbnRlbnQgaXM6IGEgPSB7XHthfVx9LCBiID0ge1x7Yn1cfS4KYGBgCiMjIyMgT3V0cHV0
IHstfQo+IFRoaXMgaXMgYSBwYXJhZ3JhcGggYW5kIHggaXMge3t4OjAzZH19IGFuZCB5IGlz
IHt7eTouMmZ9fS4KPiBPdGhlciBjb250ZW50IGlzOiBhID0ge3thfX0sIGIgPSB7e2J9fS4K
CiMjIEZvcm1hdCBMaW5rIEV4dGVuc2lvbgoKV2hlbiB3cml0aW5nIG11bHRpcGxlIGRvY3Vt
ZW50cywgb2Z0ZW4gZG9jdW1lbnRzIGFyZSByZWZlcmVuY2VkCmJldHdlZW4gZWFjaCBvdGhl
ciB1c2luZyBsaW5rcy4gSW4gb3JkZXIgdG8gcmVmZXIgdG8gZXh0ZXJuYWwKYGh0bWxgIGFu
ZCBgcGRmYCBkb2N1bWVudHMgdGhlIE1hcmtkb3duIGxpbmsgc3RhdGVtZW50IGlzIHVzZWQu
CmBgYG1kCltMaW5rIENhcHRpb25dKHBhdGgvdG8vZmlsZS5odG1sKQpbTGluayBDYXB0aW9u
XShwYXRoL3RvL2ZpbGUucGRmKQpgYGAKT25lIGxpbmsgc3RhdGVtZW50IGNhbm5vdCBiZSB1
c2VkIGZvciByZW5kZXJpbmcgYGh0bWxgIGFuZCBgcGRmYAp3aXRoIGNvbnNpc3RlbnQgcGF0
aHMuIFVzaW5nIHRoZSBgbWFya3lgIGZvcm1hdCBsaW5rCiBgLlw/Pz9gIGZpbGUgZXh0ZW5z
aW9uIHJlc3VsdHMgaW4gY29uc2lzdGVudCBsaW5rcyBmb3IgYGh0bWxgIGFuZApgcGRmYCBk
b2N1bWVudHMuCgojIyMjIEV4YW1wbGUgey19CmBgYG1kCltMaW5rIHRvIHRoaXMgRG9jdW1l
bnRdKG1hcmt5Llw/Pz8pCmBgYAojIyMjIE91dHB1dCB7LX0KPiBbTGluayB0byB0aGlzIERv
Y3VtZW50XShtYXJreS4/Pz8pCgojIyBGb3JtYXQgQ29kZXMKCk9mdGVuIHdoZW4gd3JpdGlu
ZyBtYXJrZG93biBmb3IgYGh0bWxgIGFuZCBgcGRmYCBkb2N1bWVudHMsIHRoZQpvdXRwdXQg
bmVlZHMgdG8gYmUgdHdlYWtlZCBhY2NvcmRpbmdseS4KYG1hcmt5YCBzdXBwb3J0cyBmb3Jt
YXQgc3BlY2lmaWMgdHdlYWtpbmcgYnkgaW5qZWN0aW5nCnJhdyBgaHRtbGAgb3IgYHRleGAg
Y29kZSBpbnRvIE1hcmtkb3duIHVzaW5nIGZvcm1hdCBjb2Rlcy4KCkluIG9yZGVyIHRvIGlu
amVjdCBmb3JtYXQgc3BlY2lmaWMgY29kZSB0aGUgYGZtdGNvZGVgIGNsYXNzIGlzIHVzZWQu
ClRoZSBgZm10Y29kZWAgY2xhc3MgbWFuYWdlcyBpbmplY3Rpb24gb2YgYGh0bWxgIGFuZCBg
dGV4YCBjb2RlCmRlcGVuZGluZyBvbiB0aGUgb3V0cHV0IGZvcm1hdC4KCioqQVRURU5USU9O
OioqIGB0ZXhgIHBhY2thZ2VzIGhhdmUgdG8gYmUgaW5jbHVkZWQgZm9yIGBwZGZgIGFzIHdl
bGwgYXMKSmF2YVNjcmlwdCBhbmQgc3R5bGUgc2hlZXRzIGZvciBgaHRtbGAgdXNpbmcgdGhl
IG1ldGEgZGF0YSBmaWVsZHMKYGhlYWRlci1pbmNsdWRlcy0tcGRmYCBhbmQgYGhlYWRlci1p
bmNsdWRlcy0taHRtbGAgcmVzcGVjdGl2ZWx5LgoKIyMjIyBFeGFtcGxlOiBgZm10Y29kZWAg
ey19CmBgYHB5dGhvbjw/IQpGID0gZm10Y29kZShodG1sPSJIPHN1cD5UPC9zdXA+PHN1Yj5N
PC9zdWI+TCIsIHBkZj1yIlxMYVRlWCIpCj8+CmBgYApgYGBtYXJrZG93bgpJbnZvY2F0aW9u
IG9mIGZvcm1hdCBjb2RlIHJlc3VsdHMgaW46IHtce0YoKX1cfS4KYGBgCiMjIyMgT3V0cHV0
IHstfQo+IEludm9jYXRpb24gb2YgZm9ybWF0IGNvZGUgcmVzdWx0cyBpbjoge3tGKCl9fS4K
CiMjIyMgRXhhbXBsZTogQ29sb3Igey19CmBgYHB5dGhvbjw/IQpDID0gbGFtYmRhIGNvbG9y
OiBmbXRjb2RlKAoJaHRtbD0iPHNwYW4gc3R5bGU9J2NvbG9yOiVzOyc+ezB9PC9zcGFuPiIg
JSBjb2xvciwKCXBkZj1yIlx0ZXh0Y29sb3J7eyVzfX17e3swfX19IiAlIGNvbG9yCikKQiA9
IEMoImJsdWUiKQpSID0gQygicmVkIikKPz4KYGBgCmBgYG1hcmtkb3duClRleHQgd2l0aCB7
XHtCKCJibHVlIil9XH0gYW5kIHtce1IoIlJFRCIpfVx9LgpgYGAKIyMjIyBPdXRwdXQgey19
Cj4gVGV4dCB3aXRoIHt7QigiYmx1ZSIpfX0gYW5kIHt7UigiUkVEIil9fS4KCgojIyMjIEV4
YW1wbGU6IENsYXNzZXMgey19CmBgYHB5dGhvbjw/IQpjbGFzcyBjb2xvcjoKCWRlZiBfX2lu
aXRfXyhzZWxmLCBjb2xvcik6CgkJc2VsZi5jb2xvciA9IGNvbG9yCglkZWYgdXBwZXIoc2Vs
ZiwgeCk6CgkJcmV0dXJuIHNlbGYudGV4dCh4LnVwcGVyKCkpCglkZWYgbG93ZXIoc2VsZiwg
eCk6CgkJcmV0dXJuIHNlbGYudGV4dCh4Lmxvd2VyKCkpCgpjbGFzcyBodG1sKGNvbG9yKToK
CWRlZiB0ZXh0KHNlbGYsIHgpOgoJCXJldHVybiBmIjxzcGFuIHN0eWxlPSdjb2xvcjp7c2Vs
Zi5jb2xvcn07Jz57eH08L3NwYW4+IgoKY2xhc3MgcGRmKGNvbG9yKToKCWRlZiB0ZXh0KHNl
bGYsIHgpOgoJCXJldHVybiByZiJcdGV4dGNvbG9ye3t7c2VsZi5jb2xvcn19fXt7e3h9fX0i
CgpDQyA9IGxhbWJkYSB4OiBmbXRjb2RlKGh0bWw9aHRtbCh4KSwgcGRmPXBkZih4KSkKQkIg
PSBDQygiYmx1ZSIpClJSID0gQ0MoInJlZCIpCj8+CmBgYApgYGBtYXJrZG93bgpUZXh0IHdp
dGgge1x7QkIudXBwZXIoImJsdWUiKX1cfSBhbmQge1x7UlIubG93ZXIoIlJFRCIpfVx9Lgpg
YGAKIyMjIyBPdXRwdXQgey19Cj4gVGV4dCB3aXRoIHt7QkIudXBwZXIoImJsdWUiKX19IGFu
ZCB7e1JSLmxvd2VyKCJSRUQiKX19LgoKIyBNZXRhIERhdGEgaW4gRnJvbnQgTWF0dGVyCgpN
ZXRhIGRhdGEgaXMgYW5ub3RhdGVkIGluIHRoZSBmcm9udCBtYXR0ZXIgb2YgYSAJTWFya2Rv
d24gdGV4dCBkb2N1bWVudC4KVGhlIGZyb250IG1hdHRlciBtdXN0IHN0YXJ0IGluIHRoZSBm
aXJzdCBsaW5lIHdpdGggYC0tLWAgYW5kIHByZWNlZGVzIGFsbApvdGhlciB0ZXh0IGJlaW5n
IGZlbmNlZCBieSBgLS0tYC4gVGhlIG1ldGEgZGF0YSBpcyBpbiBgeWFtbGAgZm9ybWF0LgpU
aGUgYHlhbWxgIGJsb2NrIGlzIHBhcnNlZCB1c2luZyBgcHl0aG9uLXB5eWFtbGAuIEFsbCBt
ZXRhCmRhdGEgaXMgaW1wb3J0ZWQgaW50byB0aGUgcHJlcHJvY2Vzc2VkIGRvY3VtZW50LgoK
IyMgUGFuZG9jIEZyb250IE1hdHRlcgoKIyMjIyBFeGFtcGxlIHstfQpgYGB5YW1sCi0tLQp0
aXRsZTogTXkgRG9jdW1lbnQKZGF0ZTogMjAyMi0wMS0wMQphdXRob3I6IC4uLgpsaW5rLWNp
dGF0aW9uczogdHJ1ZQpiaWJsaW9ncmFwaHk6IGRhdGEvbWFya3kuYmliCmhlYWRlci1pbmNs
dWRlczogPgogICBcaHlwZXJzZXR1cHtjb2xvcmxpbmtzPWZhbHNlLAogICBhbGxib3JkZXJj
b2xvcnM9ezAgMCAwfSwKICAgcGRmYm9yZGVyc3R5bGU9ey9TL1UvVyAxfVx9Cnhub3MtY2xl
dmVyZWY6IHRydWUKeG5vcy1jYXBpdGFsaXNlOiB0cnVlCmZvbnRzaXplOiAxMXB0Ci0tLQpg
YGAKVGhlIG1ldGEgZGF0YSBmaWVsZHMKW2B0aXRsZWAsIGBkYXRlYCwgYGF1dGhvcmBdKGh0
dHBzOi8vcGFuZG9jLm9yZy9NQU5VQUwuaHRtbCNtZXRhZGF0YS12YXJpYWJsZXMpLApbYGxp
bmstY2l0YXRpb25zYF0oaHR0cHM6Ly9wYW5kb2Mub3JnL01BTlVBTC5odG1sI290aGVyLXJl
bGV2YW50LW1ldGFkYXRhLWZpZWxkcyksCltgYmlibGlvZ3JhcGh5YF0oaHR0cHM6Ly9wYW5k
b2Mub3JnL01BTlVBTC5odG1sI2NpdGF0aW9uLXJlbmRlcmluZykgYW5kCltgaGVhZGVyLWlu
Y2x1ZGVzYF0oaHR0cHM6Ly9wYW5kb2Mub3JnL01BTlVBTC5odG1sI3ZhcmlhYmxlcy1zZXQt
YXV0b21hdGljYWxseSkKYXJlIHByb2Nlc3NlZCBieSBgcGFuZG9jYCBkdXJpbmcgZG9jdW1l
bnQgcmVuZGVyaW5nLiBgZm9udHNpemVgIGFkanVzdHMgdGhlCmZvbnQgc2l6ZSBpbiBbYGh0
bWxgXShodHRwczovL3BhbmRvYy5vcmcvTUFOVUFMLmh0bWwjdmFyaWFibGVzLWZvci1odG1s
KQphbmQgW2BwZGZgXShodHRwczovL3BhbmRvYy5vcmcvTUFOVUFMLmh0bWwjdmFyaWFibGVz
LWZvci1sYXRleCkgZG9jdW1lbnRzLgpUaGUgYHhub3MtY2xldmVyZWZgIGFuZCBgeG5vcy1j
YXBpdGFsaXNlYApmaWVsZHMgYXJlIHVzZWQgYnkgdGhlIFtgcGFuZG9jLXhub3NgXShodHRw
czovL2dpdGh1Yi5jb20vdG9tZHVjay9wYW5kb2MteG5vcykKZXh0ZW5zaW9ucyBmb3IgcmVm
ZXJlbmNpbmcKW2ZpZ3VyZXNdKGh0dHBzOi8vZ2l0aHViLmNvbS90b21kdWNrL3BhbmRvYy1m
aWdub3MjY3VzdG9taXphdGlvbiksClt0YWJsZXNdKGh0dHBzOi8vZ2l0aHViLmNvbS90b21k
dWNrL3BhbmRvYy10YWJsZW5vcyNjdXN0b21pemF0aW9uKSwKW3NlY3Rpb25zXShodHRwczov
L2dpdGh1Yi5jb20vdG9tZHVjay9wYW5kb2Mtc2Vjbm9zI2N1c3RvbWl6YXRpb24pIGFuZApb
ZXF1YXRpb25zXShodHRwczovL2dpdGh1Yi5jb20vdG9tZHVjay9wYW5kb2MtZXFub3MjY3Vz
dG9taXphdGlvbikuCgojIyBgbWFya3lgIEZvcm1hdCBGaWVsZHMKCioqRXhhbXBsZSoqCmBg
YHlhbWwKLS0tCmhlYWRlci1pbmNsdWRlcy0tcGRmOiA+CiAgXGh5cGVyc2V0dXB7CiAgY29s
b3JsaW5rcz1mYWxzZSwKICBhbGxib3JkZXJjb2xvcnM9ezAgMCAwfSwKICBwZGZib3JkZXJz
dHlsZT17L1MvVS9XIDF9XH0KaGVhZGVyLWluY2x1ZGVzLS1odG1sOiA+CiAgPHN0eWxlPiog
eyBib3gtc2l6aW5nOiBib3JkZXItYm94OyB9PC9zdHlsZT4KLS0tCmBgYAoKVGhlIHBhbmRv
YyBgaGVhZGVyLWluY2x1ZGVzYCBmaWVsZCBpcyB1c2VkIGZvciBgcGRmYCBhbmQgYGh0bWxg
IGRvY3VtZW50cywKdGhlcmVmb3JlIGl0IG11c3QgY29udGFpbiBjb3JyZXNwb25kaW5nIHRl
eCBhbmQgYGh0bWxgIGNvZGUuCgpUaGUgZmllbGQgYGhlYWRlci1pbmNsdWRlc2AgZW5kaW5n
IHdpdGggYC0tcGRmYCBvciBgLS1odG1sYApzcGVjaWZpZXMgY29ycmVzcG9uZGluZyBvcHRp
b25zIGZvciB0aGUgZ2VuZXJhdGlvbiBvZiBgcGRmYCBhbmQgYGh0bWxgCmRvY3VtZW50cy4g
RHVyaW5nIG1ha2UsIGBtYXJreWAgc2NhbnMgYWxsIG1ldGEgZGF0YSBmaWVsZHMsIGFuZApm
aWVsZHMgd2hpY2ggZW5kIHdpdGggYC0tcGRmYCBhbmQgYC0taHRtbGAgYXJlIHNlbGVjdGVk
IGFuZCBmb3J3YXJkZWQKdG8gYHBhbmRvY2AgYmFzZWQgb24gdGhlIGZvcm1hdCB0byBiZSBy
ZW5kZXJlZC4KCiMgU2NpZW50aWZpYyBXcml0aW5nIGluIE1hcmtkb3duIHsjc2VjOnBhbm1k
fQoKW01hcmtkb3duXShodHRwczovL3BhbmRvYy5vcmcvTUFOVUFMLmh0bWwjcGFuZG9jcy1t
YXJrZG93bikgaXMgYSBtYXJrdXAKbGFuZ3VhZ2UgZm9yIHRlY2huaWNhbCB3cml0aW5nLCB3
aXRoIGVtcGhhc2lzIG9uIHJlYWRhYmlsaXR5LiBNYXJrZG93bgpjYW4gYmUgcmVuZGVyZWQg
aW4gbWFueSBmb3JtYXRzIGluY2x1ZGluZyBgaHRtbGAgYW5kIGBwZGZgIGJ5IHVzaW5nCltg
cGFuZG9jYF0oaHR0cHM6Ly9wYW5kb2Mub3JnLykgZm9yIGV4YW1wbGUuCgpVc2luZyB2YXJp
b3VzIE1hcmtkb3duIGV4dGVuc2lvbnMgb2YgYHBhbmRvY2AgYSBzdWZmaWNpZW50IHN0cnVj
dHVyZSBmb3IKd3JpdGluZyBzY2llbnRpZmljIGRvY3VtZW50cyBpcyByZWZsZWN0ZWQgdXNp
bmcgTWFya2Rvd24gc3ludGF4LgpgbWFya3lgIGJ5IGRlZmF1bHQgdXNlcyB0aGUgZm9sbG93
aW5nIGBwYW5kb2NgIE1hcmtkb3duIGV4dGVuc2lvbnMuCiogcGFyc2luZyBleHRlbnNpb25z
CgkqIFthbGxfc3ltYm9sc19lc2NhcGFibGVdKGh0dHBzOi8vcGFuZG9jLm9yZy9NQU5VQUwu
aHRtbCNleHRlbnNpb24tYWxsX3N5bWJvbHNfZXNjYXBhYmxlKQoJKiBbaW50cmF3b3JkX3Vu
ZGVyc2NvcmVzXShodHRwczovL3BhbmRvYy5vcmcvTUFOVUFMLmh0bWwjZXh0ZW5zaW9uLWlu
dHJhd29yZF91bmRlcnNjb3JlcykKCSogW2VzY2FwZWRfbGluZV9icmVha3NdKGh0dHBzOi8v
cGFuZG9jLm9yZy9NQU5VQUwuaHRtbCNleHRlbnNpb24tZXNjYXBlZF9saW5lX2JyZWFrcykK
CSogW3NwYWNlX2luX2F0eF9oZWFkZXJdKGh0dHBzOi8vcGFuZG9jLm9yZy9NQU5VQUwuaHRt
bCNleHRlbnNpb24tc3BhY2VfaW5fYXR4X2hlYWRlcikKCSogW2xpc3RzX3dpdGhvdXRfcHJl
Y2VkaW5nX2JsYW5rbGluZV0oaHR0cHM6Ly9wYW5kb2Mub3JnL01BTlVBTC5odG1sI2V4dGVu
c2lvbi1saXN0c193aXRob3V0X3ByZWNlZGluZ19ibGFua2xpbmUpCiogc3R5bGluZyBleHRl
bnNpb25zCgkqIFtpbmxpbmVfY29kZV9hdHRyaWJ1dGVzXShodHRwczovL3BhbmRvYy5vcmcv
TUFOVUFMLmh0bWwjZXh0ZW5zaW9uLWlubGluZV9jb2RlX2F0dHJpYnV0ZXMpCgkqIFtzdHJp
a2VvdXRdKGh0dHBzOi8vcGFuZG9jLm9yZy9NQU5VQUwuaHRtbCNleHRlbnNpb24tc3RyaWtl
b3V0KQoqIHN0cnVjdHVyaW5nIGV4dGVuc2lvbnMKCSogW3lhbWxfbWV0YWRhdGFfYmxvY2td
KGh0dHBzOi8vcGFuZG9jLm9yZy9NQU5VQUwuaHRtbCNleHRlbnNpb24teWFtbF9tZXRhZGF0
YV9ibG9jaykKCSogW3BpcGVfdGFibGVzXShodHRwczovL3BhbmRvYy5vcmcvTUFOVUFMLmh0
bWwjZXh0ZW5zaW9uLXBpcGVfdGFibGVzKQoJKiBbbGluZV9ibG9ja3NdKGh0dHBzOi8vcGFu
ZG9jLm9yZy9NQU5VQUwuaHRtbCNleHRlbnNpb24tbGluZV9ibG9ja3MpCgkqIFtpbXBsaWNp
dF9maWd1cmVzXShodHRwczovL3BhbmRvYy5vcmcvTUFOVUFMLmh0bWwjZXh0ZW5zaW9uLWlt
cGxpY2l0X2ZpZ3VyZXMpCgkqIFthYmJyZXZpYXRpb25zXShodHRwczovL3BhbmRvYy5vcmcv
TUFOVUFMLmh0bWwjZXh0ZW5zaW9uLWFiYnJldmlhdGlvbnMpCgkqIFtpbmxpbmVfbm90ZXNd
KGh0dHBzOi8vcGFuZG9jLm9yZy9NQU5VQUwuaHRtbCNleHRlbnNpb24taW5saW5lX25vdGVz
KQoqIGNvZGUgaW5qZWN0aW9uCgkqIFtyYXdfaHRtbF0oaHR0cHM6Ly9wYW5kb2Mub3JnL01B
TlVBTC5odG1sI2V4dGVuc2lvbi1yYXdfaHRtbCkKCSogW3Jhd190ZXhdKGh0dHBzOi8vcGFu
ZG9jLm9yZy9NQU5VQUwuaHRtbCNleHRlbnNpb24tcmF3X3RleCkKCmBwYW5kb2NgIHN1cHBv
cnRzCltlcXVhdGlvbnNdKGh0dHBzOi8vcGFuZG9jLm9yZy9NQU5VQUwuaHRtbCNleHRlbnNp
b24tdGV4X21hdGhfZG9sbGFycykKcmVuZGVyZWQgaW5saW5lIGFuZCBzaW5nbGUtbGluZSBp
biB0ZXgtc3R5bGUgdXNpbmcgYCQuLi4kYCBhbmQgYCQkLi4uJCRgLApbYmlibGlvZ3JhcGh5
XShodHRwczovL3BhbmRvYy5vcmcvTUFOVUFMLmh0bWwjY2l0YXRpb25zKQp1c2luZyB0aGUg
YC0tY2l0ZXByb2NgIG9wdGlvbiwKW3NlY3Rpb24gbnVtYmVyaW5nXShodHRwczovL3BhbmRv
Yy5vcmcvTUFOVUFMLmh0bWwjZXh0ZW5zaW9uLWhlYWRlcl9hdHRyaWJ1dGVzKQp1c2luZyB0
aGUgYC0tbnVtYmVyLXNlY3Rpb25zYCBvcHRpb24gYW5kClt0YWJsZSBvZiBjb250ZW50c10o
aHR0cHM6Ly9wYW5kb2Mub3JnL01BTlVBTC5odG1sI29wdGlvbi0tdG9jKQp1c2luZyB0aGUg
YC0tdGFibGUtb2YtY29udGVudHNgIG9wdGlvbi4KCmBwYW5kb2NgIHN1cHBvcnRzIFtgeG5v
c2BdKGh0dHBzOi8vZ2l0aHViLmNvbS90b21kdWNrL3BhbmRvYy14bm9zKSBmaWx0ZXJzCmZv
ciByZWZlcmVuY2luZyBkb2N1bWVudCBjb250ZW50IGxpa2UKW2ZpZ3VyZXNdKGh0dHBzOi8v
Z2l0aHViLmNvbS90b21kdWNrL3BhbmRvYy1maWdub3MjdXNhZ2UpLApbZXF1YXRpb25zXSho
dHRwczovL2dpdGh1Yi5jb20vdG9tZHVjay9wYW5kb2MtZXFub3MjdXNhZ2UpLApbdGFibGVz
XShodHRwczovL2dpdGh1Yi5jb20vdG9tZHVjay9wYW5kb2MtdGFibGVub3MjdXNhZ2UpLApb
c2VjdGlvbnNdKGh0dHBzOi8vZ2l0aHViLmNvbS90b21kdWNrL3BhbmRvYy1zZWNub3MjdXNh
Z2UpCmJ5IHVzaW5nIHRoZSBgLS1maWx0ZXIgcGFuZG9jLXhub3NgIG9wdGlvbi4KYHhub3Ng
IGludGVncmF0ZXMgY2xldmVyIHJlZmVyZW5jZXMsIHdoaWNoIG1lYW5zICJGaWcuIiwgIlNl
Yy4iLCAiRXEuIgphbmQgIlRhYi4iIGFyZSBhZGRlZCBhdXRvbWF0aWNhbGx5IHRvIHRoZSBj
b3JyZXNwb25kaW5nIGVsZW1lbnQuCklmIHRoZSBwcmVmaXggaXMgdG8gYmUgb21pdHRlZCwg
dGhlIHJlZmVyZW5jZSBpcyB3cml0dGVuIGFzCmBcIUByZWY6bGFiZWxgLgoKIyMjIyBFeGFt
cGxlIHstfQpgYGBtZAojIyBSZWZlcmVuY2VkIFNlY3Rpb24geyNzZWM6bGFiZWx9CgpUaGlz
IGlzIGEgcmVmZXJlbmNlIHRvIEBzZWM6bGFiZWwuCgohW1RoaXMgaXMgdGhlIGNhcHRpb25d
KGRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOUwpVaEVVZ0FBQUFVQUFB
QUZDQVlBQUFDTmJ5YmxBQUFBSEVsRVFWUUkxMlA0Ly84L3czOEdJQVhESUJLRTBESAp4Z2xq
TkJBQU85VFhMMFk0T0h3QUFBQUJKUlU1RXJrSmdnZz09KXsjZmlnOmxhYmVsfQoKVGhpcyBp
cyBhIHJlZmVyZW5jZSB0byBAZmlnOmxhYmVsLgoKQSAgfEIgIHxDICB8RAotLS18LS0tfC0t
LXwtLS0KMDAwfDExMXw0NDR8NTU1CjIyMnwzMzN8NjY2fDc3NwoKVGFibGU6IFRoaXMgaXMg
dGhlIGNhcHRpb24geyN0Ymw6bGFiZWx9CgpUaGlzIGlzIGEgcmVmZXJlbmNlIHRvIEB0Ymw6
bGFiZWwuCgokJFxtYm94e2V9XntcbWJveHtpfVxwaX0rMT0wJCR7I2VxOmxhYmVsfQoKVGhp
cyBpcyBhIHJlZmVyZW5jZSB0byBAZXE6bGFiZWwuCgpUaGlzIGlzIGEgY2l0YXRpb24gW0BN
dWxsZXIxOTkzXS4KYGBgCgpUaGUgZmlsZSBgbWFya3kuYmliYCBpcyBzcGVjaWZpZWQgaW4g
dGhlIG1ldGEgZGF0YSBpbiB0aGUgZnJvbnQKbWF0dGVyIG9mIHRoZSBNYXJrZG93biB0ZXh0
LgoKIyMgUmVmZXJlbmNlZCBTZWN0aW9uIHsjc2VjOmxhYmVsfQoKVGhpcyBpcyBhIHJlZmVy
ZW5jZSB0byBAc2VjOmxhYmVsLgoKIVtUaGlzIGlzIHRoZSBjYXB0aW9uXShkYXRhOmltYWdl
L3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUFVQUFBQUZDQVlBQUFDTmJ5
YmxBQUFBSEVsRVFWUUkxMlA0Ly84L3czOEdJQVhESUJLRTBESHhnbGpOQkFBTzlUWEwwWTRP
SHdBQUFBQkpSVTVFcmtKZ2dnPT0peyNmaWc6bGFiZWx9CgpUaGlzIGlzIGEgcmVmZXJlbmNl
IHRvIEBmaWc6bGFiZWwuCgpBICB8QiAgfEMgIHxECi0tLXwtLS18LS0tfC0tLQowMDB8MTEx
fDQ0NHw1NTUKMjIyfDMzM3w2NjZ8Nzc3CgpUYWJsZTogVGhpcyBpcyB0aGUgY2FwdGlvbi4g
eyN0Ymw6bGFiZWx9CgpUaGlzIGlzIGEgcmVmZXJlbmNlIHRvIEB0Ymw6bGFiZWwuCgokJFxt
Ym94e2V9XntpXHBpfSsxPTAkJHsjZXE6bGFiZWx9CgpUaGlzIGlzIGEgcmVmZXJlbmNlIHRv
IEBlcTpsYWJlbC4KClRoaXMgaXMgYSBjaXRhdGlvbiBbQE11bGxlcjE5OTNdLgoKIyBSZWZl
cmVuY2VzCg==
'''
pack_marky_bib = '''
QGFydGljbGV7TXVsbGVyMTk5MywKICAgIGF1dGhvciAgPSB7UGV0ZXIgTXVsbGVyfSwKICAg
IHRpdGxlICAgPSB7VGhlIHRpdGxlIG9mIHRoZSB3b3JrfSwKICAgIGpvdXJuYWwgPSB7VGhl
IG5hbWUgb2YgdGhlIGpvdXJuYWx9LAogICAgeWVhciAgICA9IHsxOTkzfSwKICAgIG51bWJl
ciAgPSB7Mn0sCiAgICBwYWdlcyAgID0gezIwMS0yMTN9LAogICAgbW9udGggICA9IHs3fSwK
ICAgIG5vdGUgICAgPSB7QW4gb3B0aW9uYWwgbm90ZX0sCiAgICB2b2x1bWUgID0gezR9Cn0K
'''
pack__gitignore = '''
YnVpbGQvCmh0bWwvCg==
'''

###!!!:::marky_pack_data:::!!!###
########################################################################
# SECTION IS AUTO-PACKAGED USING ./marky.py --pack --force
########################################################################

########################################################################

def _marky_front_join(y, text):
	return """---\n%s\n---\n%s""" % (
		yaml.dump(y, allow_unicode=True, default_flow_style=False),
		text
	)

def _marky_front_split(t):
	global _MARKY_EXEC_DICT
	if not t.startswith("---\n"):
		return dict(), mark, 0
	y = t.split("---\n")[1]
	meta_lines = len(y.split("\n")) + 2
	mark = "---\n".join(t.split("---\n")[2:])
	print("---\n" + y + "---", flush=True)
	data = dict()
	try:
		data = yaml.safe_load(y)
	except Exception as ex:
		print("# YAML ERROR", type(ex), str(ex))
		sys.exit(1)
	return data, mark, meta_lines

########################################################################

def _marky_mdtext_print(*args, sep=" ", shift="", crop=False, ret=False):
	global _MARKY_EXEC_QUIET
	global _MARKY_EXEC_TEXT
	global _MARKY_EXEC_APPEND
	if len(args) == 0:
		if _MARKY_EXEC_APPEND == False: _MARKY_EXEC_TEXT.append("")
		_MARKY_EXEC_APPEND = False
	else:
		if ret: return _marky_mdtext_ret(args[0], shift, crop)
		if crop or shift != "":
			_marky_mdtext_crop(args[0], shift, crop)
			if args[-1] == _marky_mdtext_print:
				_MARKY_EXEC_APPEND = True
			return
		exec_append_new = False
		if args[-1] == _marky_mdtext_print:
			exec_append_new = True
			args = args[0:-1]
		text = sep.join([str(i) for i in args])
		if _MARKY_EXEC_APPEND and len(_MARKY_EXEC_TEXT) > 0:
			_MARKY_EXEC_TEXT[-1] += text
		else:
			_MARKY_EXEC_TEXT.append(text)
		_MARKY_EXEC_APPEND = exec_append_new
		if not _MARKY_EXEC_QUIET: print(text, end="" if _MARKY_EXEC_APPEND else "\n", flush=True)

def _marky_mdtext_crop(arg, shift, crop):
	global _MARKY_EXEC_TEXT
	global _MARKY_EXEC_APPEND
	if not type(arg) is str:
		arg = str(arg)
	arg = arg.split("\n")
	if crop:
		if len(arg[0].strip()) == 0:
			arg = arg[1:]
		if len(arg[-1].strip()) == 0:
			arg = arg[:-1]
	n = len(arg[0]) - len(arg[0].lstrip())
	for i in arg:
		if crop and len(i[0:n].lstrip()) == 0:
			i = i[n:]
		_MARKY_EXEC_TEXT.append(shift + i)

def _marky_mdtext_ret(arg, shift="", crop=True):
	if not type(arg) is str:
		arg = str(arg)
	text = []
	arg = arg.split("\n")
	if crop:
		if len(arg[0].strip()) == 0:
			arg = arg[1:]
		if len(arg[-1].strip()) == 0:
			arg = arg[:-1]
	n = len(arg[0]) - len(arg[0].lstrip())
	for i in arg:
		if crop and len(i[0:n].lstrip()) == 0:
			i = i[n:]
		text.append(shift + i)
	return "\n".join(text)

########################################################################

class _marky_fmtcall:
	def __init__(self, name, fmtc):
		self.name = name
		self.fmtc = fmtc
	def __call__(self, *args, **kwargs):
		text = "<<?html "
		f = getattr(self.fmtc.html, self.name)
		if callable(f):
			v = f(*args, **kwargs)
			if type(v) is str: text += v
		elif type(f) is str:
			text += f.format(*args, **kwargs)
		text += " html?>>"
		text += "<<?pdf "
		f = getattr(self.fmtc.pdf, self.name)
		if callable(f):
			v = f(*args, **kwargs)
			if type(v) is str: text += v
		elif type(f) is str:
			text += f.format(*args, **kwargs)
		text += " pdf?>>"
		return text

class _marky_fmtcode:
	def __init__(self, pdf=None, html=None):
		if not html is None: self.html = html
		if not pdf is None: self.pdf = pdf
	def __call__(self, *args, **kwargs):
		text = "<<?html "
		f = self.html
		if callable(f):
			v = f(*args, **kwargs)
			if type(v) is str: text += v
		elif type(f) is str:
			text += f.format(*args, **kwargs)
		text += " html?>>"
		text += "<<?pdf "
		f = self.pdf
		if callable(f):
			v = f(*args, **kwargs)
			if type(v) is str: text += v
		elif type(f) is str:
			text += f.format(*args, **kwargs)
		text += " pdf?>>"
		return text
	def __getattr__(self, name):
		return _marky_fmtcall(name, self)

########################################################################

def _marky_rebrace(t):
	t = t.replace("{{", "<<brace?")
	t = t.replace("}}", "?brace>>")
	t = t.replace("{", "{{")
	t = t.replace("}", "}}")
	t = t.replace("<<brace?", "{")
	t = t.replace("?brace>>", "}")
	return t

def _marky_code_text(t, fstring=True):
	if fstring:
		if not '"""' in t and not t.endswith('"'):
			return '___(rf"""' + _marky_rebrace(t) + '""", ___); '
		elif not "'''" in t and not t.endswith("'"):
			return "___(rf'''" + _marky_rebrace(t) + "''', ___); "
		else:
			print("# ERROR", "python code contains \"\"\" as well as '''.")
			sys.exit(1)
	else:
		if not '"""' in t and not t.endswith('"'):
			return '___(r"""' + t + '""", ___); '
		elif not "'''" in t and not t.endswith("'"):
			return "___(r'''" + t + "''', ___); "
		else:
			print("# ERROR", "python code contains \"\"\" as well as '''.")
			sys.exit(1)

def _marky_paste_code(t):
	show_code = False
	if t.startswith("!"):
		t = t[1:]
		show_code = True
	if show_code:
		return _marky_code_text(t, fstring=False) + t
	return t

def _marky_meta_merge(old, front):
	meta = {}
	meta.update(old)
	try:
		for k, v in front.items():
			if k in meta:
				print("<!-- field exists, skip yaml %s --!>" % k)
			else:
				meta[k] = v
	except Exception as ex:
		print("# META MERGE ERROR", type(ex), str(ex))
		sys.exit(1)
	return meta

def _marky_run(fname, meta, inbase):
	global _MARKY_EXEC_DICT
	with open(fname, "r") as h:
		front, t, meta_lines = _marky_front_split(h.read())
	meta = _marky_meta_merge(meta, front)
	p = 0
	r = ""
	while True:
		p0 = t.find("<?", p)
		p1 = t.find("?>", p)
		if p0 > -1:
			if p1 < p0:
				print("# ERROR", "?> before <?")
				sys.exit(1)
			if p0 > 0: r += _marky_code_text(t[p:p0])
			p1 = t.find("?>", p0)
			if p1 > -1:
				code = t[p0+2:p1]
				r += _marky_paste_code(code)
				p = p1 + 2
			else:
				print("# ERROR", "missing ?>")
				sys.exit(1)
		else:
			r += _marky_code_text(t[p:])
			break
	for a, b, c, count in [
		("", "<%s?", "", 1),
		("", "?%s>", "", 1),
		("", "{%s", "{", 3),
		("}", "%s}", "", 3)
	]:
		for j in reversed(range(1, count+1)):
			for i in range(3):
				X = "\\"*(i + 1)
				Y = "\\"*(i + 0)
				r = r.replace(a + (b % X)*j + c, a + (b % Y)*j + c)
	open(_MARKY_BUILD_DIR + inbase + ".py", "w").write(r)
	try:
		exec(r, _MARKY_EXEC_DICT, None)
	except Exception as ex:
		_marky_print_trace(ex, meta_lines, r)
		sys.exit(1)
	return meta

def _marky_print_trace(ex, mlines, code):
	print("# TRACEBACK")
	import traceback
	traceback.print_tb(ex.__traceback__)
	print("# PYTHON ERROR")
	print(type(ex), str(ex))
	if ex.filename == "<string>":
		print("# ERROR LOCATION")
		code = code.split("\n")
		print(len(code))
		for i in range(max(0, ex.lineno-5), min(len(code), ex.lineno+5)):
			print("*" if i + 1 == ex.lineno else " ", "%03d" % i, code[i])

########################################################################

def _marky_meta_link(front, link):
	flink = {}
	try:
		for k, v in front.items():
			if "--" in k: continue
			if not k in flink:
				flink[k] = v
			else:
				print("<!-- field exists, skip yaml %s --!>" % k)
		for k, v in front.items():
			if not "--" in k: continue
			x = k.split("--")
			if x[-1] in _MARKY_FORMAT:
				if x[-1] == link:
					k = "--".join(x[0:-1])
					if k in flink:
						print("<!-- field link, merge yaml %s --!>" % k)
						if type(v) is list: flink[k].extend(v)
						if type(v) is dict: flink[k].update(v)
						if type(v) is str: flink[k] += " " + v
						else: flink[k] = v
					else:
						print("<!-- field link, set yaml %s --!>" % k)
						flink[k] = v
	except Exception as ex:
		print("# META LINK ERROR", type(ex), str(ex))
		sys.exit(1)
	return flink

def _marky_link(front, md_text, link):
	md_text = md_text.replace(".???", "." + link)
	md_text = md_text.replace(r".\???", r".???")
	md_text = md_text.replace(r".\\???", r".\???")
	lsep = 3
	len_args = len(link) + 1
	c = 0
	newtext = ""
	p = md_text.find("<<?")
	while p >= 0:
		q = md_text.find("?>>", p + lsep)
		if q > 0:
			newtext += md_text[c:p]
			expr = md_text[p+lsep:q]
			if expr.startswith(link) and expr.endswith(link):
				newtext += expr[len_args:-len_args]
			c = q + lsep
			p = md_text.find("<<?", c)
		else:
			p = md_text.find("<<?", p + lsep)
	newtext += md_text[c:]
	flink = _marky_meta_link(front, link)
	return _marky_front_join(flink, newtext)

def _marky_write_build(inbase, outdir, front, mark):
	os.makedirs(_MARKY_BUILD_DIR + outdir, exist_ok=True)
	if not mark is None:
		open(_MARKY_BUILD_DIR + inbase + ".md", "w").write(_marky_front_join(front, mark))
		for fmt in _MARKY_FORMAT:
			open(_MARKY_BUILD_DIR + inbase + "." + fmt + ".md", "w").write(_marky_link(front, mark, fmt))

	with open(_MARKY_BUILD_DIR + inbase + ".make", "w") as fhnd:
		fhnd.write(f"""# auto-generated
all_md:=$(all_md) {_MARKY_MD_DIR+inbase}.md

{_MARKY_BUILD_DIR+inbase}.md: {_MARKY_MD_DIR+inbase}.md
	mkdir -p "{_MARKY_BUILD_DIR+outdir}"
	ln -snf ../{_MARKY_DATA_DIR} {_MARKY_BUILD_DIR+_MARKY_DATA_DIR}
	./marky.py --base="{inbase}.md"

.PHONY: build/{inbase}
build/{inbase}: {_MARKY_BUILD_DIR+inbase}.md

all_build:=$(all_build) build/{inbase}
"""
		)
		if "pdf" in _MARKY_FORMAT:
			fhnd.write(f"""
{_MARKY_BUILD_DIR+inbase}.tex: {_MARKY_BUILD_DIR+inbase}.pdf.md {_MARKY_MD_DIR+inbase}.md
	mkdir -p "{_MARKY_BUILD_DIR+outdir}"
	./pandoc-run tex {_MARKY_BUILD_DIR+inbase}.pdf.md {_MARKY_BUILD_DIR+inbase}.tex

all_tex:=$(all_tex) {_MARKY_BUILD_DIR+inbase}.tex
"""
			)
		for fmt in _MARKY_FORMAT:
			fhnd.write(f"""
{_MARKY_BUILD_DIR+inbase}.{fmt}.md: {_MARKY_BUILD_DIR+inbase}.md

{fmt}/{inbase}.{fmt}: {_MARKY_BUILD_DIR+inbase}.{fmt}.md {_MARKY_MD_DIR+inbase}.md
	mkdir -p "{fmt}/{outdir}"
	./pandoc-run {fmt} {_MARKY_BUILD_DIR+inbase}.{fmt}.md {fmt}/{inbase}.{fmt}

.PHONY: {fmt}/{inbase}
{fmt}/{inbase}: {fmt}/{inbase}.{fmt}

all_{fmt}:=$(all_{fmt}) {fmt}/{inbase}.{fmt}
"""
			)

########################################################################

def _marky_pack_b64enc(x, n=72):
	x = base64.b64encode(bytes(x, "utf-8")).decode("ascii")
	return "\n".join([x[i:i+n] for i in range(0, len(x), n)])

def _marky_pack_b64dec(x):
	return base64.b64decode(bytes(x.replace("\n", ""), "ascii")).decode("utf-8")

def _marky_load_pack(i):
	return _marky_pack_b64dec(eval("pack_" + i.split("/")[-1].replace(".", "_").replace("-", "_")))

def _marky_pack_write_file(fname, force=False):
	if not os.path.exists(fname) or force:
		print("# WRITE", fname)
		open(fname, "w").write(_marky_load_pack("./" + fname))
	else:
		print("# EXISTS", fname)

def _marky_store_pack(i, ftext):
	return "pack_%s = '''\n%s\n'''\n" % (i.split("/")[-1].replace(".", "_").replace("-", "_"), _marky_pack_b64enc(ftext))

def _marky_pack_read_file(fname):
	return _marky_store_pack("./" + fname, open(fname, "r").read())

########################################################################

_MARKY_FORMAT = ["html", "pdf"]
_MARKY_BUILD_DIR = "build/"  #< WITH trailing /
_MARKY_MD_DIR = "md/"  #< WITH trailing /
_MARKY_DATA_DIR = "data" #< no trailing /
_MARKY_PACK_DIRS = [
	_MARKY_BUILD_DIR,
	_MARKY_DATA_DIR,
	_MARKY_MD_DIR
]
_MARKY_PACK_FILES = [
	"Makefile",
	"pandoc-run",
	"md/marky.md",
	"data/marky.bib",
	".gitignore"
]
_MARKY_EXEC_QUIET = False
_MARKY_EXEC_DICT = dict()
_MARKY_EXEC_TEXT = list()
_MARKY_EXEC_APPEND = False
_MARKY_EXEC_DICT["___"] = _marky_mdtext_print
_MARKY_EXEC_DICT["fmtcode"] = _marky_fmtcode

########################################################################

if __name__ == "__main__":

	parser = argparse.ArgumentParser(add_help=False)

	parser.add_argument("--version", action='store_true', help="version is v" + ".".join([str(i) for i in _MARKY_VERSION]))
	parser.add_argument("--help", action='store_true', help="show this help message")
	parser.add_argument("--base", type=str, default="", help="path to input markdown text")
	parser.add_argument("--init", action='store_true', help="create dirs (" + ", ".join(_MARKY_PACK_DIRS) + ") and files (" + ", ".join(_MARKY_PACK_FILES) + ")")
	parser.add_argument("--force", action='store_true', help="force overwrite of files for --init/--pack")
	parser.add_argument("--pack", action='store_true', help="pack files (" + ", ".join(_MARKY_PACK_FILES) + ") into marky.py.pack source")
	parser.add_argument("--scan", action='store_true', help="create build/*.make from md/*.md")
	parser.add_argument("--quiet", action='store_true', help="do not show Markdown output")

	# ~ args, uargs = parser.parse_known_args()
	args = parser.parse_args()

	sys.path.append(".")

########################################################################

	if args.version:
		print(".".join([str(i) for i in _MARKY_VERSION]))
		sys.exit(0)
	elif args.help or len(sys.argv) == 1:
		parser.print_help()
		sys.exit(0)
	elif args.init:
		for i in _MARKY_PACK_DIRS:
			if not os.path.exists(i):
				print("# MKDIR", i)
				os.mkdir(i)
			else:
				print("# EXISTS", i)
		for i in _MARKY_PACK_FILES:
			_marky_pack_write_file(i, args.force)
		print("# USAGE")
		print("make help")
		sys.exit(0)
	elif args.pack:
		print("# PACK", ", ".join(_MARKY_PACK_FILES))
		marky_text = open(sys.argv[0], "r").read()
		head, src, tail = tuple(marky_text.split("\n###!!!:::marky_pack_data:::!!!###\n"))
		src = "".join([_marky_pack_read_file(i) for i in _MARKY_PACK_FILES])
		marky_text = "\n###!!!:::marky_pack_data:::!!!###\n".join([head, src, tail])
		open(sys.argv[0] + ".pack", "w").write(marky_text)
		if args.force:
			print("# UPDATE OF `marky` FORCED")
			print("# -----------------------")
			print("# mv marky.py.pack marky.py")
			print("# chmod 775 marky.py")
			os.replace("marky.py.pack", "marky.py")
			os.chmod("marky.py", 0o775)
		else:
			print("# MANUAL UPDATE NEEDED")
			print("# --------------------")
			print("mv marky.py.pack marky.py")
			print("chmod +x marky.py")
		sys.exit(0)
	elif args.scan:
		for i in glob.glob("md/**/*.md", recursive=True):
			inbase = i[3:-3]
			outdir = "/".join(inbase.split("/")[0:-1])
			print("# WRITE", _MARKY_BUILD_DIR + inbase + ".make")
			_marky_write_build(inbase, outdir, None, None)
		sys.exit(0)
		pass
	elif args.force:
		print("# ERROR", "--force can only be used with --pack/--init")
		sys.exit(1)
	elif args.quiet:
		_MARKY_EXEC_QUIET = True

########################################################################

	infile = _MARKY_MD_DIR + args.base
	if len(args.base) == 0:
		print("# ERROR", "empty base: use --base file.md")
		sys.exit(1)
	if not os.path.exists(infile):
		print("# ERROR", "wrong base %s: file not found %s" % (args.base, infile))
		sys.exit(1)
	inbase = args.base if not "." in args.base.split("/")[-1] else ".".join(args.base.split(".")[0:-1])
	outdir = "/".join(inbase.split("/")[0:-1])

	if os.path.exists(_MARKY_BUILD_DIR):
		front = _marky_run(infile, {}, inbase)
		mark = "\n".join(_MARKY_EXEC_TEXT)
		_marky_write_build(inbase, outdir, front, mark)
	else:
		print("# ERROR", "no build dir: mkdir build")
		sys.sys.exit(1)
