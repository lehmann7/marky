#!/usr/bin/env python3
# -*- coding: utf-8 -*-

########################################################################
# marky Markdown Preprocessor ###########################################
########################################################################

# Quick Make Example Project
############################
#
#  > mkdir project
#  > cp /path/to/marky.py project
#  > cd project
#  > chmod +x marky.py
#  > ./marky.py --init
#  > make scan html-all pdf-all httpd
#
# Open: project/pdf/*.pdf
# Goto: http://localhost:8000/

########################################################################

import sys
import argparse
import glob
import os
import base64
import yaml

########################################################################

if not sys.version_info.major == 3 and sys.version_info.minor >= 6:
	try:
		raise ValueError("marky requires Python 3.6 or higher.")
	except Exception as ex:
		print("# ERROR", type(ex), str(ex))
		sys.exit(1)

########################################################################

_MARKY_VERSION = (0, 9)

########################################################################
# SECTION IS AUTO-PACKAGED USING ./marky.py --pack --force
########################################################################
###!!!:::marky_pack_data:::!!!###
pack_Makefile = '''
IyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMj
IyMjIyMjIyMjIyMjIyMjIyMjCgouUEhPTlk6IGhlbHAKaGVscDoKCSMgbWFya3kgREVQRU5E
RU5DSUVTCgkjIyMjIyMjIyMjIyMjIyMjIyMjIwoJIyAqIHBhbmRvYyA+PSAyLjEwCgkjICog
cGlwIGluc3RhbGwgcGFuZG9jLWZpZ25vcwoJIyAqIHBpcCBpbnN0YWxsIHBhbmRvYy1lcW5v
cwoJIyAqIHBpcCBpbnN0YWxsIHBhbmRvYy1zZWNub3MKCSMgKiBwaXAgaW5zdGFsbCBwYW5k
b2MtdGFibGVub3MKCSMgKiBwaXAgaW5zdGFsbCBwYW5kb2MteG5vcwoJIyAqIHBpcCBpbnN0
YWxsIHB5eWFtbAoJIwoJIyBBVFRFTlRJT04KCSMjIyMjIyMjIyMjCgkjIEFsbCBmaWxlcyBp
biBgYnVpbGQvKi5tZGAgYW5kIGBodG1sLyouaHRtbGAgYXJlIGF1dG8tZ2VuZXJhdGVkIQoJ
IyBVc2VyIGZpbGVzIGAqLm1kYCBoYXZlIHRvIGJlIHBsYWNlZCBpbiBgbWQvKi5tZGAhCgkj
IGBtYWtlIGNsZWFuYCBkZWxldGVzIGFsbCBmaWxlcyBpbiBgYnVpbGQvYCwgYGh0bWwvYCBh
bmQgYHBkZi9gLgoJIwoJIyBtYXJreSBVVElMUwoJIyMjIyMjIyMjIyMjIwoJIyAqIG1ha2Ug
aGVscCAgICAgICAgICAgIC0gc2hvdyB0aGlzICpIZWxwIE1lc3NhZ2UqCgkjICogbWFrZSB0
cmVlICAgICAgICAgICAgLSBzaG93IHRoZSAqUHJvamVjdCBUcmVlKgoJIyAqIG1ha2UgaHR0
cGQgICAgICAgICAgIC0gcnVuIHB5dGhvbiAtbSBodHRwZC5zZXJ2ZXIgaW4gYGh0bWwvYAoJ
IyAqIG1ha2UgY2xlYW4gICAgICAgICAgIC0gZGVsZXRlOiBgYnVpbGQvKmAsIGBodG1sLypg
LCBgcGRmLypgCgkjICogbWFrZSBzY2FuICAgICAgICAgICAgLSBidWlsZCBtYWtlIGRlcHM6
IGBidWlsZC8qLm1ha2VgCgkjICogbWFrZSBsaXN0ICAgICAgICAgICAgLSBsaXN0IGFsbCBz
Y2FubmVkIGZpbGVzIGFuZCB0YXJnZXRzCgkjCgkjIG1hcmt5IEJVSUxEIEFMTAoJIyMjIyMj
IyMjIyMjIyMjIyMKCSMgKiBtYWtlIGJ1aWxkICAgICAgICAgICAtPiBgYnVpbGQvKi57aHRt
bCxwZGZ9Lm1kYAoJIyAqIG1ha2UgdGV4ICAgICAgICAgICAgIC0+IGBidWlsZC8qLnRleGAK
CSMgKiBtYWtlIGh0bWwgICAgICAgICAgICAtPiBgaHRtbC8qLmh0bWxgCgkjICogbWFrZSBw
ZGYgICAgICAgICAgICAgLT4gYHBkZi8qLnBkZmAKCSMgKiBtYWtlIGFsbCAgICAgICAgICAg
ICAtPiBgaHRtbC8qLmh0bWxgLCBgcGRmLyoucGRmYAoJIwoJIyBtYXJreSBCVUlMRCBGSUxF
CgkjIyMjIyMjIyMjIyMjIyMjIyMKCSMgKiBtYWtlIGJ1aWxkL2ZpbGUgICAgICAtPiBgYnVp
bGQvZmlsZS57aHRtbCxwZGZ9Lm1kYAoJIyAqIG1ha2UgYnVpbGQvZmlsZS50ZXggIC0+IGBi
dWlsZC9maWxlLnRleGAKCSMgKiBtYWtlIGh0bWwvZmlsZSAgICAgICAtPiBgaHRtbC9maWxl
Lmh0bWxgCgkjICogbWFrZSBwZGYvZmlsZSAgICAgICAgLT4gYHBkZi9wZGYuaHRtbGAKCSMK
CSMgRVhBTVBMRQoJIyMjIyMjIyMjCgkjIDEuIHJ1biBgbWFrZSBzY2FuOyBtYWtlIGh0bWwv
ZmlsZS5odG1sIGh0dHBkYDoKCSMgICAgKiBnZW5lcmF0ZSBgYnVpbGQvZmlsZS5tYWtlYAoJ
IyAgICAqIHRyYW5zZm9ybSBgbWQvZmlsZS5tZGAgLT4gYGh0bWwvZmlsZS5odG1sYAoJIyAg
ICAqIHN0YXJ0IGEgcHl0aG9uIGh0dHBkIHNlcnZlciBpbiBgaHRtbGAKCSMgMi4gcnVuIGBt
YWtlIHNjYW47IG1ha2UgcGRmL2ZpbGUucGRmYAoJIyAgICAqIGdlbmVyYXRlIGBidWlsZC9m
aWxlLm1ha2VgCgkjICAgICogdHJhbnNmb3JtIGBtZC9maWxlLm1kYCAtPiBgcGRmL2ZpbGUu
cGRmYAoJIwoKLlBIT05ZOiB0cmVlCnRyZWU6CgkjIFBST0pFQ1QgVFJFRQoJIyMjIyMjIyMj
IyMjIyMKCSMgPHdvcmtpbmdfZGlyPgoJIyB8LSBtYXJreS5weSAgICAgICAgICAgIC0gbWFy
a3kgZXhlY3V0YWJsZQoJIyB8LSBNYWtlZmlsZSAgICAgICAgKCopIC0gbWFya3kgTWFrZWZp
bGUKCSMgfC0gcGFuZG9jLXJ1biAgICAgICgqKSAtIHBhbmRvYyB3cmFwcGVyCgkjIHwtIG1k
LyAgICAgICAgICAgICAoKikgLSB1c2VyIE1hcmtkb3duIGRpcgoJIyB8ICB8LSAqLm1kICAg
ICAgICAgICAgIC0gdXNlciBNYXJrZG93biB0ZXh0CgkjIHwtIGRhdGEvICAgICAgICAgICAo
KikgLSB1c2VyIGRhdGEgZGlyCgkjIHwgIHwtICouKiAgICAgICAgICAgICAgICB1c2VyIGRh
dGEgZmlsZXMKCSMgfC0gYnVpbGQvICAgICAgICAgICgqKSAtIGJ1aWxkIE1hcmtkb3duIGRp
cgoJIyB8ICB8LSAqLnB5ICAgICAgICAgKCopIC0gbWFya3kgUHl0aG9uIGNvZGUKCSMgfCAg
fC0gKi5tYWtlICAgICAgICgqKSAtIE1ha2VmaWxlIHJ1bGVzCgkjIHwgIHwtICouaHRtbC5t
ZCAgICAoKikgLSBNYXJrZG93biBmb3IgaHRtbCBmb3JtYXQKCSMgfCAgfC0gKi5wZGYubWQg
ICAgICgqKSAtIE1hcmtkb3duIGZvciBwZGYgZm9ybWF0CgkjIHwtIGh0bWwvKi5odG1sICAg
ICAoKikgLSByZW5kZXJlZCBodG1sIGRpcgoJIyB8LSBwZGYvKi5wZGYgICAgICAgKCopIC0g
cmVuZGVyZWQgcGRmIGRpcgoJIwoJIyAoKikgZGlyZWN0b3JpZXMvZmlsZXMgYXJlIGF1dG8t
Z2VuZXJhdGVkIHVzaW5nCgkjICAgIGAuL21hcmt5LnB5IC0taW5pdDsgbWFrZSBzY2FuOyBt
YWtlIGFsbMK0CgkjCgouUEhPTlk6IGNsZWFuCmNsZWFuOgoJcm0gLXJmIC4vYnVpbGQvKiAu
L2h0bWwvKiAuL3BkZi8qCgouUEhPTlk6IGh0dHBkCmh0dHBkOgoJY2QgaHRtbCAmJiBweXRo
b24gLW0gaHR0cC5zZXJ2ZXIKCi5QSE9OWTogc2NhbgpzY2FuOgoJLi9tYXJreS5weSAtLXNj
YW4KCiMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMj
IyMjIyMjIyMjIyMjIyMjIyMjIyMjIwoKYWxsX21kOj0KYWxsX2J1aWxkOj0KYWxsX2h0bWw6
PQphbGxfcGRmOj0KYWxsX3RleDo9CgotaW5jbHVkZSBidWlsZC8qLm1ha2UgYnVpbGQvKiov
Ki5tYWtlCgojIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMj
IyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMKCi5QSE9OWTogbGluawpidWlsZDogJChhbGxf
YnVpbGQpCgouUEhPTlk6IGh0bWwKaHRtbDogJChhbGxfaHRtbCkKCi5QSE9OWTogcGRmCnBk
ZjogJChhbGxfcGRmKQoKLlBIT05ZOiB0ZXgKdGV4OiAkKGFsbF90ZXgpCgouUEhPTlk6IGFs
bAphbGw6IGh0bWwgcGRmCgouUEhPTlk6IGxpc3QKbGlzdDoKCSMgbWFya3kgVEFSR0VUUwoJ
IyMjIyMjIyMjIyMjIyMjCgkjICogYG1ha2Ugc2NhbmAgLS0gRklMRVM6JChhbGxfbWQpCgkj
ICogYG1ha2UgYnVpbGRgIC0tIGBtYWtlJChhbGxfYnVpbGQpYAoJIyAqIGBtYWtlIGh0bWxg
IC0tIGBtYWtlJChhbGxfaHRtbClgCgkjICogYG1ha2UgcGRmYCAtLSBgbWFrZSQoYWxsX3Bk
ZilgCgkjICogYG1ha2UgdGV4YCAtLSBgbWFrZSQoYWxsX3RleClgCgkjCg==
'''
pack_pandoc_run = '''
IyEvYmluL2Jhc2gKClsgJCMgPT0gMCBdICYmIGVjaG8gIiIiCiMgVXNhZ2U6ICQwOiA8Rk9S
TUFUPiA8SU5GSUxFPiA8T1VURklMRT4KIyBFeGFtcGxlOgojICQwIGh0bWwgYnVpbGQvZmls
ZS5odG1sLm1kIGh0bWwvZmlsZS5odG1sCiMgJDAgcGRmIGJ1aWxkL2ZpbGUucGRmLm1kIHBk
Zi9maWxlLnBkZgoiIiIgJiYgZXhpdCAxCgpQQU5ET0M9cGFuZG9jCgpNREVYVD1cCmFsbF9z
eW1ib2xzX2VzY2FwYWJsZStcCmludHJhd29yZF91bmRlcnNjb3JlcytcCmVzY2FwZWRfbGlu
ZV9icmVha3MrXApzcGFjZV9pbl9hdHhfaGVhZGVyK1wKbGlzdHNfd2l0aG91dF9wcmVjZWRp
bmdfYmxhbmtsaW5lK1wKaW5saW5lX2NvZGVfYXR0cmlidXRlcytcCnN0cmlrZW91dCtcCnlh
bWxfbWV0YWRhdGFfYmxvY2srXApwaXBlX3RhYmxlcytcCmxpbmVfYmxvY2tzK1wKaW1wbGlj
aXRfZmlndXJlcytcCmFiYnJldmlhdGlvbnMrXAppbmxpbmVfbm90ZXMKClBET1BUPSIiIgot
LXRhYmxlLW9mLWNvbnRlbnRzCi0tbnVtYmVyLXNlY3Rpb25zCiIiIgoKaWYgWyAkMSA9PSBo
dG1sIF0gOyB0aGVuCiRQQU5ET0MgIiQyIiBcCi0tZmlsdGVyIHBhbmRvYy14bm9zIFwKLS1j
aXRlcHJvYyBcCi0tZnJvbT1tYXJrZG93bityYXdfaHRtbCskTURFWFQgXAotLXRvPWh0bWw1
IFwKLS1zZWxmLWNvbnRhaW5lZCBcCi0tb3V0cHV0PSIkMyIgXAotLXJlc291cmNlLXBhdGg9
Ii4vYnVpbGQvIiBcCiRQRE9QVApmaQoKaWYgWyAkMSA9PSBwZGYgXSA7IHRoZW4KJFBBTkRP
QyAiJDIiIFwKLS1maWx0ZXIgcGFuZG9jLXhub3MgXAotLWNpdGVwcm9jIFwKLS1mcm9tPW1h
cmtkb3duK3Jhd190ZXgrJE1ERVhUIFwKLS10bz1sYXRleCBcCi0tb3V0cHV0PSIkMyIgXAot
LXJlc291cmNlLXBhdGg9Ii4vYnVpbGQvIiBcCi0tcGRmLWVuZ2luZT14ZWxhdGV4IFwKJFBE
T1BUCmZpCgppZiBbICQxID09IHRleCBdIDsgdGhlbgokUEFORE9DICIkMiIgXAotLWZpbHRl
ciBwYW5kb2MteG5vcyBcCi0tY2l0ZXByb2MgXAotLWZyb209bWFya2Rvd24rcmF3X3RleCsk
TURFWFQgXAotLXRvPWxhdGV4IFwKLS1vdXRwdXQ9IiQzIiBcCi0tcmVzb3VyY2UtcGF0aD0i
Li9idWlsZC8iIFwKJFBET1BUCmZpCg==
'''
pack_marky_md = '''
LS0tCnRpdGxlOiAiYG1hcmt5YCBEb2N1bWVudGF0aW9uICIKdGl0bGUtLXBkZjogIi0tIGBw
ZGZgIgp0aXRsZS0taHRtbDogIi0tIGBodG1sYCIKYmlibGlvZ3JhcGh5OiBkYXRhL21hcmt5
LmJpYgpoZWFkZXItaW5jbHVkZXMtLXBkZjogPgogICBcaHlwZXJzZXR1cHtjb2xvcmxpbmtz
PWZhbHNlLAogICBhbGxib3JkZXJjb2xvcnM9ezAgMCAwfSwKICAgcGRmYm9yZGVyc3R5bGU9
ey9TL1UvVyAxfX0KaGVhZGVyLWluY2x1ZGVzLS1odG1sOiA+CiAgIDxzdHlsZT4qIHsgYm94
LXNpemluZzogYm9yZGVyLWJveDsgfTwvc3R5bGU+Cnhub3MtY2xldmVyZWY6IHRydWUKeG5v
cy1jYXBpdGFsaXNlOiB0cnVlCmZvbnRzaXplOiAxMXB0CgotLS0KPD8KY29sID0gZm10Y29k
ZSgKCWh0bWw9IjxzcGFuIHN0eWxlPSdjb2xvcjp7MX07Jz57MH08L3NwYW4+IiwKCXBkZj1y
Ilx0ZXh0Y29sb3J7e3sxfX19e3t7MH19fSIKKQpkZWYgdGV4dF9wcm9jKGNtZCwgY3JvcD1U
cnVlKToKCWltcG9ydCBzdWJwcm9jZXNzIGFzIHNwCgl0ZXh0ID0gIiIKCWZvciBpIGluIHNw
LmNoZWNrX291dHB1dChjbWQuc3BsaXQoKSkuZGVjb2RlKCJ1dGYtOCIpLnNwbGl0KCJcbiIp
OgoJCWlmIG5vdCBjcm9wOgoJCQl0ZXh0ICs9IGkgKyAiXG4iCgkJZWxpZiBpLnN0YXJ0c3dp
dGgoIiMgIik6CgkJCXRleHQgKz0gaVsyOl0gKyAiXG4iCgkJZWxpZiBpID09ICIjIjoKCQkJ
dGV4dCArPSAiXG4iCgkJZWxpZiBpLnN0YXJ0c3dpdGgoIiMiKToKCQkJdGV4dCArPSBpICsg
IlxuIgoJcmV0dXJuIHRleHQKdmVyc2lvbiA9IHRleHRfcHJvYygicHl0aG9uIG1hcmt5LnB5
IC0tdmVyc2lvbiIsIGNyb3A9RmFsc2UpLnN0cmlwKCkKPz4KLS0tCgo+ICoqQWJzdHJhY3Qq
KiAtLSBgbWFya3lgIGlzIGEgcHJlcHJvY2Vzc29yIHdpdGggYW4gZWFzeSBhbmQgaW50dWl0
aXZlCj4gc3ludGF4IGZvciBleGVjdXRpb24gb2YgZW1iZWRkZWQge3tjb2woInB5aG9uIiwi
Ymx1ZSIpfX0gY29kZSBkdXJpbmcgcmVuZGVyaW5nCj4gYGh0bWxgIGFuZCBgcGRmYCBkb2N1
bWVudHMgZnJvbSBNYXJrZG93biB0ZXh0Lgo+IFRoaXMgZG9jdW1lbnQgaXMgY3JlYXRlZCB1
c2luZyBgbWFya3lgLCB2ZXJzaW9uICp7e3ZlcnNpb259fSouCj4gRm9yIG1vcmUgaW5mb3Jt
YXRpb24gcGxlYXNlIHJlZmVyIHRvIHRoZQo+IFtgbWFya3lgIHJlcG9zaXRvcnldKGh0dHBz
Oi8vZ2l0aHViLmNvbS9sZWhtYW5uNy9tYXJreSkuCgotLS0KCiMgYG1hcmt5YCBEeW5hbWlj
IE1hcmtkb3duCgpgbWFya3lgIGlzIGEgTWFya2Rvd24gcHJlcHJvY2Vzc29yIHdoaWNoIHRy
YW5zZm9ybXMgYSBNYXJrZG93biBkb2N1bWVudAp1c2luZyBweXRob24uIGBtYXJreWAgaW1w
bGVtZW50cyB0aHJlZSBzdGF0ZW1lbnRzIHdpdGggZXh0cmVtZWx5IGVhc3kKYW5kIGludHVp
dGl2ZSBzeW50YXgsIHdoaWNoIGFyZSBlbWJlZGRlZCBkaXJlY3RseSBpbiB0aGUgTWFya2Rv
d24gdGV4dDoKCjEuIGA8XD8uLi4/XD5gOiBQeXRob24gY29kZSBibG9jay4KMi4gYHtcey4u
Ln1cfWA6IGBmYC1zdHJpbmcgb3V0cHV0IGludG8gTWFya2Rvd24uCjMuIGBfX18oKWA6IEZ1
bmN0aW9uIGZvciBvdXRwdXQgaW50byBNYXJrZG93bi4KClVzaW5nIGA8XD8uLi4/XD5gIGFu
ZCBge1x7Li4ufVx9YCBweXRob24gY29kZSBhbmQgYGZgLXN0cmluZyBvdXRwdXQKYXJlIGVt
YmVkZGVkIGRpcmVjdGx5IGluc2lkZSB0aGUgTWFya2Rvd24gdGV4dC4KCiMjIyMgRXhhbXBs
ZSAxOiBJbmxpbmUgRm9ybWF0dGVkIE91cHV0IHstfQo8PyEKeCA9IDEyMy40NQpMRUcgPSBs
YW1iZGEgdiwgdzogImxlc3NlciIgaWYgdiA8IHcgZWxzZSAiZXF1YWwgb3IgZ3JlYXRlciIK
Pz4KYGBgcGhwCjxcP3t7X19fKGNvZGU9VHJ1ZSl9fT9cPgpgYGAKYGBgbWFya2Rvd24KVGhp
cyBpcyBhbiBleGFtcGxlIHdpdGggYSB2YWx1ZSB4PXtce3g6LjNmfVx9LAp3aGljaCBpcyB7
XHtMRUcoeCwgMTAwKX1cfSB0aGFuIDEwMC4KYGBgCiMjIyMgUnVuIGFuZCBPdXRwdXQgey19
CmBgYG1hcmtkb3duClRoaXMgaXMgYW4gZXhhbXBsZSB3aXRoIGEgdmFsdWUgeD17e3g6LjNm
fX0sCndoaWNoIGlzIHt7TEVHKHgsIDEwMCl9fSB0aGFuIDEwMC4KYGBgCgpVc2luZyB0aGUg
YF9fXygpYCBmdW5jdGlvbiB0ZXh0IGlzIGdlbmVyYXRlZCBmcm9tIHB5dGhvbgphbGdvcml0
aG1zIGFuZCBkeW5hbWljYWxseSBpbnNlcnRlZCBpbnRvIHRoZSByZXN1bHRpbmcgTWFya2Rv
d24uCgojIyMjIEV4YW1wbGUgMjogRHluYW1pYyBUZXh0IGZyb20gQ29kZSB7LX0KYGBgcGhw
CjxcP3t7X19fKGNvZGU9VHJ1ZSl9fT9cPgpgYGAKIyMjIyBSdW4gYW5kIE91dHB1dCB7LX0K
YGBgbWFya2Rvd24KPD8hCmZvciBpIGluIHJhbmdlKDMpOgoJX19fKGYie2krMX0uIGBpID0g
e2l9YCIsICJhYmNkZWZnaGlqIlswOmkqM10pCj8+CmBgYAoKUHl0aG9uIGNvZGUsIHdoaWNo
IGlzIGVtYmVkZGVkIGluIHRoZSBNYXJrZG93biB0ZXh0CmZvbGxvd3MgdGhlIFB5dGhvbiBp
bmRlbnRhdGlvbiBzdGFuZGFyZC4gTWFya2Rvd24KdGV4dCBpcyBpbnRlZ3JhdGVkIGludG8g
dGhlIHByb2dyYW0gZmxvdyB3aGVuIGJlaW5nCmluc2VydGVkIGluIHB5dGhvbiBzdGF0ZW1l
bnRzIGFjY29yZGluZ2x5LgoKIyMjIyBFeGFtcGxlIDM6IFRleHQgaW4gUHJvZ3JhbSBGbG93
IHstfQpgYGBwaHAKVGhpcyBpcyB0aGUgZmlyc3QgbGluZS4KPFw/CmlmIEZhbHNlOgoJP1w+
VGhpcyBMaW5lIGlzICoqbm90Kiogc2hvd24uPFw/CmVsc2U6Cgk/XD5UaGlzIExpbmUgaXMg
c2hvd24uPFw/Cj9cPgpUaGlzIGlzIHRoZSBsYXN0IGxpbmUuCmBgYAojIyMjIFJ1biBhbmQg
T3V0cHV0IHstfQpgYGBtYXJrZG93bgpUaGlzIGlzIHRoZSBmaXJzdCBsaW5lLgo8PwppZiBG
YWxzZToKCT8+VGhpcyBMaW5lIGlzICoqbm90Kiogc2hvd24uPD8KZWxzZToKCT8+VGhpcyBM
aW5lIGlzIHNob3duLjw/Cj8+ClRoaXMgaXMgdGhlIGxhc3QgbGluZS4KYGBgCgojIyBBIEZp
cnN0IGBtYXJreWAgRXhhbXBsZQoKYG1hcmt5YCBjb21iaW5lcyBweXRob24gZXhwcmVzc2lv
bnMgd2l0aCBNYXJrZG93biwgZm9yIGR5bmFtaWMgY3JlYXRpb24Kb2YgdGV4dC4gSW4gdGhl
IGZvbGxvd2luZywgdHdvIGluLWRlcHRoIGV4YW1wbGVzIG9mIGBtYXJreWAgYXJlIHByZXNl
bnRlZC4KCiMjIyMgRXhhbXBsZSAxOiBgbWFya3lgIFN5bnRheCB7LX0KPD8hCnggPSAxMjMK
eSA9IDQ1CmRlZiBhYmNfZnVuKHYsIGEsIGIsIGMpOgoJcmV0dXJuIGEgaWYgdiA8IDEwMCBl
bHNlIGIgaWYgdiA9PSAxMDAgZWxzZSBjCkxFRyA9IGxhbWJkYSB2OiBhYmNfZnVuKHYsICJs
ZXNzZXIiLCAiZXF1YWwiLCAiZ3JlYXRlciIpCj8+CmBgYHBocAo8XD97e19fXyhjb2RlPVRy
dWUpfX0/XD4KYGBgCmBgYG1hcmtkb3duClRoaXMgaXMgYW4gZXhhbXBsZSB3aXRoIGEgdmFs
dWUgeD17XHt4fVx9LCB3aGljaCBpcwp7XHtMRUcoeCl9XH0gdGhhbiAxMDAuIFRoZXJlIGlz
IGFub3RoZXIgdmFsdWUgeT17XHt5fVx9LAp3aGljaCBpcyB7XHtMRUcoeSl9XH0gdGhhbiAx
MDAuIEJvdGggdmFsdWVzIHRvZ2V0aGVyCmFyZSB4K3k9e1x7eCt5fVx9LgpgYGAKIyMjIyBS
dW4gYW5kIE91dHB1dCB7LX0KYGBgbWFya2Rvd24KVGhpcyBpcyBhbiBleGFtcGxlIHdpdGgg
YSB2YWx1ZSB4PXt7eH19LCB3aGljaCBpcwp7e0xFRyh4KX19IHRoYW4gMTAwLiBUaGVyZSBp
cyBhbm90aGVyIHZhbHVlIHk9e3t5fX0sCndoaWNoIGlzIHt7TEVHKHkpfX0gdGhhbiAxMDAu
IEJvdGggdmFsdWVzIHRvZ2V0aGVyCmFyZSB4K3k9e3t4K3l9fS4KYGBgCgpUaGUgZm9sbG93
aW5nIGV4YW1wbGUgY29udGFpbnMgbWV0YSBkYXRhIGluIHRoZSBmcm9udCBtYXR0ZXIKYW5k
ICBjYW4gYmUgcmVuZGVyZWQgaW50byBgcGRmYCBhbmQgYGh0bWxgIGJ5IGp1c3QgY2FsbGlu
ZwpgbWFrZSBwZGYvZmlsZWAgb3IgYG1ha2UgaHRtbC9maWxlYC4KCiMjIyMgRXhhbXBsZSAy
OiBgbWQvZmlsZS5tZGAgey19CmBgYHBocAotLS0KdGl0bGU6IEFuIEV4YW1wbGUKLS0tCjxc
P3t7X19fKGNvZGU9VHJ1ZSl9fT9cPgpgYGAKIyMjIyBPdXRwdXQgYGJ1aWxkL2ZpbGUubWRg
IHstfQpgYGBtYXJrZG93bgotLS0KdGl0bGU6IEFuIEV4YW1wbGUKLS0tCjw/IQpkZWYgY2Fw
X2ZpcnN0KGkpOgoJcmV0dXJuICIgIi5qb2luKFtpWzBdLnVwcGVyKCkgKyBpWzE6XSBmb3Ig
aSBpbiBpLnNwbGl0KCldKQpmb3IgaSBpbiBbInZlcnkiLCAibm90IHNvIl06Cgk/PgoqKnt7
Y2FwX2ZpcnN0KGkpfX0gU2VjdGlvbioqCgpUbyBkYXkgaXMgYSB7e2l9fSB2ZXJ5IG5pY2Ug
ZGF5LgpUaGUgc3VuIGlzIHNoaW5pbmcge3tpfX0gYnJpZ2h0IGFuZAp0aGUgYmlyZHMgYXJl
IHNpbmdpbmcge3tpfX0gbG91ZCBhbmQKZmx5IHt7aX19IGhpZ2ggaW4gdGhlIHt7aX19IGJs
dWUgc2t5LgoJPD8KPz4KYGBgCgojIyBIb3cgZG9lcyBgbWFya3lgIHdvcmsgaW50ZXJuYWxs
eT8KCmBtYXJreWAgdXNlcyBhbiBleHRyZW1lbHkgc2ltcGxlIG1lY2hhbmlzbSBmb3IgZ2Vu
ZXJhdGluZyBhIHB5dGhvbiBwcm9ncmFtbQpmcm9tIHRoZSBNYXJrZG93biB0ZXh0LiBVc2lu
ZyB0aGUgYDxcPy4uLj9cPmAgYW5kIGB7XHsuLi59XH1gIHN0YXRlbWVudCwKUHl0aG9uIGNv
ZGUgaXMgZW1iZWRkZWQgaW50byB0aGUgTWFya2Rvd24gdGV4dCBhbmQgdHJhbnNsYXRlZCBp
bnRvIGEgc2VyaWVzCm9mIGNhbGxzIHRvIHRoZSBgX19fKClgIGZ1bmN0aW9uIHVzaW5nIGBm
YC1zdHJpbmdzIGFzIGFyZ3VtZW50cywgd2hlcmUKcHl0aG9uIHZhcmlhYmxlcyBhcmUgcmVm
ZXJlbmNlZC4gVGhpcyByZXN1bHRzIGludG8gYSBweXRob24gcHJvZ3JhbQp3aGljaCBjYW4g
Z2VuZXJhdGUgTWFya2Rvd24gdGV4dCBhbGdvcml0aG1pY2FsbHkuCgojIyMjIEV4YW1wbGU6
IGBtZC9maWxlLm1kYCB7LX0KYGBgcGhwCiogVGhpcyBpcyB7Zmlyc3R9LiA8XD8KeCA9IDEg
IyB0aGlzIGlzIGNvZGUKZm9yIGkgaW4gcmFuZ2UoMyk6CglpZiB4OgoJCT9cPgp7XHtpKzF9
XH0uIFRoZSB2YWx1ZSBpcyB7XHtce3h9XH1cfS4KPFw/CgllbHNlOgoJCT9cPntce2krMX1c
fS4gVGhlIHZhbHVlIGlzIHplcm8uCjxcPwoJeCA9IDAKP1w+KiBUaGlzIGlzIGxhc3QuCmBg
YApUaGUgZmlsZSBwcm9kdWNlcyB0aGUgZm9sbG93aW5nIE1hcmtkb3duIG91dHB1dC4KCiMj
IyMgT3V0cHV0OiBNYXJrZG93biB7LX0KYGBgYmFzaAoqIFRoaXMgaXMge2ZpcnN0fS4gPD8K
eCA9IDEgIyB0aGlzIGlzIGNvZGUKZm9yIGkgaW4gcmFuZ2UoMyk6CglpZiB4OgoJCT8+Cnt7
aSsxfX0uIFRoZSB2YWx1ZSBpcyB7e3t4fX19Lgo8PwoJZWxzZToKCQk/Pnt7aSsxfX0uIFRo
ZSB2YWx1ZSBpcyB6ZXJvLgo8PwoJeCA9IDAKPz4qIFRoaXMgaXMgbGFzdC4KYGBgCgpgbWFy
a3lgIHRyYW5zZm9ybXMgdGhlIE1hcmtkb3duIGludG8gUHl0aG9uIHNvdXJjZSBjb2RlLgpF
eGVjdXRpb24gb2YgdGhlIFB5dGhvbiBzb3VyY2UgY29kZSB5aWVsZHMgdGhlIG5ldyBNYXJr
ZG93biB0ZXh0LgoKIyMjIyBPdXRwdXQ6IGBidWlsZC9maWxlLnB5YCB7LX0KYGBgcHl0aG9u
Cl9fXyhyZiIiIiogVGhpcyBpcyB7XHtmaXJzdH1cfS4gIiIiLCBfX18pOwp4ID0gMSAjIHRo
aXMgaXMgY29kZQpmb3IgaSBpbiByYW5nZSgzKToKCWlmIHg6CgkJX19fKHJmIiIiCntpKzF9
LiBUaGUgdmFsdWUgaXMge1x7XHt4fVx9XH0uCiIiIiwgX19fKTsKCWVsc2U6CgkJX19fKHJm
IiIie2krMX0uIFRoZSB2YWx1ZSBpcyB6ZXJvLgoiIiIsIF9fXyk7Cgl4ID0gMApfX18ocmYi
IiIqIFRoaXMgaXMgbGFzdC4KIiIiLCBfX18pOwpgYGAKCiMgUXVpY2sgU3RhcnQKCiMjIGBt
YXJreWAgRGVwZW5kZW5jaWVzCgpgbWFya3lgIGRlcGVuZHMgb24gYHBhbmRvY2AgYW5kIGBw
eXlhbWxgLiBgcGFuZG9jYCBpcyB1c2VkIGZvciByZW5kZXJpbmcKdGhlIE1hcmtkb3duIGlu
dG8gYGh0bWxgIGFuZCBgcGRmYC4gYG1hcmt5YCB1c2VzCltwYW5kb2NdKGh0dHBzOi8vd3d3
LnBhbmRvYy5vcmcvKSBmb3IgcmVuZGVyaW5nIGBodG1sYCBhbmQgYHBkZmAuCmBwYW5kb2M+
PTIuMTBgIHJlbGVhc2VzIGNhbiBiZSBmb3VuZApbaGVyZV0oaHR0cHM6Ly9naXRodWIuY29t
L2pnbS9wYW5kb2MvcmVsZWFzZXMpLgpUaGUgb3RoZXIgcGFja2FnZXMgY2FuIGJlIGluc3Rh
bGxlZCB3aXRoIGBwaXBgLgoKYGBgYmFzaApwaXAgaW5zdGFsbCBwYW5kb2MtZmlnbm9zCnBp
cCBpbnN0YWxsIHBhbmRvYy1lcW5vcwpwaXAgaW5zdGFsbCBwYW5kb2Mtc2Vjbm9zCnBpcCBp
bnN0YWxsIHBhbmRvYy10YWJsZW5vcwpwaXAgaW5zdGFsbCBwYW5kb2MteG5vcwpwaXAgaW5z
dGFsbCBweXlhbWwKYGBgCgojIyBgbWFya3lgIFdvcmtmbG93CgpXb3JrZmxvdyBmb3IgY3Jl
YXRpbmcgYGh0bWxgIG9yIGBwZGZgIHVzaW5nIGBtYXJreWAgYnkKaW52b2NhdGlvbiBvZiBg
bWFrZSBzY2FuYCBhbmQgYG1ha2UgYWxsYC4KCiptYWtlKnwxLiAqd3JpdGUqICB8ICB8Mi4g
KmJ1aWxkKiAgICAgICAgICB8ICB8My4gKnJlbmRlcioKLS0tLS0tfC0tLS0tLS0tLS0tLXwt
LXwtLS0tLS0tLS0tLS0tLS0tLS0tLXwtLXwtLS0tLS0tLS0tLS0tLS0tCmBwZGZgIHwgICAg
ICAgICAgICB8ICB8YGJ1aWxkL2ZpbGUuaHRtbC5tZGB8LT58YGh0bWwvZmlsZS5odG1sYApg
LWAgICB8YG1kL2ZpbGUubWRgfC0+fCAgICAgICAgICAgICAgICAgICAgfCAgfApgaGZtbGB8
ICAgICAgICAgICAgfCAgfGBidWlsZC9maWxlLnBkZi5tZGAgfC0+fGBwZGYvZmlsZS5wZGZg
CgoxLiAqKndyaXRlKio6IHVzZXIgd3JpdGVzIGEgTWFya2Rvd24gdGV4dCBmaWxlIGFuZCBw
bGFjZXMgaXQgaW4gYG1kLyoubWRgCmRpcmVjdG9yeSB3aXRoIHRoZSBleHRlbnNpb24gYC5t
ZGAuCjIuICoqYnVpbGQqKjogYG1hcmt5YCB0cmFuc2Zvcm1zIHRoZSBmaWxlcyBpbiBgbWQv
Ki5tZGAgaW50byByZWd1bGFyIE1hcmtkb3duIHRleHQKYW5kIHBsYWNlcyB0aGUgdHJhbnNm
b3JtZWQgZmlsZXMgaW4gYGJ1aWxkL2AuCjMuICoqcmVuZGVyKio6IHRoZSByZWd1bGFyIE1h
cmtkb3duIHRleHQgaW4gdGhlIGZpbGVzIGBidWlsZC8qLm1kYCBpcyByZW5kZXJlZCBpbnRv
CmBodG1sYCBhbmQgYHBkZmAgdXNpbmcgYHBhbmRvY2AuCgpUaGUgdGhyZWUgc3RlcHMgYXJl
IGltcGxlbWVudGVkIGluIGEgTWFrZWZpbGUuCgojIyBEb3dubG9hZCBhbmQgSW5pdGlhbGl6
ZQoKYG1hcmt5YCBpcyBzdXBwbGllZCBhcyBhIHNpbmdsZS1maWxlIHNjcmlwdCB3aGljaCBh
dXRvbWF0aWNhbGx5CnNldHMgdXAgdGhlIHByb2plY3Qgc3RydWN0dXJlIGNvbnRhaW5pbmcg
YWxsIHNjcmlwdHMKcmVxdWlyZWQgZm9yIHByb2Nlc3NpbmcgYW5kIHJlbmRlcmluZyBNYXJr
ZG93bi4KCkZvciBleGFtcGxlLCBkb3dubG9hZCBgbWFya3lgIGZyb20gZ2l0aHViLgpgYGBi
YXNoCmdpdCBjbG9uZSBodHRwczovL2xlaG1hbm43LmdpdGh1Yi5jb20vbWFya3kuZ2l0CmNk
IG1hcmt5CmBgYAoKQWZ0ZXIgZG93bmxvYWQsIHRoZSBgbWFya3lgIGVudmlyb25tZW50IGlz
IGluaXRpYWxpemVkIHVzaW5nIGBtYXJreWAuCmBgYGJhc2gKLi9tYXJreS5weSAtLWluaXQK
IyBta2RpciBidWlsZC8KIyBta2RpciBkYXRhCiMgbWtkaXIgbWQvCiMgV1JJVEUgTWFrZWZp
bGUKIyBXUklURSBwYW5kb2MtcnVuCiMgV1JJVEUgbWQvbWFya3kubWQKIyBXUklURSAuZ2l0
aWdub3JlCiMgVVNBR0UKbWFrZSBoZWxwCmBgYAoKIyMgYG1hcmt5YCBFbnZpcm9ubWVudAoK
RHVyaW5nIGluaXRpYWxpemF0aW9uLCBgbWFya3lgIGNyZWF0ZXMgZGlyZWN0b3JpZXMgYW5k
IGZpbGVzLgpBZnRlciBpbml0aWFsaXphdGlvbiwgdGhlIGZvbGxvd2luZyBzdHJ1Y3R1cmUg
aXMgYXV0by1nZW5lcmF0ZWQKaW4gdGhlIHByb2plY3QgZGlyZWN0b3J5LiBgbWFya3lgIHNo
b3dzIHRoZSBwcm9qZWN0IHN0cnVjdHVyZQp3aGVuIGludm9raW5nIGBtYWtlIHRyZWVgLgpg
YGBiYXNoCjw/Cl9fXyh0ZXh0X3Byb2MoIm1ha2UgdHJlZSIpKQo/PgpgYGAKClRoZSBzY3Jp
cHQgYHBhbmRvYy1ydW5gIGNhbiBiZSBhZGp1c3RlZCBpbiBjYXNlIHNwZWNpZmljCmBwYW5k
b2NgIG9wdGlvbnMgYXJlIHJlcXVpcmVkIGZvciByZW5kZXJpbmcgdGhlIGBodG1sYCBhbmQg
YHBkZmAgZG9jdW1lbnRzLgoKIyMgRG9jdW1lbnQgUmVuZGVyaW5nCgpCeSBpbnZva2luZyBg
bWFrZSBhbGxgIGFsbCBmaWxlcyBgbWQvKi5tZGAgYXJlIHRyYW5zZm9ybWVkCmludG8gY29y
cmVzcG9uZGluZyBgaHRtbC8qLmh0bWxgIGFuZCBgcGRmLyoucGRmYCBmaWxlcy4gQnkKaW52
b2tpbmcgYG1ha2UgaHR0cGRgIGEgcHl0aG9uIHdlYiBzZXJ2ZXIgaXMgc3RhcnRlZCBpbiBg
aHRtbC9gLgoKQWxsIHVzZXItZ2VuZXJhdGVkIE1hcmtkb3duIGNvbnRlbnQgZ29lcyBpbnRv
IGBtZC8qYCB1c2VyLWdlbmVyYXRlZApkYXRhIGZpbGVzIGdvIGludG8gYGRhdGEvKmAuCgoq
KkFUVEVOVElPTjoqKiBUaGUgZmlsZXMgaW4gdGhlIGRpcmVjdG9yaWVzIGBidWlsZC8qYCBh
cmUKKiphdXRvLWdlbmVyYXRlZCoqLiBBbGwgdXNlciBmaWxlcyBoYXZlIHRvIGJlIHBsYWNl
ZCBpbnNpZGUgdGhlCmRpcmVjdG9yeSBgbWQvKmAuIEludm9raW5nIGBtYWtlIGNsZWFuYCB3
aWxsICoqZGVsZXRlIGFsbCBmaWxlcyoqCmluIGBodG1sL2AsIGBidWlsZC9gIGFuZCBgcGRm
L2AuCgojIyBJbnRlZ3JhdGVkIERvY3VtZW50YXRpb24KCmBtYXJreWAgaGFzIGFuIGludGVn
cmF0ZWQgZW52aXJvbm1lbnQuIFVzaW5nIGBtYWtlIGhlbHBgIGRpc3BsYXlzCmEgc2hvcnQg
aW5mbyBhYm91dCB0aGUgYG1hcmt5YCBkZXBlbmRlbmNpZXMsIG1ha2UgdGFyZ2V0cyBhbmQK
ZXhhbXBsZXMuCmBgYGJhc2gKPD8KX19fKHRleHRfcHJvYygibWFrZSBoZWxwIikpCj8+CmBg
YAoKIyBgbWFya3lgIEZlYXR1cmVzCgpJbiBvcmRlciB0byBxdWljayBzdGFydCBhIG5ldyBN
YXJrZG93biBwcm9qZWN0LCBqdXN0IGxpbmsgdGhlCmBtYXJreS5weWAgZXhlY3V0YWJsZSBp
biB0aGUgcHJvamVjdCBkaXIgYW5kIGluaXRpYWxpemUKdGhlIGVudmlyb25tZW50LgpgYGBi
YXNoCm1rZGlyIG15X3Byb2plY3QKY2QgbXlfcHJvamVjdAouL21hcmt5LnB5IC0taW5pdApg
YGAKCk5vdyBgbWFya3lgIGlzIHJlYWR5IGZvciBvcGVyYXRpb24uIFBsYWNlIGEgbmV3IGZp
bGUgaW4gYG1kL2ZpbGUubWRgCmFuZCBydW4gdGhlIGZvbGxvd2luZyBjb21tYW5kcy4KYGBg
YmFzaAp0b3VjaCBtZC9maWxlLm1kCm1ha2Ugc2NhbgojIFdSSVRFIGJ1aWxkL2ZpbGUubWFr
ZQpgYGAKCmBtYXJreWAgZGlzY292ZXJzIHRoZSBuZXcgZG9jdW1lbnQgd2hlbiBpbnZva2lu
ZyBgbWFrZSBzY2FuYC4KYG1hcmt5YCBhbHNvIHJlbmRlcnMgYGh0bWxgIGFuZCBgcGRmYCB1
c2luZyBtYWtlIHRhcmdldHMuCmBgYGJhc2gKbWFrZSBodG1sL2ZpbGUKbWFrZSBwZGYvZmls
ZQpgYGAKCiMjIE1ldGEgRGF0YSBpbiBGcm9udCBNYXR0ZXIKCklmIGRvY3VtZW50IHN0YXJ0
cyB3aXRoIGAtLS1gLCB5YW1sIGlzIHVzZWQgdG8gcGFyc2UKdGhlIGZyb250IG1hdHRlciBi
bG9jayBkZWxpbWl0ZWQgYnkgYC0tLWAuCkFsbCBtZXRhIGRhdGEga2V5cyB3aWxsIGJlIGV4
cG9zZWQgaW50byB0aGUgcHl0aG9uIHNjb3BlIGFzIGEgbG9jYWwKdmFyaWFibGUsIHVubGVz
cyB0aGUgdmFyaWFibGUgYWxyZWFkeSBleGlzdHMuCgojIyMjIEV4YW1wbGUgey19CmBgYG1h
cmtkb3duCi0tLQp0aXRsZTogInt7dGl0bGV9fSIKYXV0aG9yOiAuLi4KZGF0ZTogMjAyMi0w
MS0wMQotLS0KVGhlIHRpdGxlIG9mIHRoaXMgZG9jdW1lbnQgaXMge1x7dGl0bGV9XH0uCmBg
YAojIyMjIE91dHB1dCB7LX0KYGBgbWFya2Rvd24KLS0tCnRpdGxlOiAie3t0aXRsZX19Igph
dXRob3I6IC4uLgpkYXRlOiAyMDIyLTAxLTAxCi0tLQpUaGUgdGl0bGUgb2YgdGhpcyBkb2N1
bWVudCBpcyB7e3RpdGxlfX0uCmBgYAoKIyMgSW5saW5lIEZvcm1hdHRlZCBPdXRwdXQKClB5
dGhvbiBsb2NhbCB2YXJpYWJsZXMgYW5kIHZhcmlhYmxlcyBmcm9tIG1ldGEgZGF0YSBpbiBm
cm9udCBtYXR0ZXIKY2FuIGJlIGFjY2Vzc2VkIGRpcmV0bHkgZnJvbSB0aGUgbWFya2Rvd24g
dGV4dC4KVGhlIGB7XHsuLi59XH1gIHN0YXRlbWVudCB1c2VzIHN5bnRheCBzaW1pbGFyIHRv
IHB5dGhvbiBgZmAtc3RyaW5ncyBmb3IKZm9ybWF0dGVkIG91dHB1dCBvZiB2YXJpYWJsZXMg
YW5kIHJlc3VsdHMgb2YgZXhwcmVzc2lvbnMgaW50byBNYXJrZG93bgp0ZXh0LiBUaGUgYG1h
cmt5YCBvcGVyYXRvciBge1x7PGV4cHJlc3Npb24+Wzo8Zm9ybWF0Pl19XH1gIHVzZXMgdGhl
CnN5bnRheCBvZiBbYGZgLXN0cmluZ3NdKGh0dHBzOi8vZG9jcy5weXRob24ub3JnLzMvcmVm
ZXJlbmNlL2xleGljYWxfYW5hbHlzaXMuaHRtbCNmLXN0cmluZ3MpLgoKIyMjIyBFeGFtcGxl
IDEgey19CmBgYGJhc2gKVGl0bGUgb2YgdGhpcyBkb2N1bWVudCBpcyB7XHt0aXRsZX1cfSBh
bmQgZm9udCBzaXplIGlzIHtce2ZvbnRzaXplfVx9LgpgeGAgaXMge1x7eH1cfSBhbmQge1x7
IiwiLmpvaW4oW3N0cihpKSBmb3IgaSBpbiByYW5nZSh4LTEwLHgpXSl9XH0uCmBgYAojIyMj
IE91dHB1dCB7LX0KPiBUaXRsZSBvZiB0aGlzIGRvY3VtZW50IGlzIHt7dGl0bGV9fSBhbmQg
Zm9udCBzaXplIGlzIHt7Zm9udHNpemV9fS4KPiBgeGAgaXMge3t4fX0gYW5kIHt7IiwiLmpv
aW4oW3N0cihpKSBmb3IgaSBpbiByYW5nZSh4LTEwLHgpXSl9fS4KCiMjIyMgRXhhbXBsZSAy
IHstfQo8PyEKeCA9IGludCgxKQp5ID0gZmxvYXQoMi4zKQp6ID0gMAphID0gWzEsIDIsIDNd
CmIgPSAoNCwgNSkKPz4KYGBgcHl0aG9uCnt7X19fKGNvZGU9VHJ1ZSwgY3JvcD1UcnVlKX19
CmBgYApgYGBtYXJrZG93bgpUaGlzIGlzIGEgcGFyYWdyYXBoIGFuZCB4IGlzIHtce3g6MDNk
fVx9IGFuZCB5IGlzIHtce3k6LjJmfVx9LgpPdGhlciBjb250ZW50IGlzOiBhID0ge1x7YX1c
fSwgYiA9IHtce2J9XH0uCmBgYAojIyMjIE91dHB1dCB7LX0KPiBUaGlzIGlzIGEgcGFyYWdy
YXBoIGFuZCB4IGlzIHt7eDowM2R9fSBhbmQgeSBpcyB7e3k6LjJmfX0uCj4gT3RoZXIgY29u
dGVudCBpczogYSA9IHt7YX19LCBiID0ge3tifX0uCgojIyBFbWJlZGRpbmcgUHl0aG9uIENv
ZGUKClB5dGhvbiBjb2RlIGJsb2NrcyBhcmUgZW1iZWRkZWQgaW50byBNYXJrZG93biB1c2lu
ZyBgPFw/Li4uP1w+YCBhbmQgYHtcey4uLn1cfWAuCkFsbCBjb2RlIGJsb2NrcyBzcGFuIG9u
ZSBsYXJnZSBzY29wZSBzaGFyaW5nIGZ1bmN0aW9ucyBhbmQgbG9jYWwKdmFyaWFibGVzLiBN
ZXRhIGRhdGEgaXMgaW1wb3J0ZWQgZnJvbSBNYXJrZG93biBmcm9udCBtYXR0ZXIgYXMgbG9j
YWwKdmFyaWFibGVzIGluIHRoZSBweXRob24gc2NvcGUuIFRoZSBgaW1wb3J0YCBzdGF0ZW1l
bnQgY2FuIGJlIHVzZWQgaW4KcHl0aG9uIGNvZGUgaW4gb3JkZXIgdG8gYWNjZXNzIGluc3Rh
bGxlZCBweXRob24gcGFja2FnZXMgYXMgdXN1YWwuCgojIyMgVmlzaWJsZSBDb2RlCgpVc2lu
ZyBgPFw/IS4uLj9cPmAgY29kZSBpcyBleGVjdXRlZCBhbmQgc3RvcmVkLgpUaGUgdGV4dCBv
ZiB0aGUgbGFzdCBgPFw/IS4uLj9cPmAgYmxvY2sgY2FuIGJlCmFjY2Vzc2VkIGFuZCBwbGFj
ZWQgdmlhIGB7XHtfX18oY29kZT1UcnVlKX1cfWAuCgojIyMjIEV4YW1wbGUgey19CmBgYHB5
dGhvbgo8XD8hCnggPSA0MiAjIHZpc2libGUgY29kZQpwcmludCgiSGVsbG8gY29uc29sZSEi
KQo/XD4Ke1x7X19fKGNvZGU9VHJ1ZSl9XH0KYGBgCgojIyMjIFJ1biBhbmQgT3V0cHV0IHst
fQo8PyEKeCA9IDQyICMgdmlzaWJsZSBjb2RlCnByaW50KCJIZWxsbyBjb25zb2xlISIpCj8+
CmBgYHB5dGhvbgp7e19fXyhjb2RlPVRydWUsIGNyb3A9VHJ1ZSl9fQpgYGAKCioqQVRURU5U
SU9OOioqIFVzaW5nIHRoZSBgcHJpbnQoKWAgZnVuY3Rpb24gdGhlIHRleHQgd2lsbCBiZSBw
cmludGVkCnRvIHRoZSBjb25zb2xlIGFuZCAqKm5vdCoqIGluc2lkZSB0aGUgcmVzdWx0aW5n
IE1hcmtkb3duIHRleHQuCgojIyMgSGlkZGVuIENvZGUKClVzaW5nIGA8XD8uLi4/XD5gIGNv
ZGUgaXMgZXhlY3V0ZWQgYnV0IG5vdCBzaG93biBpbiBNYXJrZG93bi4KCiMjIyMgRXhhbXBs
ZSB7LX0KYGBgcHl0aG9uCjxcP3t7X19fKGNvZGU9VHJ1ZSl9fT9cPgpgYGAKIyMjIyBSdW4g
YW5kIE91dHB1dCB7LX0KYGBgcHl0aG9uCjw/IQp4ID0gNDEgIyBoaWRkZW4gY29kZQpfX18o
ZiJPdXRwdXQgdG8gTWFya2Rvd24uIHggPSB7eH0hIikKPz4KYGBgCgoqKkFUVEVOVElPTjoq
KiBVc2luZyB0aGUgYF9fXygpYCBmdW5jdGlvbiB0aGUgdGV4dCB3aWxsIGJlIHByaW50ZWQK
aW5zaWRlIHRoZSByZXN1bHRpbmcgTWFya2Rvd24gdGV4dCAqKmFuZCBub3QqKiBvbiB0aGUg
Y29uc29sZS4KCiMjIFRoZSBgX19fKClgIEZ1bmN0aW9uCgpVc2luZyB0aGUgYHByaW50KClg
IHN0YXRlbWVudCB0aGUgdGV4dCB3aWxsIGJlIHByaW50ZWQgdG8gdGhlIGNvbnNvbGUuCldo
ZW4gdXNpbmcgdGhlIGBfX18oKWAgc3RhdGVtZW50IG5ldyBNYXJrZG93biB0ZXh0IGlzCmlu
c2VydGVkIGR5bmFtaWNhbGx5IGludG8gdGhlIGRvY3VtZW50IGR1cmluZyBwcmVwcm9jZXNz
aW5nLgoKIyMjIyBFeGFtcGxlOiBMaW5lIEJyZWFrIHstfQpgYGBweXRob24KPFw/e3tfX18o
Y29kZT1UcnVlKX19P1w+CmBgYAojIyMjIFJ1biBhbmQgT3V0cHV0IHstfQpgYGBiYXNoCjw/
IQp4ID0gNDAgIyBoaWRkZW4gY29kZQpfX18oIk91dHB1dCBpbiAiLCBfX18pCl9fXygic2lu
Z2xlIGxpbmUhICIsIF9fXykKX19fKGYieCA9IHt4fSIpCj8+CmBgYAoKIyMjIyBFeGFtcGxl
OiBTaGlmdCwgQ3JvcCwgUmV0dXJuIHstfQpgYGBweXRob24KPFw/e3tfX18oY29kZT1UcnVl
KX19P1w+CmBgYAojIyMjIFJ1biBhbmQgT3V0cHV0IHstfQpgYGBiYXNoCjw/IQpyZXN1bHQg
PSBfX18oIiIiCiAgICogdGV4dCBpcyBjcm9wcGVkIGFuZCBzaGlmdGVkCiAgICAgICAgICog
c2hpZnQgYW5kIGNyb3AKICAgICAgICAgICAgKiBjYW4gYmUgY29tYmluZWQKICAgICAgICAg
ICogcmV0dXJuaW5nIHRoZSByZXN1bHQKIiIiLCBzaGlmdD0iIyMjIyMjIyMiLCBjcm9wPVRy
dWUsIHJldD1UcnVlKQpfX18ocmVzdWx0KQo/PgpgYGAKCiMjIEFsZ29yaXRobWljIFRhYmxl
IEV4YW1wbGUKCkB0Ymw6YWxndCBpcyBnZW5lcmF0ZWQgdXNpbmcgdGhlIGZvbGxvd2luZyBw
eXRob24gY2xvZGUgYmxvY2suCgo8PyEKbiA9IDUKdGFibGUgPSAiIgpkZWMgPSBbIiolcyoi
LCAiKiolcyoqIiwgIn5+JXN+fiIsICJgJXNgIiwKICAgICAgIHIiJFx0aW1lc14lcyQiLCAi
JFxpbmZ0eV8lcyQiXQp0YWJsZSArPSAifCIuam9pbigiWCIqbikgKyAiXG4iICsgInwiLmpv
aW4oIi0iKm4pICsgIlxuIgpmb3IgaSBpbiByYW5nZShuKToKCWZpbGwgPSBbY2hyKG9yZCgi
QSIpKygyKmkrMyprKSUyNikgZm9yIGsgaW4gcmFuZ2UoaSsxKV0KCWZpbGwgPSBbZGVjWyhs
K2kpJWxlbihkZWMpXSVrIGZvciBsLCBrIGluIGVudW1lcmF0ZShmaWxsKV0KCXRleHQgPSBs
aXN0KCIwIikqbgoJdGV4dFsobj4+MSktKGk+PjEpOihuPj4xKSsoaT4+MSldID0gZmlsbAoJ
dGFibGUgKz0gInwiLmpvaW4odGV4dCkgKyAiXG4iCj8+CmBgYHB5dGhvbgp7e19fXyhjb2Rl
PVRydWUsIGNyb3A9VHJ1ZSl9fQpgYGAKCnt7dGFibGV9fQoKVGFibGU6IFRhYmxlIGlzIGdl
bmVyYXRlZCB1c2luZyBjb2RlIGFuZCB0aGUgYF9fXygpYCBzdGF0ZW1lbnQuIHsjdGJsOmFs
Z3R9CgojIyBGb3JtYXQgTGluayBFeHRlbnNpb24KCldoZW4gd3JpdGluZyBtdWx0aXBsZSBk
b2N1bWVudHMsIG9mdGVuIGRvY3VtZW50cyBhcmUgcmVmZXJlbmNlZApiZXR3ZWVuIGVhY2gg
b3RoZXIgdXNpbmcgbGlua3MuIEluIG9yZGVyIHRvIHJlZmVyIHRvIGV4dGVybmFsCmBodG1s
YCBhbmQgYHBkZmAgZG9jdW1lbnRzIHRoZSBNYXJrZG93biBsaW5rIHN0YXRlbWVudCBpcyB1
c2VkLgpgYGBtZApbTGluayBDYXB0aW9uXShwYXRoL3RvL2ZpbGUuaHRtbCkKW0xpbmsgQ2Fw
dGlvbl0ocGF0aC90by9maWxlLnBkZikKYGBgCk9uZSBsaW5rIHN0YXRlbWVudCBjYW5ub3Qg
YmUgdXNlZCBmb3IgcmVuZGVyaW5nIGBodG1sYCBhbmQgYHBkZmAKd2l0aCBjb25zaXN0ZW50
IHBhdGhzLiBVc2luZyB0aGUgYG1hcmt5YCBmb3JtYXQgbGluawogYC5cPz8/YCBmaWxlIGV4
dGVuc2lvbiByZXN1bHRzIGluIGNvbnNpc3RlbnQgbGlua3MgZm9yIGBodG1sYCBhbmQKYHBk
ZmAgZG9jdW1lbnRzLgoKIyMjIyBFeGFtcGxlIHstfQpgYGBtZApbTGluayB0byB0aGlzIERv
Y3VtZW50XShtYXJreS5cPz8/KQpgYGAKIyMjIyBPdXRwdXQgey19Cj4gW0xpbmsgdG8gdGhp
cyBEb2N1bWVudF0obWFya3kuPz8/KQoKIyMgRm9ybWF0IENvZGVzCgpPZnRlbiB3aGVuIHdy
aXRpbmcgbWFya2Rvd24gZm9yIGBodG1sYCBhbmQgYHBkZmAgZG9jdW1lbnRzLCB0aGUKb3V0
cHV0IG5lZWRzIHRvIGJlIHR3ZWFrZWQgYWNjb3JkaW5nbHkuCmBtYXJreWAgc3VwcG9ydHMg
Zm9ybWF0IHNwZWNpZmljIHR3ZWFraW5nIGJ5IGluamVjdGluZwpyYXcgYGh0bWxgIG9yIGB0
ZXhgIGNvZGUgaW50byBNYXJrZG93biB1c2luZyBmb3JtYXQgY29kZXMuCgpJbiBvcmRlciB0
byBpbmplY3QgZm9ybWF0IHNwZWNpZmljIGNvZGUgdGhlIGBmbXRjb2RlYCBjbGFzcyBpcyB1
c2VkLgpUaGUgYGZtdGNvZGVgIGNsYXNzIG1hbmFnZXMgaW5qZWN0aW9uIG9mIGBodG1sYCBh
bmQgYHRleGAgY29kZQpkZXBlbmRpbmcgb24gdGhlIG91dHB1dCBmb3JtYXQuCgoqKkFUVEVO
VElPTjoqKiBgdGV4YCBwYWNrYWdlcyBoYXZlIHRvIGJlIGluY2x1ZGVkIGZvciBgcGRmYCBh
cyB3ZWxsIGFzCkphdmFTY3JpcHQgYW5kIHN0eWxlIHNoZWV0cyBmb3IgYGh0bWxgIHVzaW5n
IHRoZSBtZXRhIGRhdGEgZmllbGRzCmBoZWFkZXItaW5jbHVkZXMtLXBkZmAgYW5kIGBoZWFk
ZXItaW5jbHVkZXMtLWh0bWxgIHJlc3BlY3RpdmVseS4KCiMjIyMgRXhhbXBsZTogYGZtdGNv
ZGVgIHstfQo8PyEKRiA9IGZtdGNvZGUoaHRtbD0iSDxzdXA+VDwvc3VwPjxzdWI+TTwvc3Vi
PkwiLCBwZGY9ciJcTGFUZVgiKQo/PgpgYGBweXRob24Ke3tfX18oY29kZT1UcnVlLCBjcm9w
PVRydWUpfX0KYGBgCmBgYG1hcmtkb3duCkludm9jYXRpb24gb2YgZm9ybWF0IGNvZGUgcmVz
dWx0cyBpbjoge1x7RigpfVx9LgpgYGAKIyMjIyBPdXRwdXQgey19Cj4gSW52b2NhdGlvbiBv
ZiBmb3JtYXQgY29kZSByZXN1bHRzIGluOiB7e0YoKX19LgoKIyMjIyBFeGFtcGxlOiBDb2xv
ciB7LX0KPD8hCkMgPSBsYW1iZGEgY29sb3I6IGZtdGNvZGUoCglodG1sPSI8c3BhbiBzdHls
ZT0nY29sb3I6JXM7Jz57MH08L3NwYW4+IiAlIGNvbG9yLAoJcGRmPXIiXHRleHRjb2xvcnt7
JXN9fXt7ezB9fX0iICUgY29sb3IKKQpCID0gQygiYmx1ZSIpClIgPSBDKCJyZWQiKQo/Pgpg
YGBweXRob24Ke3tfX18oY29kZT1UcnVlLCBjcm9wPVRydWUpfX0KYGBgCmBgYG1hcmtkb3du
ClRleHQgd2l0aCB7XHtCKCJibHVlIil9XH0gYW5kIHtce1IoIlJFRCIpfVx9LgpgYGAKIyMj
IyBPdXRwdXQgey19Cj4gVGV4dCB3aXRoIHt7QigiYmx1ZSIpfX0gYW5kIHt7UigiUkVEIil9
fS4KCgojIyMjIEV4YW1wbGU6IENsYXNzZXMgey19Cjw/IQpjbGFzcyBjb2xvcjoKCWRlZiBf
X2luaXRfXyhzZWxmLCBjb2xvcik6CgkJc2VsZi5jb2xvciA9IGNvbG9yCglkZWYgdXBwZXIo
c2VsZiwgeCk6CgkJcmV0dXJuIHNlbGYudGV4dCh4LnVwcGVyKCkpCglkZWYgbG93ZXIoc2Vs
ZiwgeCk6CgkJcmV0dXJuIHNlbGYudGV4dCh4Lmxvd2VyKCkpCgpjbGFzcyBodG1sKGNvbG9y
KToKCWRlZiB0ZXh0KHNlbGYsIHgpOgoJCXJldHVybiBmIjxzcGFuIHN0eWxlPSdjb2xvcjp7
c2VsZi5jb2xvcn07Jz57eH08L3NwYW4+IgoKY2xhc3MgcGRmKGNvbG9yKToKCWRlZiB0ZXh0
KHNlbGYsIHgpOgoJCXJldHVybiByZiJcdGV4dGNvbG9ye3t7c2VsZi5jb2xvcn19fXt7e3h9
fX0iCgpDQyA9IGxhbWJkYSB4OiBmbXRjb2RlKGh0bWw9aHRtbCh4KSwgcGRmPXBkZih4KSkK
QkIgPSBDQygiYmx1ZSIpClJSID0gQ0MoInJlZCIpCj8+CmBgYHB5dGhvbgp7e19fXyhjb2Rl
PVRydWUsIGNyb3A9VHJ1ZSl9fQpgYGAKYGBgbWFya2Rvd24KVGV4dCB3aXRoIHtce0JCLnVw
cGVyKCJibHVlIil9XH0gYW5kIHtce1JSLmxvd2VyKCJSRUQiKX1cfS4KYGBgCiMjIyMgT3V0
cHV0IHstfQo+IFRleHQgd2l0aCB7e0JCLnVwcGVyKCJibHVlIil9fSBhbmQge3tSUi5sb3dl
cigiUkVEIil9fS4KCiMjIE1hcmtkb3duIEluY2x1ZGUKCk9mdGVuIHdoZW4gd3JpdGluZyBt
YXJrZG93biBmb3IgYGh0bWxgIGFuZCBgcGRmYCBkb2N1bWVudHMsCmNlcnRhaW4gcGFyYWdy
YXBocyBuZWVkIHRvIGJlIGR1cGxpY2F0ZWQsIG9yIHJlbmRlcmVkCndpdGggb3RoZXIgcGFy
YW1ldGVycy4gYG1hcmt5IHN1cHBvcnRzYCBpbmNsdWRpbmcKb3RoZXIgZG9jdW1lbnRzIHZp
YSBgX19fKGZpbGUpYHRoZQpvdXRwdXQgbmVlZHMgdG8gYmUgdHdlYWtlZCBhY2NvcmRpbmds
eS4KYG1hcmt5YCBzdXBwb3J0cyBmb3JtYXQgc3BlY2lmaWMgdHdlYWtpbmcgYnkgaW5qZWN0
aW5nCnJhdyBgaHRtbGAgb3IgYHRleGAgY29kZSBpbnRvIE1hcmtkb3duIHVzaW5nIGZvcm1h
dCBjb2Rlcy4KCiMgTWV0YSBEYXRhIGluIEZyb250IE1hdHRlcgoKTWV0YSBkYXRhIGlzIGFu
bm90YXRlZCBpbiB0aGUgZnJvbnQgbWF0dGVyIG9mIGEgTWFya2Rvd24gdGV4dCBkb2N1bWVu
dC4KVGhlIGZyb250IG1hdHRlciBtdXN0IHN0YXJ0IGluIHRoZSBmaXJzdCBsaW5lIHdpdGgg
YC0tLWAgYW5kIHByZWNlZGVzIGFsbApvdGhlciB0ZXh0IGJlaW5nIGZlbmNlZCBieSBgLS0t
YC4gVGhlIG1ldGEgZGF0YSBpcyBpbiBgeWFtbGAgZm9ybWF0LgpUaGUgYHlhbWxgIGJsb2Nr
IGlzIHBhcnNlZCB1c2luZyBgcHl0aG9uLXB5eWFtbGAuIEFsbCBtZXRhCmRhdGEgaXMgaW1w
b3J0ZWQgaW50byB0aGUgcHJlcHJvY2Vzc2VkIGRvY3VtZW50LgoKIyMgUGFuZG9jIEZyb250
IE1hdHRlcgoKIyMjIyBFeGFtcGxlIHstfQpgYGB5YW1sCi0tLQp0aXRsZTogTXkgRG9jdW1l
bnQKZGF0ZTogMjAyMi0wMS0wMQphdXRob3I6IC4uLgpsaW5rLWNpdGF0aW9uczogdHJ1ZQpi
aWJsaW9ncmFwaHk6IGRhdGEvbWFya3kuYmliCmhlYWRlci1pbmNsdWRlczogPgogICBcaHlw
ZXJzZXR1cHtjb2xvcmxpbmtzPWZhbHNlLAogICBhbGxib3JkZXJjb2xvcnM9ezAgMCAwfSwK
ICAgcGRmYm9yZGVyc3R5bGU9ey9TL1UvVyAxfVx9Cnhub3MtY2xldmVyZWY6IHRydWUKeG5v
cy1jYXBpdGFsaXNlOiB0cnVlCmZvbnRzaXplOiAxMXB0Ci0tLQpgYGAKVGhlIG1ldGEgZGF0
YSBmaWVsZHMKW2B0aXRsZWAsIGBkYXRlYCwgYGF1dGhvcmBdKGh0dHBzOi8vcGFuZG9jLm9y
Zy9NQU5VQUwuaHRtbCNtZXRhZGF0YS12YXJpYWJsZXMpLApbYGxpbmstY2l0YXRpb25zYF0o
aHR0cHM6Ly9wYW5kb2Mub3JnL01BTlVBTC5odG1sI290aGVyLXJlbGV2YW50LW1ldGFkYXRh
LWZpZWxkcyksCltgYmlibGlvZ3JhcGh5YF0oaHR0cHM6Ly9wYW5kb2Mub3JnL01BTlVBTC5o
dG1sI2NpdGF0aW9uLXJlbmRlcmluZykgYW5kCltgaGVhZGVyLWluY2x1ZGVzYF0oaHR0cHM6
Ly9wYW5kb2Mub3JnL01BTlVBTC5odG1sI3ZhcmlhYmxlcy1zZXQtYXV0b21hdGljYWxseSkK
YXJlIHByb2Nlc3NlZCBieSBgcGFuZG9jYCBkdXJpbmcgZG9jdW1lbnQgcmVuZGVyaW5nLiBg
Zm9udHNpemVgIGFkanVzdHMgdGhlCmZvbnQgc2l6ZSBpbiBbYGh0bWxgXShodHRwczovL3Bh
bmRvYy5vcmcvTUFOVUFMLmh0bWwjdmFyaWFibGVzLWZvci1odG1sKQphbmQgW2BwZGZgXSho
dHRwczovL3BhbmRvYy5vcmcvTUFOVUFMLmh0bWwjdmFyaWFibGVzLWZvci1sYXRleCkgZG9j
dW1lbnRzLgpUaGUgYHhub3MtY2xldmVyZWZgIGFuZCBgeG5vcy1jYXBpdGFsaXNlYApmaWVs
ZHMgYXJlIHVzZWQgYnkgdGhlIFtgcGFuZG9jLXhub3NgXShodHRwczovL2dpdGh1Yi5jb20v
dG9tZHVjay9wYW5kb2MteG5vcykKZXh0ZW5zaW9ucyBmb3IgcmVmZXJlbmNpbmcKW2ZpZ3Vy
ZXNdKGh0dHBzOi8vZ2l0aHViLmNvbS90b21kdWNrL3BhbmRvYy1maWdub3MjY3VzdG9taXph
dGlvbiksClt0YWJsZXNdKGh0dHBzOi8vZ2l0aHViLmNvbS90b21kdWNrL3BhbmRvYy10YWJs
ZW5vcyNjdXN0b21pemF0aW9uKSwKW3NlY3Rpb25zXShodHRwczovL2dpdGh1Yi5jb20vdG9t
ZHVjay9wYW5kb2Mtc2Vjbm9zI2N1c3RvbWl6YXRpb24pIGFuZApbZXF1YXRpb25zXShodHRw
czovL2dpdGh1Yi5jb20vdG9tZHVjay9wYW5kb2MtZXFub3MjY3VzdG9taXphdGlvbikuCgoj
IyBgbWFya3lgIEZvcm1hdCBGaWVsZHMKCioqRXhhbXBsZSoqCmBgYHlhbWwKLS0tCmhlYWRl
ci1pbmNsdWRlcy0tcGRmOiA+CiAgXGh5cGVyc2V0dXB7CiAgY29sb3JsaW5rcz1mYWxzZSwK
ICBhbGxib3JkZXJjb2xvcnM9ezAgMCAwfSwKICBwZGZib3JkZXJzdHlsZT17L1MvVS9XIDF9
XH0KaGVhZGVyLWluY2x1ZGVzLS1odG1sOiA+CiAgPHN0eWxlPiogeyBib3gtc2l6aW5nOiBi
b3JkZXItYm94OyB9PC9zdHlsZT4KLS0tCmBgYAoKVGhlIHBhbmRvYyBgaGVhZGVyLWluY2x1
ZGVzYCBmaWVsZCBpcyB1c2VkIGZvciBgcGRmYCBhbmQgYGh0bWxgIGRvY3VtZW50cywKdGhl
cmVmb3JlIGl0IG11c3QgY29udGFpbiBjb3JyZXNwb25kaW5nIHRleCBhbmQgYGh0bWxgIGNv
ZGUuCgpUaGUgZmllbGQgYGhlYWRlci1pbmNsdWRlc2AgZW5kaW5nIHdpdGggYC0tcGRmYCBv
ciBgLS1odG1sYApzcGVjaWZpZXMgY29ycmVzcG9uZGluZyBvcHRpb25zIGZvciB0aGUgZ2Vu
ZXJhdGlvbiBvZiBgcGRmYCBhbmQgYGh0bWxgCmRvY3VtZW50cy4gRHVyaW5nIG1ha2UsIGBt
YXJreWAgc2NhbnMgYWxsIG1ldGEgZGF0YSBmaWVsZHMsIGFuZApmaWVsZHMgd2hpY2ggZW5k
IHdpdGggYC0tcGRmYCBhbmQgYC0taHRtbGAgYXJlIHNlbGVjdGVkIGFuZCBmb3J3YXJkZWQK
dG8gYHBhbmRvY2AgYmFzZWQgb24gdGhlIGZvcm1hdCB0byBiZSByZW5kZXJlZC4KCiMgU2Np
ZW50aWZpYyBXcml0aW5nIGluIE1hcmtkb3duIHsjc2VjOnBhbm1kfQoKW01hcmtkb3duXSho
dHRwczovL3BhbmRvYy5vcmcvTUFOVUFMLmh0bWwjcGFuZG9jcy1tYXJrZG93bikgaXMgYSBt
YXJrdXAKbGFuZ3VhZ2UgZm9yIHRlY2huaWNhbCB3cml0aW5nLCB3aXRoIGVtcGhhc2lzIG9u
IHJlYWRhYmlsaXR5LiBNYXJrZG93bgpjYW4gYmUgcmVuZGVyZWQgaW4gbWFueSBmb3JtYXRz
IGluY2x1ZGluZyBgaHRtbGAgYW5kIGBwZGZgIGJ5IHVzaW5nCltgcGFuZG9jYF0oaHR0cHM6
Ly9wYW5kb2Mub3JnLykgZm9yIGV4YW1wbGUuCgpVc2luZyB2YXJpb3VzIE1hcmtkb3duIGV4
dGVuc2lvbnMgb2YgYHBhbmRvY2AgYSBzdWZmaWNpZW50IHN0cnVjdHVyZSBmb3IKd3JpdGlu
ZyBzY2llbnRpZmljIGRvY3VtZW50cyBpcyByZWZsZWN0ZWQgdXNpbmcgTWFya2Rvd24gc3lu
dGF4LgpgbWFya3lgIGJ5IGRlZmF1bHQgdXNlcyB0aGUgZm9sbG93aW5nIGBwYW5kb2NgIE1h
cmtkb3duIGV4dGVuc2lvbnMuCiogcGFyc2luZyBleHRlbnNpb25zCgkqIFthbGxfc3ltYm9s
c19lc2NhcGFibGVdKGh0dHBzOi8vcGFuZG9jLm9yZy9NQU5VQUwuaHRtbCNleHRlbnNpb24t
YWxsX3N5bWJvbHNfZXNjYXBhYmxlKQoJKiBbaW50cmF3b3JkX3VuZGVyc2NvcmVzXShodHRw
czovL3BhbmRvYy5vcmcvTUFOVUFMLmh0bWwjZXh0ZW5zaW9uLWludHJhd29yZF91bmRlcnNj
b3JlcykKCSogW2VzY2FwZWRfbGluZV9icmVha3NdKGh0dHBzOi8vcGFuZG9jLm9yZy9NQU5V
QUwuaHRtbCNleHRlbnNpb24tZXNjYXBlZF9saW5lX2JyZWFrcykKCSogW3NwYWNlX2luX2F0
eF9oZWFkZXJdKGh0dHBzOi8vcGFuZG9jLm9yZy9NQU5VQUwuaHRtbCNleHRlbnNpb24tc3Bh
Y2VfaW5fYXR4X2hlYWRlcikKCSogW2xpc3RzX3dpdGhvdXRfcHJlY2VkaW5nX2JsYW5rbGlu
ZV0oaHR0cHM6Ly9wYW5kb2Mub3JnL01BTlVBTC5odG1sI2V4dGVuc2lvbi1saXN0c193aXRo
b3V0X3ByZWNlZGluZ19ibGFua2xpbmUpCiogc3R5bGluZyBleHRlbnNpb25zCgkqIFtpbmxp
bmVfY29kZV9hdHRyaWJ1dGVzXShodHRwczovL3BhbmRvYy5vcmcvTUFOVUFMLmh0bWwjZXh0
ZW5zaW9uLWlubGluZV9jb2RlX2F0dHJpYnV0ZXMpCgkqIFtzdHJpa2VvdXRdKGh0dHBzOi8v
cGFuZG9jLm9yZy9NQU5VQUwuaHRtbCNleHRlbnNpb24tc3RyaWtlb3V0KQoqIHN0cnVjdHVy
aW5nIGV4dGVuc2lvbnMKCSogW3lhbWxfbWV0YWRhdGFfYmxvY2tdKGh0dHBzOi8vcGFuZG9j
Lm9yZy9NQU5VQUwuaHRtbCNleHRlbnNpb24teWFtbF9tZXRhZGF0YV9ibG9jaykKCSogW3Bp
cGVfdGFibGVzXShodHRwczovL3BhbmRvYy5vcmcvTUFOVUFMLmh0bWwjZXh0ZW5zaW9uLXBp
cGVfdGFibGVzKQoJKiBbbGluZV9ibG9ja3NdKGh0dHBzOi8vcGFuZG9jLm9yZy9NQU5VQUwu
aHRtbCNleHRlbnNpb24tbGluZV9ibG9ja3MpCgkqIFtpbXBsaWNpdF9maWd1cmVzXShodHRw
czovL3BhbmRvYy5vcmcvTUFOVUFMLmh0bWwjZXh0ZW5zaW9uLWltcGxpY2l0X2ZpZ3VyZXMp
CgkqIFthYmJyZXZpYXRpb25zXShodHRwczovL3BhbmRvYy5vcmcvTUFOVUFMLmh0bWwjZXh0
ZW5zaW9uLWFiYnJldmlhdGlvbnMpCgkqIFtpbmxpbmVfbm90ZXNdKGh0dHBzOi8vcGFuZG9j
Lm9yZy9NQU5VQUwuaHRtbCNleHRlbnNpb24taW5saW5lX25vdGVzKQoqIGNvZGUgaW5qZWN0
aW9uCgkqIFtyYXdfaHRtbF0oaHR0cHM6Ly9wYW5kb2Mub3JnL01BTlVBTC5odG1sI2V4dGVu
c2lvbi1yYXdfaHRtbCkKCSogW3Jhd190ZXhdKGh0dHBzOi8vcGFuZG9jLm9yZy9NQU5VQUwu
aHRtbCNleHRlbnNpb24tcmF3X3RleCkKCmBwYW5kb2NgIHN1cHBvcnRzCltlcXVhdGlvbnNd
KGh0dHBzOi8vcGFuZG9jLm9yZy9NQU5VQUwuaHRtbCNleHRlbnNpb24tdGV4X21hdGhfZG9s
bGFycykKcmVuZGVyZWQgaW5saW5lIGFuZCBzaW5nbGUtbGluZSBpbiB0ZXgtc3R5bGUgdXNp
bmcgYCQuLi4kYCBhbmQgYCQkLi4uJCRgLApbYmlibGlvZ3JhcGh5XShodHRwczovL3BhbmRv
Yy5vcmcvTUFOVUFMLmh0bWwjY2l0YXRpb25zKQp1c2luZyB0aGUgYC0tY2l0ZXByb2NgIG9w
dGlvbiwKW3NlY3Rpb24gbnVtYmVyaW5nXShodHRwczovL3BhbmRvYy5vcmcvTUFOVUFMLmh0
bWwjZXh0ZW5zaW9uLWhlYWRlcl9hdHRyaWJ1dGVzKQp1c2luZyB0aGUgYC0tbnVtYmVyLXNl
Y3Rpb25zYCBvcHRpb24gYW5kClt0YWJsZSBvZiBjb250ZW50c10oaHR0cHM6Ly9wYW5kb2Mu
b3JnL01BTlVBTC5odG1sI29wdGlvbi0tdG9jKQp1c2luZyB0aGUgYC0tdGFibGUtb2YtY29u
dGVudHNgIG9wdGlvbi4KCmBwYW5kb2NgIHN1cHBvcnRzIFtgeG5vc2BdKGh0dHBzOi8vZ2l0
aHViLmNvbS90b21kdWNrL3BhbmRvYy14bm9zKSBmaWx0ZXJzCmZvciByZWZlcmVuY2luZyBk
b2N1bWVudCBjb250ZW50IGxpa2UKW2ZpZ3VyZXNdKGh0dHBzOi8vZ2l0aHViLmNvbS90b21k
dWNrL3BhbmRvYy1maWdub3MjdXNhZ2UpLApbZXF1YXRpb25zXShodHRwczovL2dpdGh1Yi5j
b20vdG9tZHVjay9wYW5kb2MtZXFub3MjdXNhZ2UpLApbdGFibGVzXShodHRwczovL2dpdGh1
Yi5jb20vdG9tZHVjay9wYW5kb2MtdGFibGVub3MjdXNhZ2UpLApbc2VjdGlvbnNdKGh0dHBz
Oi8vZ2l0aHViLmNvbS90b21kdWNrL3BhbmRvYy1zZWNub3MjdXNhZ2UpCmJ5IHVzaW5nIHRo
ZSBgLS1maWx0ZXIgcGFuZG9jLXhub3NgIG9wdGlvbi4KYHhub3NgIGludGVncmF0ZXMgY2xl
dmVyIHJlZmVyZW5jZXMsIHdoaWNoIG1lYW5zICJGaWcuIiwgIlNlYy4iLCAiRXEuIgphbmQg
IlRhYi4iIGFyZSBhZGRlZCBhdXRvbWF0aWNhbGx5IHRvIHRoZSBjb3JyZXNwb25kaW5nIGVs
ZW1lbnQuCklmIHRoZSBwcmVmaXggaXMgdG8gYmUgb21pdHRlZCwgdGhlIHJlZmVyZW5jZSBp
cyB3cml0dGVuIGFzCmBcIUByZWY6bGFiZWxgLgoKIyMjIyBFeGFtcGxlIHstfQpgYGBtZAoj
IyBSZWZlcmVuY2VkIFNlY3Rpb24geyNzZWM6bGFiZWx9CgpUaGlzIGlzIGEgcmVmZXJlbmNl
IHRvIEBzZWM6bGFiZWwuCgohW1RoaXMgaXMgdGhlIGNhcHRpb25dKGRhdGE6aW1hZ2UvcG5n
O2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOUwpVaEVVZ0FBQUFVQUFBQUZDQVlBQUFDTmJ5YmxB
QUFBSEVsRVFWUUkxMlA0Ly84L3czOEdJQVhESUJLRTBESAp4Z2xqTkJBQU85VFhMMFk0T0h3
QUFBQUJKUlU1RXJrSmdnZz09KXsjZmlnOmxhYmVsfQoKVGhpcyBpcyBhIHJlZmVyZW5jZSB0
byBAZmlnOmxhYmVsLgoKQSAgfEIgIHxDICB8RAotLS18LS0tfC0tLXwtLS0KMDAwfDExMXw0
NDR8NTU1CjIyMnwzMzN8NjY2fDc3NwoKVGFibGU6IFRoaXMgaXMgdGhlIGNhcHRpb24geyN0
Ymw6bGFiZWx9CgpUaGlzIGlzIGEgcmVmZXJlbmNlIHRvIEB0Ymw6bGFiZWwuCgokJFxtYm94
e2V9XntcbWJveHtpfVxwaX0rMT0wJCR7I2VxOmxhYmVsfQoKVGhpcyBpcyBhIHJlZmVyZW5j
ZSB0byBAZXE6bGFiZWwuCgpUaGlzIGlzIGEgY2l0YXRpb24gW0BNdWxsZXIxOTkzXS4KYGBg
CgpUaGUgZmlsZSBgbWFya3kuYmliYCBpcyBzcGVjaWZpZWQgaW4gdGhlIG1ldGEgZGF0YSBp
biB0aGUgZnJvbnQKbWF0dGVyIG9mIHRoZSBNYXJrZG93biB0ZXh0LgoKIyMgUmVmZXJlbmNl
ZCBTZWN0aW9uIHsjc2VjOmxhYmVsfQoKVGhpcyBpcyBhIHJlZmVyZW5jZSB0byBAc2VjOmxh
YmVsLgoKIVtUaGlzIGlzIHRoZSBjYXB0aW9uXShkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZC
T1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUFVQUFBQUZDQVlBQUFDTmJ5YmxBQUFBSEVsRVFWUUkx
MlA0Ly84L3czOEdJQVhESUJLRTBESHhnbGpOQkFBTzlUWEwwWTRPSHdBQUFBQkpSVTVFcmtK
Z2dnPT0peyNmaWc6bGFiZWx9CgpUaGlzIGlzIGEgcmVmZXJlbmNlIHRvIEBmaWc6bGFiZWwu
CgpBICB8QiAgfEMgIHxECi0tLXwtLS18LS0tfC0tLQowMDB8MTExfDQ0NHw1NTUKMjIyfDMz
M3w2NjZ8Nzc3CgpUYWJsZTogVGhpcyBpcyB0aGUgY2FwdGlvbi4geyN0Ymw6bGFiZWx9CgpU
aGlzIGlzIGEgcmVmZXJlbmNlIHRvIEB0Ymw6bGFiZWwuCgokJFxtYm94e2V9XntpXHBpfSsx
PTAkJHsjZXE6bGFiZWx9CgpUaGlzIGlzIGEgcmVmZXJlbmNlIHRvIEBlcTpsYWJlbC4KClRo
aXMgaXMgYSBjaXRhdGlvbiBbQE11bGxlcjE5OTNdLgoKIyBSZWZlcmVuY2VzCg==
'''
pack_marky_bib = '''
QGFydGljbGV7TXVsbGVyMTk5MywKICAgIGF1dGhvciAgPSB7UGV0ZXIgTXVsbGVyfSwKICAg
IHRpdGxlICAgPSB7VGhlIHRpdGxlIG9mIHRoZSB3b3JrfSwKICAgIGpvdXJuYWwgPSB7VGhl
IG5hbWUgb2YgdGhlIGpvdXJuYWx9LAogICAgeWVhciAgICA9IHsxOTkzfSwKICAgIG51bWJl
ciAgPSB7Mn0sCiAgICBwYWdlcyAgID0gezIwMS0yMTN9LAogICAgbW9udGggICA9IHs3fSwK
ICAgIG5vdGUgICAgPSB7QW4gb3B0aW9uYWwgbm90ZX0sCiAgICB2b2x1bWUgID0gezR9Cn0K
'''
pack__gitignore = '''
YnVpbGQvCmh0bWwvCg==
'''

###!!!:::marky_pack_data:::!!!###
########################################################################
# SECTION IS AUTO-PACKAGED USING ./marky.py --pack --force
########################################################################

########################################################################

def _marky_front_join(y, text):
	return """---\n%s\n---\n%s""" % (
		yaml.dump(y, allow_unicode=True, default_flow_style=False),
		text
	)

def _marky_front_split(t):
	global _MARKY_EXEC_GLOBALS
	if not t.startswith("---\n"):
		return dict(), t, 0
	y = t.split("---\n")[1]
	meta_lines = len(y.split("\n")) + 2
	mark = "---\n".join(t.split("---\n")[2:])
	print("---\n" + y + "---", flush=True)
	data = dict()
	try:
		data = yaml.safe_load(y)
	except Exception as ex:
		print("# YAML ERROR", type(ex), str(ex))
		sys.exit(1)
	return data, mark, meta_lines

########################################################################

def _marky_mdtext_print(*args, sep=" ", shift="", crop=False, ret=False, code=False, pop=True,
	file=None, __marky__=False, raw=False, aux=False):
	# MD output: args, sep=" ", shift="", crop=False, ret=False
	# MD code output: code=False, pop=True
	# MD include: file, __marky__, raw, aux
	global _MARKY_EXEC_QUIET
	global _MARKY_EXEC_TEXT
	global _MARKY_EXEC_APPEND
	global _MARKY_PASTE_CODE
	if code:
		if len(_MARKY_PASTE_CODE) == 0: return ""
		code = _MARKY_PASTE_CODE[0]
		if pop: _MARKY_PASTE_CODE = _MARKY_PASTE_CODE[1:]
		return _marky_mdtext_print(code, shift=shift, crop=crop, ret=True, code=False)
	if not file is None:
		if aux:
			_MARKY_INCLUDE_LIST.append(file)
		elif raw:
			if not os.path.exists(file):
				print("# ERROR", "no such file", file)
				sys.exit(1)
			___(open(file, "r").read(), ___)
		else:
			_marky_run(_MARKY_MD_DIR + file, "/".join(file.split("/")[0:-1]), __marky__)
		return
	if len(args) == 0:
		if _MARKY_EXEC_APPEND == False: _MARKY_EXEC_TEXT.append("")
		_MARKY_EXEC_APPEND = False
	else:
		if ret: return _marky_mdtext_ret(args[0], shift, crop)
		if crop or shift != "":
			_marky_mdtext_crop(args[0], shift, crop)
			if args[-1] == _marky_mdtext_print:
				_MARKY_EXEC_APPEND = True
			return
		exec_append_new = False
		if args[-1] == _marky_mdtext_print:
			exec_append_new = True
			args = args[0:-1]
		text = sep.join([str(i) for i in args])
		if _MARKY_EXEC_APPEND and len(_MARKY_EXEC_TEXT) > 0:
			_MARKY_EXEC_TEXT[-1] += text
		else:
			_MARKY_EXEC_TEXT.append(text)
		_MARKY_EXEC_APPEND = exec_append_new
		if not _MARKY_EXEC_QUIET: print(text, end="" if _MARKY_EXEC_APPEND else "\n", flush=True)

def _marky_mdtext_crop(arg, shift, crop):
	global _MARKY_EXEC_TEXT
	global _MARKY_EXEC_APPEND
	if not type(arg) is str:
		arg = str(arg)
	arg = arg.split("\n")
	if crop:
		if len(arg[0].strip()) == 0:
			arg = arg[1:]
		if len(arg[-1].strip()) == 0:
			arg = arg[:-1]
	n = len(arg[0]) - len(arg[0].lstrip())
	for i in arg:
		if crop and len(i[0:n].lstrip()) == 0:
			i = i[n:]
		_MARKY_EXEC_TEXT.append(shift + i)

def _marky_mdtext_ret(arg, shift="", crop=True):
	if not type(arg) is str:
		arg = str(arg)
	text = []
	arg = arg.split("\n")
	if crop:
		if len(arg[0].strip()) == 0:
			arg = arg[1:]
		if len(arg[-1].strip()) == 0:
			arg = arg[:-1]
	n = len(arg[0]) - len(arg[0].lstrip())
	for i in arg:
		if crop and len(i[0:n].lstrip()) == 0:
			i = i[n:]
		text.append(shift + i)
	return "\n".join(text)

########################################################################

class _marky_fmtcall:
	def __init__(self, name, fmtc):
		self.name = name
		self.fmtc = fmtc
	def __call__(self, *args, **kwargs):
		text = "<<?html "
		f = getattr(self.fmtc.html, self.name)
		if callable(f):
			v = f(*args, **kwargs)
			if type(v) is str: text += v
		elif type(f) is str:
			text += f.format(*args, **kwargs)
		text += " html?>>"
		text += "<<?pdf "
		f = getattr(self.fmtc.pdf, self.name)
		if callable(f):
			v = f(*args, **kwargs)
			if type(v) is str: text += v
		elif type(f) is str:
			text += f.format(*args, **kwargs)
		text += " pdf?>>"
		return text

class _marky_fmtcode:
	def __init__(self, pdf=None, html=None):
		if not html is None: self.html = html
		if not pdf is None: self.pdf = pdf
	def __call__(self, *args, **kwargs):
		text = "<<?html "
		f = self.html
		if callable(f):
			v = f(*args, **kwargs)
			if type(v) is str: text += v
		elif type(f) is str:
			text += f.format(*args, **kwargs)
		text += " html?>>"
		text += "<<?pdf "
		f = self.pdf
		if callable(f):
			v = f(*args, **kwargs)
			if type(v) is str: text += v
		elif type(f) is str:
			text += f.format(*args, **kwargs)
		text += " pdf?>>"
		return text
	def __getattr__(self, name):
		return _marky_fmtcall(name, self)

########################################################################

def _marky_rebrace(t):
	t = t.replace("{{", "<<brace?")
	t = t.replace("}}", "?brace>>")
	t = t.replace("{", "{{")
	t = t.replace("}", "}}")
	t = t.replace("<<brace?", "{")
	t = t.replace("?brace>>", "}")
	return t

def _marky_code_text(t, fstring=True):
	if fstring:
		if not '"""' in t and not t.endswith('"'):
			return '___(rf"""' + _marky_rebrace(t) + '""", ___); '
		elif not "'''" in t and not t.endswith("'"):
			return "___(rf'''" + _marky_rebrace(t) + "''', ___); "
		else:
			print("# ERROR", "python code contains \"\"\" as well as '''.")
			sys.exit(1)
	else:
		if not '"""' in t and not t.endswith('"'):
			return '___(r"""' + t + '""", ___); '
		elif not "'''" in t and not t.endswith("'"):
			return "___(r'''" + t + "''', ___); "
		else:
			print("# ERROR", "python code contains \"\"\" as well as '''.")
			sys.exit(1)

def _marky_paste_code(t):
	global _MARKY_PASTE_CODE
	# ~ show_code = False
	if t.startswith("!"):
		t = t[1:]
		_MARKY_PASTE_CODE.append(t)
		# ~ show_code = True
	# ~ if show_code:
		# ~ return _marky_code_text(t, fstring=False) + t
	return t

def _marky_meta_merge(old, front):
	global _MARKY_EXEC_GLOBALS
	meta = {}
	meta.update(old)
	try:
		for k, v in front.items():
			x = k.split("--")
			if "--" in k and x[-1] in _MARKY_FORMAT:
				if k in meta:
					if type(v) is list:
						print("<!-- field link, merge yaml list %s --!>" % k)
						meta[k].extend(v)
					if type(v) is dict:
						print("<!-- field link, merge yaml dict %s --!>" % k)
						meta[k].update(v)
					if type(v) is str:
						print("<!-- field link, merge yaml str %s --!>" % k)
						meta[k] += " " + v
					else:
						print("<!-- field exists, skip yaml %s %s --!>" % (str(type(v)), k))
				else:
					print("<!-- field link, set yaml %s --!>" % k)
					meta[k] = v
			else:
				if k in meta:
					print("<!-- field exists, skip yaml %s --!>" % k)
				else:
					meta[k] = v
				k = k.replace("-", "_")
				if k in _MARKY_EXEC_GLOBALS:
					print("<!-- field exists, skip local %s --!>" % k)
				else:
					_MARKY_EXEC_GLOBALS[k] = v
	except Exception as ex:
		print("# META MERGE ERROR", type(ex), str(ex))
		sys.exit(1)
	return meta

def _marky_run(fname, inbase, run=True):
	global _MARKY_EXEC_GLOBALS
	global _MARKY_META_DICT
	global _MARKY_INCLUDE_LIST
	_MARKY_INCLUDE_LIST.append(fname)
	with open(fname, "r") as h:
		front, t, meta_lines = _marky_front_split(h.read())
	_MARKY_META_DICT = _marky_meta_merge(_MARKY_META_DICT, front)
	p = 0
	r = ""
	while True:
		p0 = t.find("<?", p)
		p1 = t.find("?>", p)
		if p0 > -1:
			if p1 < p0:
				print(t[max(0, p0-250):p0+2])
				print("# ERROR", "?> before <?")
				if "<!?" in t:
					print("# there is <!? in text, did you mean: <?!")
				sys.exit(1)
			if p0 > 0: r += _marky_code_text(t[p:p0])
			p1 = t.find("?>", p0)
			if p1 > -1:
				code = t[p0+2:p1]
				r += _marky_paste_code(code)
				p = p1 + 2
			else:
				print("# ERROR", "missing ?>")
				sys.exit(1)
		else:
			r += _marky_code_text(t[p:])
			break
	for a, b, c, count in [
		("", "<%s?", "", 1),
		("", "?%s>", "", 1),
		("", "{%s", "{", 3),
		("}", "%s}", "", 3)
	]:
		for j in reversed(range(1, count+1)):
			for i in range(3):
				X = "\\"*(i + 1)
				Y = "\\"*(i + 0)
				r = r.replace(a + (b % X)*j + c, a + (b % Y)*j + c)
	open(_MARKY_BUILD_DIR + inbase + ".py", "w").write(r)
	try:
		old_val = _MARKY_EXEC_GLOBALS["__marky__"]
		_MARKY_EXEC_GLOBALS["__marky__"] = run
		exec(r, _MARKY_EXEC_GLOBALS, None)
		_MARKY_EXEC_GLOBALS["__marky__"] = old_val
	except Exception as ex:
		_marky_print_trace(ex, meta_lines, r)
		sys.exit(1)

def _marky_print_trace(ex, mlines, code):
	print("# TRACEBACK")
	import traceback
	traceback.print_tb(ex.__traceback__)
	if hasattr(ex, "filename") and ex.filename == "<string>":
		print("# ERROR LOCATION")
		code = code.split("\n")
		print(len(code))
		for i in range(max(0, ex.lineno-5), min(len(code), ex.lineno+5)):
			print("*" if i + 1 == ex.lineno else " ", "%03d" % i, code[i])
	print("# PYTHON ERROR")
	print(type(ex), str(ex))

########################################################################

def _marky_meta_link(front, link):
	flink = {}
	try:
		for k, v in front.items():
			if "--" in k: continue
			if not k in flink:
				flink[k] = v
			else:
				print("<!-- field exists, skip yaml %s --!>" % k)
		for k, v in front.items():
			if not "--" in k: continue
			x = k.split("--")
			if x[-1] in _MARKY_FORMAT:
				if x[-1] == link:
					k = "--".join(x[0:-1])
					if k in flink:
						print("<!-- field link, merge yaml %s --!>" % k)
						if type(v) is list: flink[k].extend(v)
						if type(v) is dict: flink[k].update(v)
						if type(v) is str: flink[k] += " " + v
						else: flink[k] = v
					else:
						print("<!-- field link, set yaml %s --!>" % k)
						flink[k] = v
	except Exception as ex:
		print("# META LINK ERROR", type(ex), str(ex))
		sys.exit(1)
	return flink

def _marky_link(front, md_text, link):
	md_text = md_text.replace(".???", "." + link)
	md_text = md_text.replace(r".\???", r".???")
	md_text = md_text.replace(r".\\???", r".\???")
	lsep = 3
	len_args = len(link) + 1
	c = 0
	newtext = ""
	p = md_text.find("<<?")
	while p >= 0:
		q = md_text.find("?>>", p + lsep)
		if q > 0:
			newtext += md_text[c:p]
			expr = md_text[p+lsep:q]
			if expr.startswith(link) and expr.endswith(link):
				newtext += expr[len_args:-len_args]
			c = q + lsep
			p = md_text.find("<<?", c)
		else:
			p = md_text.find("<<?", p + lsep)
	newtext += md_text[c:]
	flink = _marky_meta_link(front, link)
	return _marky_front_join(flink, newtext)

def _marky_write_build(inbase, outdir, front, mark):
	os.makedirs(_MARKY_BUILD_DIR + outdir, exist_ok=True)
	open(_MARKY_BUILD_DIR + inbase + ".deps", "w").write("\n".join(list(set(_MARKY_INCLUDE_LIST))))
	if not mark is None:
		open(_MARKY_BUILD_DIR + inbase + ".md", "w").write(_marky_front_join(front, mark))
		for fmt in _MARKY_FORMAT:
			open(_MARKY_BUILD_DIR + inbase + "." + fmt + ".md", "w").write(_marky_link(front, mark, fmt))

	with open(_MARKY_BUILD_DIR + inbase + ".make", "w") as fhnd:
		fhnd.write(f"""# auto-generated
all_md:=$(all_md) {_MARKY_MD_DIR+inbase}.md

{_MARKY_BUILD_DIR+inbase}.md: {_MARKY_MD_DIR+inbase}.md
	mkdir -p "{_MARKY_BUILD_DIR+outdir}"
	ln -snf ../{_MARKY_DATA_DIR} {_MARKY_BUILD_DIR+_MARKY_DATA_DIR}
	./marky.py --base="{inbase}.md"

.PHONY: build/{inbase}
build/{inbase}: {_MARKY_BUILD_DIR+inbase}.md

all_build:=$(all_build) build/{inbase}
"""
		)
		if "pdf" in _MARKY_FORMAT:
			fhnd.write(f"""
{_MARKY_BUILD_DIR+inbase}.tex: {_MARKY_BUILD_DIR+inbase}.pdf.md {_MARKY_MD_DIR+inbase}.md
	mkdir -p "{_MARKY_BUILD_DIR+outdir}"
	./pandoc-run tex {_MARKY_BUILD_DIR+inbase}.pdf.md {_MARKY_BUILD_DIR+inbase}.tex

all_tex:=$(all_tex) {_MARKY_BUILD_DIR+inbase}.tex
"""
			)
		for fmt in _MARKY_FORMAT:
			fhnd.write(f"""
{_MARKY_BUILD_DIR+inbase}.{fmt}.md: {_MARKY_BUILD_DIR+inbase}.md

{fmt}/{inbase}.{fmt}: {_MARKY_BUILD_DIR+inbase}.{fmt}.md {_MARKY_MD_DIR+inbase}.md
	mkdir -p "{fmt}/{outdir}"
	./pandoc-run {fmt} {_MARKY_BUILD_DIR+inbase}.{fmt}.md {fmt}/{inbase}.{fmt}

.PHONY: {fmt}/{inbase}
{fmt}/{inbase}: {fmt}/{inbase}.{fmt}

all_{fmt}:=$(all_{fmt}) {fmt}/{inbase}.{fmt}
"""
			)

########################################################################

def _marky_pack_b64enc(x, n=72):
	x = base64.b64encode(bytes(x, "utf-8")).decode("ascii")
	return "\n".join([x[i:i+n] for i in range(0, len(x), n)])

def _marky_pack_b64dec(x):
	return base64.b64decode(bytes(x.replace("\n", ""), "ascii")).decode("utf-8")

def _marky_load_pack(i):
	return _marky_pack_b64dec(eval("pack_" + i.split("/")[-1].replace(".", "_").replace("-", "_")))

def _marky_pack_write_file(fname, force=False):
	if not os.path.exists(fname) or force:
		print("# WRITE", fname)
		open(fname, "w").write(_marky_load_pack("./" + fname))
	else:
		print("# EXISTS", fname)

def _marky_store_pack(i, ftext):
	return "pack_%s = '''\n%s\n'''\n" % (i.split("/")[-1].replace(".", "_").replace("-", "_"), _marky_pack_b64enc(ftext))

def _marky_pack_read_file(fname):
	return _marky_store_pack("./" + fname, open(fname, "r").read())

########################################################################

_MARKY_FORMAT = ["html", "pdf"]
_MARKY_BUILD_DIR = "build/"  #< WITH trailing /
_MARKY_MD_DIR = "md/"  #< WITH trailing /
_MARKY_DATA_DIR = "data" #< no trailing /
_MARKY_PACK_DIRS = [
	_MARKY_BUILD_DIR,
	_MARKY_DATA_DIR,
	_MARKY_MD_DIR
]
_MARKY_PACK_FILES = [
	"Makefile",
	"pandoc-run",
	"md/marky.md",
	"data/marky.bib",
	".gitignore"
]
_MARKY_EXEC_QUIET = False
_MARKY_EXEC_TEXT = list()
_MARKY_EXEC_APPEND = False
_MARKY_EXEC_GLOBALS = dict()
_MARKY_EXEC_GLOBALS["___"] = _marky_mdtext_print
_MARKY_EXEC_GLOBALS["fmtcode"] = _marky_fmtcode
_MARKY_EXEC_GLOBALS["__marky__"] = True
_MARKY_META_DICT = dict()
_MARKY_INCLUDE_LIST = list()
_MARKY_PASTE_CODE = list()

########################################################################

if __name__ == "__main__":

	parser = argparse.ArgumentParser(add_help=False)

	parser.add_argument("--version", action='store_true', help="version is v" + ".".join([str(i) for i in _MARKY_VERSION]))
	parser.add_argument("--help", action='store_true', help="show this help message")
	parser.add_argument("--base", type=str, default="", help="path to input markdown text")
	parser.add_argument("--init", action='store_true', help="create dirs (" + ", ".join(_MARKY_PACK_DIRS) + ") and files (" + ", ".join(_MARKY_PACK_FILES) + ")")
	parser.add_argument("--force", action='store_true', help="force overwrite of files for --init/--pack")
	parser.add_argument("--pack", action='store_true', help="pack files (" + ", ".join(_MARKY_PACK_FILES) + ") into marky.py.pack source")
	parser.add_argument("--scan", action='store_true', help="create build/*.make from md/*.md")
	parser.add_argument("--quiet", action='store_true', help="do not show Markdown output")

	# ~ args, uargs = parser.parse_known_args()
	args = parser.parse_args()

	sys.path.append("/".join(sys.argv[0].split("/")[0:-1]) + "/lib")

########################################################################

	if args.version:
		print(".".join([str(i) for i in _MARKY_VERSION]))
		sys.exit(0)
	elif args.help or len(sys.argv) == 1:
		parser.print_help()
		sys.exit(0)
	elif args.init:
		for i in _MARKY_PACK_DIRS:
			if not os.path.exists(i):
				print("# MKDIR", i)
				os.mkdir(i)
			else:
				print("# EXISTS", i)
		for i in _MARKY_PACK_FILES:
			_marky_pack_write_file(i, args.force)
		print("# USAGE")
		print("make help")
		sys.exit(0)
	elif args.pack:
		print("# PACK", ", ".join(_MARKY_PACK_FILES))
		marky_text = open(sys.argv[0], "r").read()
		head, src, tail = tuple(marky_text.split("\n###!!!:::marky_pack_data:::!!!###\n"))
		src = "".join([_marky_pack_read_file(i) for i in _MARKY_PACK_FILES])
		marky_text = "\n###!!!:::marky_pack_data:::!!!###\n".join([head, src, tail])
		open(sys.argv[0] + ".pack", "w").write(marky_text)
		if args.force:
			print("# UPDATE OF `marky` FORCED")
			print("# -----------------------")
			print("# mv marky.py.pack marky.py")
			print("# chmod 775 marky.py")
			os.replace("marky.py.pack", "marky.py")
			os.chmod("marky.py", 0o775)
		else:
			print("# MANUAL UPDATE NEEDED")
			print("# --------------------")
			print("mv marky.py.pack marky.py")
			print("chmod +x marky.py")
		sys.exit(0)
	elif args.scan:
		for i in glob.glob("md/**/*.md", recursive=True):
			inbase = i[3:-3]
			outdir = "/".join(inbase.split("/")[0:-1])
			print("# WRITE", _MARKY_BUILD_DIR + inbase + ".make")
			_marky_write_build(inbase, outdir, None, None)
		sys.exit(0)
		pass
	elif args.force:
		print("# ERROR", "--force can only be used with --pack/--init")
		sys.exit(1)
	elif args.quiet:
		_MARKY_EXEC_QUIET = True

########################################################################

	infile = _MARKY_MD_DIR + args.base
	if len(args.base) == 0:
		print("# ERROR", "empty base: use --base file.md")
		sys.exit(1)
	if not os.path.exists(infile):
		print("# ERROR", "wrong base %s: file not found %s" % (args.base, infile))
		sys.exit(1)
	inbase = args.base if not "." in args.base.split("/")[-1] else ".".join(args.base.split(".")[0:-1])
	outdir = "/".join(inbase.split("/")[0:-1])

	if os.path.exists(_MARKY_BUILD_DIR):
		_marky_run(infile, inbase)
		mark = "\n".join(_MARKY_EXEC_TEXT)
		_marky_write_build(inbase, outdir, _MARKY_META_DICT, mark)
	else:
		print("# ERROR", "no build dir: mkdir build")
		sys.sys.exit(1)
