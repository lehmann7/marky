#!/usr/bin/env python3
# -*- coding: utf-8 -*-

########################################################################
# marky Markdown Preprocessor ##########################################
########################################################################

# Quick Make Example Project
############################
#
#  > mkdir project
#  > cp /path/to/marky.py project
#  > cd project
#  > chmod +x marky.py
#  > ./marky.py --init
#  > make scan html-all pdf-all httpd
#
# Open: project/pdf/*.pdf
# Goto: http://localhost:8000/

########################################################################

import sys
import argparse
import glob
import os
import base64
import yaml

########################################################################

if not sys.version_info.major == 3 and sys.version_info.minor >= 6:
	try:
		raise ValueError("marky requires Python 3.6 or higher.")
	except Exception as ex:
		print("# ERROR", type(ex), str(ex))
		sys.exit(1)

########################################################################

_MARKY_VERSION = (0, 9)

########################################################################
# SECTION IS AUTO-PACKAGED USING ./marky.py --pack --force
########################################################################
###!!!:::marky_pack_data:::!!!###
pack_Makefile = '''
IyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMj
IyMjIyMjIyMjIyMjIyMjIyMjCgouUEhPTlk6IGhlbHAKaGVscDoKCSMgbWFya3kgREVQRU5E
RU5DSUVTCgkjIyMjIyMjIyMjIyMjIyMjIyMjIwoJIyAqIHBhbmRvYyA+PSAyLjEwCgkjICog
cGlwIGluc3RhbGwgcGFuZG9jLWZpZ25vcwoJIyAqIHBpcCBpbnN0YWxsIHBhbmRvYy1lcW5v
cwoJIyAqIHBpcCBpbnN0YWxsIHBhbmRvYy1zZWNub3MKCSMgKiBwaXAgaW5zdGFsbCBwYW5k
b2MtdGFibGVub3MKCSMgKiBwaXAgaW5zdGFsbCBwYW5kb2MteG5vcwoJIyAqIHBpcCBpbnN0
YWxsIHB5eWFtbAoJIwoJIyBBVFRFTlRJT04KCSMjIyMjIyMjIyMjCgkjIEFsbCBmaWxlcyBp
biBgYnVpbGQvKi5tZGAgYW5kIGBodG1sLyouaHRtbGAgYXJlIGF1dG8tZ2VuZXJhdGVkIQoJ
IyBVc2VyIGZpbGVzIGAqLm1kYCBoYXZlIHRvIGJlIHBsYWNlZCBpbiBgbWQvKi5tZGAhCgkj
IGBtYWtlIGNsZWFuYCBkZWxldGVzIGFsbCBmaWxlcyBpbiBgYnVpbGQvYCwgYGh0bWwvYCBh
bmQgYHBkZi9gLgoJIwoJIyBtYXJreSBVVElMUwoJIyMjIyMjIyMjIyMjIwoJIyAqIG1ha2Ug
aGVscCAgICAgICAgICAgIC0gc2hvdyB0aGlzICpIZWxwIE1lc3NhZ2UqCgkjICogbWFrZSB0
cmVlICAgICAgICAgICAgLSBzaG93IHRoZSAqUHJvamVjdCBUcmVlKgoJIyAqIG1ha2UgaHR0
cGQgICAgICAgICAgIC0gcnVuIHB5dGhvbiAtbSBodHRwZC5zZXJ2ZXIgaW4gYGh0bWwvYAoJ
IyAqIG1ha2UgY2xlYW4gICAgICAgICAgIC0gZGVsZXRlOiBgYnVpbGQvKmAsIGBodG1sLypg
LCBgcGRmLypgCgkjICogbWFrZSBzY2FuICAgICAgICAgICAgLSBidWlsZCBtYWtlIGRlcHM6
IGBidWlsZC8qLm1ha2VgCgkjICogbWFrZSBsaXN0ICAgICAgICAgICAgLSBsaXN0IGFsbCBz
Y2FubmVkIGZpbGVzIGFuZCB0YXJnZXRzCgkjCgkjIG1hcmt5IEJVSUxEIEFMTAoJIyMjIyMj
IyMjIyMjIyMjIyMKCSMgKiBtYWtlIGJ1aWxkICAgICAgICAgICAtPiBgYnVpbGQvKi57aHRt
bCxwZGZ9Lm1kYAoJIyAqIG1ha2UgdGV4ICAgICAgICAgICAgIC0+IGBidWlsZC8qLnRleGAK
CSMgKiBtYWtlIGh0bWwgICAgICAgICAgICAtPiBgaHRtbC8qLmh0bWxgCgkjICogbWFrZSBw
ZGYgICAgICAgICAgICAgLT4gYHBkZi8qLnBkZmAKCSMgKiBtYWtlIGFsbCAgICAgICAgICAg
ICAtPiBgaHRtbC8qLmh0bWxgLCBgcGRmLyoucGRmYAoJIwoJIyBtYXJreSBCVUlMRCBGSUxF
CgkjIyMjIyMjIyMjIyMjIyMjIyMKCSMgKiBtYWtlIGJ1aWxkL2ZpbGUgICAgICAtPiBgYnVp
bGQvZmlsZS57aHRtbCxwZGZ9Lm1kYAoJIyAqIG1ha2UgYnVpbGQvZmlsZS50ZXggIC0+IGBi
dWlsZC9maWxlLnRleGAKCSMgKiBtYWtlIGh0bWwvZmlsZSAgICAgICAtPiBgaHRtbC9maWxl
Lmh0bWxgCgkjICogbWFrZSBwZGYvZmlsZSAgICAgICAgLT4gYHBkZi9wZGYuaHRtbGAKCSMK
CSMgRVhBTVBMRQoJIyMjIyMjIyMjCgkjIDEuIHJ1biBgbWFrZSBzY2FuOyBtYWtlIGh0bWwv
ZmlsZS5odG1sIGh0dHBkYDoKCSMgICAgKiBnZW5lcmF0ZSBgYnVpbGQvZmlsZS5tYWtlYAoJ
IyAgICAqIHRyYW5zZm9ybSBgbWQvZmlsZS5tZGAgLT4gYGh0bWwvZmlsZS5odG1sYAoJIyAg
ICAqIHN0YXJ0IGEgcHl0aG9uIGh0dHBkIHNlcnZlciBpbiBgaHRtbGAKCSMgMi4gcnVuIGBt
YWtlIHNjYW47IG1ha2UgcGRmL2ZpbGUucGRmYAoJIyAgICAqIGdlbmVyYXRlIGBidWlsZC9m
aWxlLm1ha2VgCgkjICAgICogdHJhbnNmb3JtIGBtZC9maWxlLm1kYCAtPiBgcGRmL2ZpbGUu
cGRmYAoJIwoKLlBIT05ZOiB0cmVlCnRyZWU6CgkjIFBST0pFQ1QgVFJFRQoJIyMjIyMjIyMj
IyMjIyMKCSMgPHdvcmtpbmdfZGlyPgoJIyB8LSBtYXJreS5weSAgICAgICAgICAgIC0gbWFy
a3kgZXhlY3V0YWJsZQoJIyB8LSBNYWtlZmlsZSAgICAgICAgKCopIC0gbWFya3kgTWFrZWZp
bGUKCSMgfC0gcGFuZG9jLXJ1biAgICAgICgqKSAtIHBhbmRvYyB3cmFwcGVyCgkjIHwtIG1k
LyAgICAgICAgICAgICAoKikgLSB1c2VyIE1hcmtkb3duIGRpcgoJIyB8ICB8LSAqLm1kICAg
ICAgICAgICAgIC0gdXNlciBNYXJrZG93biB0ZXh0CgkjIHwtIGRhdGEvICAgICAgICAgICAo
KikgLSB1c2VyIGRhdGEgZGlyCgkjIHwgIHwtICouKiAgICAgICAgICAgICAgICB1c2VyIGRh
dGEgZmlsZXMKCSMgfC0gYnVpbGQvICAgICAgICAgICgqKSAtIGJ1aWxkIE1hcmtkb3duIGRp
cgoJIyB8ICB8LSAqLnB5ICAgICAgICAgKCopIC0gbWFya3kgUHl0aG9uIGNvZGUKCSMgfCAg
fC0gKi5tYWtlICAgICAgICgqKSAtIE1ha2VmaWxlIHJ1bGVzCgkjIHwgIHwtICouaHRtbC5t
ZCAgICAoKikgLSBNYXJrZG93biBmb3IgaHRtbCBmb3JtYXQKCSMgfCAgfC0gKi5wZGYubWQg
ICAgICgqKSAtIE1hcmtkb3duIGZvciBwZGYgZm9ybWF0CgkjIHwtIGh0bWwvKi5odG1sICAg
ICAoKikgLSByZW5kZXJlZCBodG1sIGRpcgoJIyB8LSBwZGYvKi5wZGYgICAgICAgKCopIC0g
cmVuZGVyZWQgcGRmIGRpcgoJIwoJIyAoKikgZGlyZWN0b3JpZXMvZmlsZXMgYXJlIGF1dG8t
Z2VuZXJhdGVkIHVzaW5nCgkjICAgIGAuL21hcmt5LnB5IC0taW5pdDsgbWFrZSBzY2FuOyBt
YWtlIGFsbMK0CgkjCgouUEhPTlk6IGNsZWFuCmNsZWFuOgoJcm0gLXJmIC4vYnVpbGQvKiAu
L2h0bWwvKiAuL3BkZi8qCgouUEhPTlk6IGh0dHBkCmh0dHBkOgoJY2QgaHRtbCAmJiBweXRo
b24gLW0gaHR0cC5zZXJ2ZXIKCi5QSE9OWTogc2NhbgpzY2FuOgoJLi9tYXJreS5weSAtLXNj
YW4KCiMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMj
IyMjIyMjIyMjIyMjIyMjIyMjIyMjIwoKYWxsX21kOj0KYWxsX2J1aWxkOj0KYWxsX2h0bWw6
PQphbGxfcGRmOj0KYWxsX3RleDo9CgotaW5jbHVkZSBidWlsZC8qLm1ha2UgYnVpbGQvKiov
Ki5tYWtlCgojIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMj
IyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMKCi5QSE9OWTogbGluawpidWlsZDogJChhbGxf
YnVpbGQpCgouUEhPTlk6IGh0bWwKaHRtbDogJChhbGxfaHRtbCkKCi5QSE9OWTogcGRmCnBk
ZjogJChhbGxfcGRmKQoKLlBIT05ZOiB0ZXgKdGV4OiAkKGFsbF90ZXgpCgouUEhPTlk6IGFs
bAphbGw6IGh0bWwgcGRmCgouUEhPTlk6IGxpc3QKbGlzdDoKCSMgbWFya3kgVEFSR0VUUwoJ
IyMjIyMjIyMjIyMjIyMjCgkjICogYG1ha2Ugc2NhbmAgLS0gRklMRVM6JChhbGxfbWQpCgkj
ICogYG1ha2UgYnVpbGRgIC0tIGBtYWtlJChhbGxfYnVpbGQpYAoJIyAqIGBtYWtlIGh0bWxg
IC0tIGBtYWtlJChhbGxfaHRtbClgCgkjICogYG1ha2UgcGRmYCAtLSBgbWFrZSQoYWxsX3Bk
ZilgCgkjICogYG1ha2UgdGV4YCAtLSBgbWFrZSQoYWxsX3RleClgCgkjCg==
'''
pack_pandoc_run = '''
IyEvYmluL2Jhc2gKClsgJCMgPT0gMCBdICYmIGVjaG8gIiIiCiMgVXNhZ2U6ICQwOiA8Rk9S
TUFUPiA8SU5GSUxFPiA8T1VURklMRT4KIyBFeGFtcGxlOgojICQwIGh0bWwgYnVpbGQvZmls
ZS5odG1sLm1kIGh0bWwvZmlsZS5odG1sCiMgJDAgcGRmIGJ1aWxkL2ZpbGUucGRmLm1kIHBk
Zi9maWxlLnBkZgoiIiIgJiYgZXhpdCAxCgpQQU5ET0M9cGFuZG9jCgpNREVYVD1cCmFsbF9z
eW1ib2xzX2VzY2FwYWJsZStcCmludHJhd29yZF91bmRlcnNjb3JlcytcCmVzY2FwZWRfbGlu
ZV9icmVha3MrXApzcGFjZV9pbl9hdHhfaGVhZGVyK1wKbGlzdHNfd2l0aG91dF9wcmVjZWRp
bmdfYmxhbmtsaW5lK1wKaW5saW5lX2NvZGVfYXR0cmlidXRlcytcCnN0cmlrZW91dCtcCnlh
bWxfbWV0YWRhdGFfYmxvY2srXApwaXBlX3RhYmxlcytcCmxpbmVfYmxvY2tzK1wKaW1wbGlj
aXRfZmlndXJlcytcCmFiYnJldmlhdGlvbnMrXAppbmxpbmVfbm90ZXMKClBET1BUPSIiIgot
LXRhYmxlLW9mLWNvbnRlbnRzCi0tbnVtYmVyLXNlY3Rpb25zCiIiIgoKaWYgWyAkMSA9PSBo
dG1sIF0gOyB0aGVuCiRQQU5ET0MgIiQyIiBcCi0tZmlsdGVyIHBhbmRvYy14bm9zIFwKLS1j
aXRlcHJvYyBcCi0tZnJvbT1tYXJrZG93bityYXdfaHRtbCskTURFWFQgXAotLXRvPWh0bWw1
IFwKLS1zZWxmLWNvbnRhaW5lZCBcCi0tb3V0cHV0PSIkMyIgXAotLXJlc291cmNlLXBhdGg9
Ii4vYnVpbGQvIiBcCiRQRE9QVApmaQoKaWYgWyAkMSA9PSBwZGYgXSA7IHRoZW4KJFBBTkRP
QyAiJDIiIFwKLS1maWx0ZXIgcGFuZG9jLXhub3MgXAotLWNpdGVwcm9jIFwKLS1mcm9tPW1h
cmtkb3duK3Jhd190ZXgrJE1ERVhUIFwKLS10bz1sYXRleCBcCi0tb3V0cHV0PSIkMyIgXAot
LXJlc291cmNlLXBhdGg9Ii4vYnVpbGQvIiBcCi0tcGRmLWVuZ2luZT14ZWxhdGV4IFwKJFBE
T1BUCmZpCgppZiBbICQxID09IHRleCBdIDsgdGhlbgokUEFORE9DICIkMiIgXAotLWZpbHRl
ciBwYW5kb2MteG5vcyBcCi0tY2l0ZXByb2MgXAotLWZyb209bWFya2Rvd24rcmF3X3RleCsk
TURFWFQgXAotLXRvPWxhdGV4IFwKLS1vdXRwdXQ9IiQzIiBcCi0tcmVzb3VyY2UtcGF0aD0i
Li9idWlsZC8iIFwKJFBET1BUCmZpCg==
'''
pack_marky_md = '''
LS0tCnRpdGxlOiAiYG1hcmt5YCBEb2N1bWVudGF0aW9uICIKdGl0bGUtLXBkZjogIi0tIGBw
ZGZgIgp0aXRsZS0taHRtbDogIi0tIGBodG1sYCIKYXV0aG9yOiBsZWhtYW5uNwpiaWJsaW9n
cmFwaHk6IGRhdGEvbWFya3kuYmliCmhlYWRlci1pbmNsdWRlcy0tcGRmOiA+CiAgIFxoeXBl
cnNldHVwe2NvbG9ybGlua3M9ZmFsc2UsCiAgIGFsbGJvcmRlcmNvbG9ycz17MCAwIDB9LAog
ICBwZGZib3JkZXJzdHlsZT17L1MvVS9XIDF9fQpoZWFkZXItaW5jbHVkZXMtLWh0bWw6ID4K
ICAgPHN0eWxlPiogeyBib3gtc2l6aW5nOiBib3JkZXItYm94OyB9PC9zdHlsZT4KeG5vcy1j
bGV2ZXJlZjogdHJ1ZQp4bm9zLWNhcGl0YWxpc2U6IHRydWUKZm9udHNpemU6IDExcHQKCi0t
LQo8Pwpjb2wgPSBmbXRjb2RlKAoJaHRtbD0iPHNwYW4gc3R5bGU9J2NvbG9yOnsxfTsnPnsw
fTwvc3Bhbj4iLAoJcGRmPXIiXHRleHRjb2xvcnt7ezF9fX17e3swfX19IgopCmRlZiB0ZXh0
X3Byb2MoY21kLCBjcm9wPVRydWUpOgoJaW1wb3J0IHN1YnByb2Nlc3MgYXMgc3AKCXRleHQg
PSAiIgoJZm9yIGkgaW4gc3AuY2hlY2tfb3V0cHV0KGNtZC5zcGxpdCgpKS5kZWNvZGUoInV0
Zi04Iikuc3BsaXQoIlxuIik6CgkJaWYgbm90IGNyb3A6CgkJCXRleHQgKz0gaSArICJcbiIK
CQllbGlmIGkuc3RhcnRzd2l0aCgiIyAiKToKCQkJdGV4dCArPSBpWzI6XSArICJcbiIKCQll
bGlmIGkgPT0gIiMiOgoJCQl0ZXh0ICs9ICJcbiIKCQllbGlmIGkuc3RhcnRzd2l0aCgiIyIp
OgoJCQl0ZXh0ICs9IGkgKyAiXG4iCglyZXR1cm4gdGV4dAp2ZXJzaW9uID0gdGV4dF9wcm9j
KCJweXRob24gbWFya3kucHkgLS12ZXJzaW9uIiwgY3JvcD1GYWxzZSkuc3RyaXAoKQo/Pgot
LS0KCj4gKipBYnN0cmFjdCoqIC0tIGBtYXJreWAgaXMgYSBwcmVwcm9jZXNzb3Igd2l0aCBh
biBlYXN5IGFuZCBpbnR1aXRpdmUKPiBzeW50YXggZm9yIGV4ZWN1dGlvbiBvZiBlbWJlZGRl
ZCB7e2NvbCgicHlob24iLCJibHVlIil9fSBjb2RlIGR1cmluZyByZW5kZXJpbmcKPiBgaHRt
bGAgYW5kIGBwZGZgIGRvY3VtZW50cyBmcm9tIE1hcmtkb3duIHRleHQuCj4gVGhpcyBkb2N1
bWVudCBpcyBjcmVhdGVkIHVzaW5nIGBtYXJreWAsIHZlcnNpb24gKnt7dmVyc2lvbn19Ki4K
PiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBwbGVhc2UgcmVmZXIgdG8gdGhlCj4gW2BtYXJreWAg
cmVwb3NpdG9yeV0oaHR0cHM6Ly9naXRodWIuY29tL2xlaG1hbm43L21hcmt5KS4KCi0tLQoK
IyBgbWFya3lgIER5bmFtaWMgTWFya2Rvd24KCmBtYXJreWAgaXMgYSBNYXJrZG93biBwcmVw
cm9jZXNzb3Igd2hpY2ggdHJhbnNmb3JtcyBhIE1hcmtkb3duIGRvY3VtZW50CnVzaW5nIHB5
dGhvbi4gYG1hcmt5YCBpbXBsZW1lbnRzIHRocmVlIHN0YXRlbWVudHMgd2l0aCBleHRyZW1l
bHkgZWFzeQphbmQgaW50dWl0aXZlIHN5bnRheCwgd2hpY2ggYXJlIGVtYmVkZGVkIGRpcmVj
dGx5IGluIHRoZSBNYXJrZG93biB0ZXh0OgoKMS4gYDxcPy4uLj9cPmA6IFB5dGhvbiBjb2Rl
IGJsb2NrLgoyLiBge1x7Li4ufVx9YDogYGZgLXN0cmluZyBvdXRwdXQgaW50byBNYXJrZG93
bi4KMy4gYF9fXygpYDogRnVuY3Rpb24gZm9yIG91dHB1dCBpbnRvIE1hcmtkb3duLgoKVXNp
bmcgYDxcPy4uLj9cPmAgYW5kIGB7XHsuLi59XH1gIHB5dGhvbiBjb2RlIGFuZCBgZmAtc3Ry
aW5nIG91dHB1dAphcmUgZW1iZWRkZWQgZGlyZWN0bHkgaW5zaWRlIHRoZSBNYXJrZG93biB0
ZXh0LgoKIyMjIyBFeGFtcGxlIDE6IElubGluZSBGb3JtYXR0ZWQgT3VwdXQgey19Cjw/IQp4
ID0gMTIzLjQ1CkxFRyA9IGxhbWJkYSB2LCB3OiAibGVzc2VyIiBpZiB2IDwgdyBlbHNlICJl
cXVhbCBvciBncmVhdGVyIgo/PgpgYGBwaHAKPFw/e3tfX18oY29kZT1UcnVlKX19P1w+CmBg
YApgYGBtYXJrZG93bgpUaGlzIGlzIGFuIGV4YW1wbGUgd2l0aCBhIHZhbHVlIHg9e1x7eDou
M2Z9XH0sCndoaWNoIGlzIHtce0xFRyh4LCAxMDApfVx9IHRoYW4gMTAwLgpgYGAKIyMjIyBS
dW4gYW5kIE91dHB1dCB7LX0KYGBgbWFya2Rvd24KVGhpcyBpcyBhbiBleGFtcGxlIHdpdGgg
YSB2YWx1ZSB4PXt7eDouM2Z9fSwKd2hpY2ggaXMge3tMRUcoeCwgMTAwKX19IHRoYW4gMTAw
LgpgYGAKClVzaW5nIHRoZSBgX19fKClgIGZ1bmN0aW9uIHRleHQgaXMgZ2VuZXJhdGVkIGZy
b20gcHl0aG9uCmFsZ29yaXRobXMgYW5kIGR5bmFtaWNhbGx5IGluc2VydGVkIGludG8gdGhl
IHJlc3VsdGluZyBNYXJrZG93bi4KCiMjIyMgRXhhbXBsZSAyOiBEeW5hbWljIFRleHQgZnJv
bSBDb2RlIHstfQpgYGBwaHAKPFw/e3tfX18oY29kZT1UcnVlKX19P1w+CmBgYAojIyMjIFJ1
biBhbmQgT3V0cHV0IHstfQpgYGBtYXJrZG93bgo8PyEKZm9yIGkgaW4gcmFuZ2UoMyk6Cglf
X18oZiJ7aSsxfS4gYGkgPSB7aX1gIiwgImFiY2RlZmdoaWoiWzA6aSozXSkKPz4KYGBgCgpQ
eXRob24gY29kZSwgd2hpY2ggaXMgZW1iZWRkZWQgaW4gdGhlIE1hcmtkb3duIHRleHQKZm9s
bG93cyB0aGUgUHl0aG9uIGluZGVudGF0aW9uIHN0YW5kYXJkLiBNYXJrZG93bgp0ZXh0IGlz
IGludGVncmF0ZWQgaW50byB0aGUgcHJvZ3JhbSBmbG93IHdoZW4gYmVpbmcKaW5zZXJ0ZWQg
aW4gcHl0aG9uIHN0YXRlbWVudHMgYWNjb3JkaW5nbHkuCgojIyMjIEV4YW1wbGUgMzogVGV4
dCBpbiBQcm9ncmFtIEZsb3cgey19CmBgYHBocApUaGlzIGlzIHRoZSBmaXJzdCBsaW5lLgo8
XD8KaWYgRmFsc2U6Cgk/XD5UaGlzIExpbmUgaXMgKipub3QqKiBzaG93bi48XD8KZWxzZToK
CT9cPlRoaXMgTGluZSBpcyBzaG93bi48XD8KP1w+ClRoaXMgaXMgdGhlIGxhc3QgbGluZS4K
YGBgCiMjIyMgUnVuIGFuZCBPdXRwdXQgey19CmBgYG1hcmtkb3duClRoaXMgaXMgdGhlIGZp
cnN0IGxpbmUuCjw/CmlmIEZhbHNlOgoJPz5UaGlzIExpbmUgaXMgKipub3QqKiBzaG93bi48
PwplbHNlOgoJPz5UaGlzIExpbmUgaXMgc2hvd24uPD8KPz4KVGhpcyBpcyB0aGUgbGFzdCBs
aW5lLgpgYGAKCiMjIEEgRmlyc3QgYG1hcmt5YCBFeGFtcGxlCgpgbWFya3lgIGNvbWJpbmVz
IHB5dGhvbiBleHByZXNzaW9ucyB3aXRoIE1hcmtkb3duLCBmb3IgZHluYW1pYyBjcmVhdGlv
bgpvZiB0ZXh0LiBJbiB0aGUgZm9sbG93aW5nLCB0d28gaW4tZGVwdGggZXhhbXBsZXMgb2Yg
YG1hcmt5YCBhcmUgcHJlc2VudGVkLgoKIyMjIyBFeGFtcGxlIDE6IGBtYXJreWAgU3ludGF4
IHstfQo8PyEKeCA9IDEyMwp5ID0gNDUKZGVmIGFiY19mdW4odiwgYSwgYiwgYyk6CglyZXR1
cm4gYSBpZiB2IDwgMTAwIGVsc2UgYiBpZiB2ID09IDEwMCBlbHNlIGMKTEVHID0gbGFtYmRh
IHY6IGFiY19mdW4odiwgImxlc3NlciIsICJlcXVhbCIsICJncmVhdGVyIikKPz4KYGBgcGhw
CjxcP3t7X19fKGNvZGU9VHJ1ZSl9fT9cPgpgYGAKYGBgbWFya2Rvd24KVGhpcyBpcyBhbiBl
eGFtcGxlIHdpdGggYSB2YWx1ZSB4PXtce3h9XH0sIHdoaWNoIGlzCntce0xFRyh4KX1cfSB0
aGFuIDEwMC4gVGhlcmUgaXMgYW5vdGhlciB2YWx1ZSB5PXtce3l9XH0sCndoaWNoIGlzIHtc
e0xFRyh5KX1cfSB0aGFuIDEwMC4gQm90aCB2YWx1ZXMgdG9nZXRoZXIKYXJlIHgreT17XHt4
K3l9XH0uCmBgYAojIyMjIFJ1biBhbmQgT3V0cHV0IHstfQpgYGBtYXJrZG93bgpUaGlzIGlz
IGFuIGV4YW1wbGUgd2l0aCBhIHZhbHVlIHg9e3t4fX0sIHdoaWNoIGlzCnt7TEVHKHgpfX0g
dGhhbiAxMDAuIFRoZXJlIGlzIGFub3RoZXIgdmFsdWUgeT17e3l9fSwKd2hpY2ggaXMge3tM
RUcoeSl9fSB0aGFuIDEwMC4gQm90aCB2YWx1ZXMgdG9nZXRoZXIKYXJlIHgreT17e3greX19
LgpgYGAKClRoZSBmb2xsb3dpbmcgZXhhbXBsZSBjb250YWlucyBtZXRhIGRhdGEgaW4gdGhl
IGZyb250IG1hdHRlcgphbmQgIGNhbiBiZSByZW5kZXJlZCBpbnRvIGBwZGZgIGFuZCBgaHRt
bGAgYnkganVzdCBjYWxsaW5nCmBtYWtlIHBkZi9maWxlYCBvciBgbWFrZSBodG1sL2ZpbGVg
LgoKIyMjIyBFeGFtcGxlIDI6IGBtZC9maWxlLm1kYCB7LX0KYGBgcGhwCi0tLQp0aXRsZTog
QW4gRXhhbXBsZQotLS0KPFw/e3tfX18oY29kZT1UcnVlKX19P1w+CmBgYAojIyMjIE91dHB1
dCBgYnVpbGQvZmlsZS5tZGAgey19CmBgYG1hcmtkb3duCi0tLQp0aXRsZTogQW4gRXhhbXBs
ZQotLS0KPD8hCmRlZiBjYXBfZmlyc3QoaSk6CglyZXR1cm4gIiAiLmpvaW4oW2lbMF0udXBw
ZXIoKSArIGlbMTpdIGZvciBpIGluIGkuc3BsaXQoKV0pCmZvciBpIGluIFsidmVyeSIsICJu
b3Qgc28iXToKCT8+Cioqe3tjYXBfZmlyc3QoaSl9fSBTZWN0aW9uKioKClRvIGRheSBpcyBh
IHt7aX19IHZlcnkgbmljZSBkYXkuClRoZSBzdW4gaXMgc2hpbmluZyB7e2l9fSBicmlnaHQg
YW5kCnRoZSBiaXJkcyBhcmUgc2luZ2luZyB7e2l9fSBsb3VkIGFuZApmbHkge3tpfX0gaGln
aCBpbiB0aGUge3tpfX0gYmx1ZSBza3kuCgk8Pwo/PgpgYGAKCiMjIEhvdyBkb2VzIGBtYXJr
eWAgd29yayBpbnRlcm5hbGx5PwoKYG1hcmt5YCB1c2VzIGFuIGV4dHJlbWVseSBzaW1wbGUg
bWVjaGFuaXNtIGZvciBnZW5lcmF0aW5nIGEgcHl0aG9uIHByb2dyYW1tCmZyb20gdGhlIE1h
cmtkb3duIHRleHQuIFVzaW5nIHRoZSBgPFw/Li4uP1w+YCBhbmQgYHtcey4uLn1cfWAgc3Rh
dGVtZW50LApQeXRob24gY29kZSBpcyBlbWJlZGRlZCBpbnRvIHRoZSBNYXJrZG93biB0ZXh0
IGFuZCB0cmFuc2xhdGVkIGludG8gYSBzZXJpZXMKb2YgY2FsbHMgdG8gdGhlIGBfX18oKWAg
ZnVuY3Rpb24gdXNpbmcgYGZgLXN0cmluZ3MgYXMgYXJndW1lbnRzLCB3aGVyZQpweXRob24g
dmFyaWFibGVzIGFyZSByZWZlcmVuY2VkLiBUaGlzIHJlc3VsdHMgaW50byBhIHB5dGhvbiBw
cm9ncmFtCndoaWNoIGNhbiBnZW5lcmF0ZSBNYXJrZG93biB0ZXh0IGFsZ29yaXRobWljYWxs
eS4KCiMjIyMgRXhhbXBsZTogYG1kL2ZpbGUubWRgIHstfQpgYGBwaHAKKiBUaGlzIGlzIHtm
aXJzdH0uIDxcPwp4ID0gMSAjIHRoaXMgaXMgY29kZQpmb3IgaSBpbiByYW5nZSgzKToKCWlm
IHg6CgkJP1w+Cntce2krMX1cfS4gVGhlIHZhbHVlIGlzIHtce1x7eH1cfVx9Lgo8XD8KCWVs
c2U6CgkJP1w+e1x7aSsxfVx9LiBUaGUgdmFsdWUgaXMgemVyby4KPFw/Cgl4ID0gMAo/XD4q
IFRoaXMgaXMgbGFzdC4KYGBgClRoZSBmaWxlIHByb2R1Y2VzIHRoZSBmb2xsb3dpbmcgTWFy
a2Rvd24gb3V0cHV0LgoKIyMjIyBPdXRwdXQ6IE1hcmtkb3duIHstfQpgYGBiYXNoCiogVGhp
cyBpcyB7Zmlyc3R9LiA8Pwp4ID0gMSAjIHRoaXMgaXMgY29kZQpmb3IgaSBpbiByYW5nZSgz
KToKCWlmIHg6CgkJPz4Ke3tpKzF9fS4gVGhlIHZhbHVlIGlzIHt7e3h9fX0uCjw/CgllbHNl
OgoJCT8+e3tpKzF9fS4gVGhlIHZhbHVlIGlzIHplcm8uCjw/Cgl4ID0gMAo/PiogVGhpcyBp
cyBsYXN0LgpgYGAKCmBtYXJreWAgdHJhbnNmb3JtcyB0aGUgTWFya2Rvd24gaW50byBQeXRo
b24gc291cmNlIGNvZGUuCkV4ZWN1dGlvbiBvZiB0aGUgUHl0aG9uIHNvdXJjZSBjb2RlIHlp
ZWxkcyB0aGUgbmV3IE1hcmtkb3duIHRleHQuCgojIyMjIE91dHB1dDogYGJ1aWxkL2ZpbGUu
cHlgIHstfQpgYGBweXRob24KX19fKHJmIiIiKiBUaGlzIGlzIHtce2ZpcnN0fVx9LiAiIiIs
IF9fXyk7CnggPSAxICMgdGhpcyBpcyBjb2RlCmZvciBpIGluIHJhbmdlKDMpOgoJaWYgeDoK
CQlfX18ocmYiIiIKe2krMX0uIFRoZSB2YWx1ZSBpcyB7XHtce3h9XH1cfS4KIiIiLCBfX18p
OwoJZWxzZToKCQlfX18ocmYiIiJ7aSsxfS4gVGhlIHZhbHVlIGlzIHplcm8uCiIiIiwgX19f
KTsKCXggPSAwCl9fXyhyZiIiIiogVGhpcyBpcyBsYXN0LgoiIiIsIF9fXyk7CmBgYAoKIyBR
dWljayBTdGFydAoKIyMgYG1hcmt5YCBEZXBlbmRlbmNpZXMKCmBtYXJreWAgZGVwZW5kcyBv
biBgcGFuZG9jYCBhbmQgYHB5eWFtbGAuIGBwYW5kb2NgIGlzIHVzZWQgZm9yIHJlbmRlcmlu
Zwp0aGUgTWFya2Rvd24gaW50byBgaHRtbGAgYW5kIGBwZGZgLiBgbWFya3lgIHVzZXMKW3Bh
bmRvY10oaHR0cHM6Ly93d3cucGFuZG9jLm9yZy8pIGZvciByZW5kZXJpbmcgYGh0bWxgIGFu
ZCBgcGRmYC4KYHBhbmRvYz49Mi4xMGAgcmVsZWFzZXMgY2FuIGJlIGZvdW5kCltoZXJlXSho
dHRwczovL2dpdGh1Yi5jb20vamdtL3BhbmRvYy9yZWxlYXNlcykuClRoZSBvdGhlciBwYWNr
YWdlcyBjYW4gYmUgaW5zdGFsbGVkIHdpdGggYHBpcGAuCgpgYGBiYXNoCnBpcCBpbnN0YWxs
IHBhbmRvYy1maWdub3MKcGlwIGluc3RhbGwgcGFuZG9jLWVxbm9zCnBpcCBpbnN0YWxsIHBh
bmRvYy1zZWNub3MKcGlwIGluc3RhbGwgcGFuZG9jLXRhYmxlbm9zCnBpcCBpbnN0YWxsIHBh
bmRvYy14bm9zCnBpcCBpbnN0YWxsIHB5eWFtbApgYGAKCiMjIGBtYXJreWAgV29ya2Zsb3cK
CldvcmtmbG93IGZvciBjcmVhdGluZyBgaHRtbGAgb3IgYHBkZmAgdXNpbmcgYG1hcmt5YCBi
eQppbnZvY2F0aW9uIG9mIGBtYWtlIHNjYW5gIGFuZCBgbWFrZSBhbGxgLgoKKm1ha2UqfDEu
ICp3cml0ZSogIHwgIHwyLiAqYnVpbGQqICAgICAgICAgIHwgIHwzLiAqcmVuZGVyKgotLS0t
LS18LS0tLS0tLS0tLS0tfC0tfC0tLS0tLS0tLS0tLS0tLS0tLS0tfC0tfC0tLS0tLS0tLS0t
LS0tLS0KYHBkZmAgfCAgICAgICAgICAgIHwgIHxgYnVpbGQvZmlsZS5odG1sLm1kYHwtPnxg
aHRtbC9maWxlLmh0bWxgCmAtYCAgIHxgbWQvZmlsZS5tZGB8LT58ICAgICAgICAgICAgICAg
ICAgICB8ICB8CmBoZm1sYHwgICAgICAgICAgICB8ICB8YGJ1aWxkL2ZpbGUucGRmLm1kYCB8
LT58YHBkZi9maWxlLnBkZmAKCjEuICoqd3JpdGUqKjogdXNlciB3cml0ZXMgYSBNYXJrZG93
biB0ZXh0IGZpbGUgYW5kIHBsYWNlcyBpdCBpbiBgbWQvKi5tZGAKZGlyZWN0b3J5IHdpdGgg
dGhlIGV4dGVuc2lvbiBgLm1kYC4KMi4gKipidWlsZCoqOiBgbWFya3lgIHRyYW5zZm9ybXMg
dGhlIGZpbGVzIGluIGBtZC8qLm1kYCBpbnRvIHJlZ3VsYXIgTWFya2Rvd24gdGV4dAphbmQg
cGxhY2VzIHRoZSB0cmFuc2Zvcm1lZCBmaWxlcyBpbiBgYnVpbGQvYC4KMy4gKipyZW5kZXIq
KjogdGhlIHJlZ3VsYXIgTWFya2Rvd24gdGV4dCBpbiB0aGUgZmlsZXMgYGJ1aWxkLyoubWRg
IGlzIHJlbmRlcmVkIGludG8KYGh0bWxgIGFuZCBgcGRmYCB1c2luZyBgcGFuZG9jYC4KClRo
ZSB0aHJlZSBzdGVwcyBhcmUgaW1wbGVtZW50ZWQgaW4gYSBNYWtlZmlsZS4KCiMjIERvd25s
b2FkIGFuZCBJbml0aWFsaXplCgpgbWFya3lgIGlzIHN1cHBsaWVkIGFzIGEgc2luZ2xlLWZp
bGUgc2NyaXB0IHdoaWNoIGF1dG9tYXRpY2FsbHkKc2V0cyB1cCB0aGUgcHJvamVjdCBzdHJ1
Y3R1cmUgY29udGFpbmluZyBhbGwgc2NyaXB0cwpyZXF1aXJlZCBmb3IgcHJvY2Vzc2luZyBh
bmQgcmVuZGVyaW5nIE1hcmtkb3duLgoKRm9yIGV4YW1wbGUsIGRvd25sb2FkIGBtYXJreWAg
ZnJvbSBnaXRodWIuCmBgYGJhc2gKZ2l0IGNsb25lIGh0dHBzOi8vbGVobWFubjcuZ2l0aHVi
LmNvbS9tYXJreS5naXQKY2QgbWFya3kKYGBgCgpBZnRlciBkb3dubG9hZCwgdGhlIGBtYXJr
eWAgZW52aXJvbm1lbnQgaXMgaW5pdGlhbGl6ZWQgdXNpbmcgYG1hcmt5YC4KYGBgYmFzaAou
L21hcmt5LnB5IC0taW5pdAojIG1rZGlyIGJ1aWxkLwojIG1rZGlyIGRhdGEKIyBta2RpciBt
ZC8KIyBXUklURSBNYWtlZmlsZQojIFdSSVRFIHBhbmRvYy1ydW4KIyBXUklURSBtZC9tYXJr
eS5tZAojIFdSSVRFIC5naXRpZ25vcmUKIyBVU0FHRQptYWtlIGhlbHAKYGBgCgojIyBgbWFy
a3lgIEVudmlyb25tZW50CgpEdXJpbmcgaW5pdGlhbGl6YXRpb24sIGBtYXJreWAgY3JlYXRl
cyBkaXJlY3RvcmllcyBhbmQgZmlsZXMuCkFmdGVyIGluaXRpYWxpemF0aW9uLCB0aGUgZm9s
bG93aW5nIHN0cnVjdHVyZSBpcyBhdXRvLWdlbmVyYXRlZAppbiB0aGUgcHJvamVjdCBkaXJl
Y3RvcnkuIGBtYXJreWAgc2hvd3MgdGhlIHByb2plY3Qgc3RydWN0dXJlCndoZW4gaW52b2tp
bmcgYG1ha2UgdHJlZWAuCmBgYGJhc2gKPD8KX19fKHRleHRfcHJvYygibWFrZSB0cmVlIikp
Cj8+CmBgYAoKVGhlIHNjcmlwdCBgcGFuZG9jLXJ1bmAgY2FuIGJlIGFkanVzdGVkIGluIGNh
c2Ugc3BlY2lmaWMKYHBhbmRvY2Agb3B0aW9ucyBhcmUgcmVxdWlyZWQgZm9yIHJlbmRlcmlu
ZyB0aGUgYGh0bWxgIGFuZCBgcGRmYCBkb2N1bWVudHMuCgojIyBEb2N1bWVudCBSZW5kZXJp
bmcKCkJ5IGludm9raW5nIGBtYWtlIGFsbGAgYWxsIGZpbGVzIGBtZC8qLm1kYCBhcmUgdHJh
bnNmb3JtZWQKaW50byBjb3JyZXNwb25kaW5nIGBodG1sLyouaHRtbGAgYW5kIGBwZGYvKi5w
ZGZgIGZpbGVzLiBCeQppbnZva2luZyBgbWFrZSBodHRwZGAgYSBweXRob24gd2ViIHNlcnZl
ciBpcyBzdGFydGVkIGluIGBodG1sL2AuCgpBbGwgdXNlci1nZW5lcmF0ZWQgTWFya2Rvd24g
Y29udGVudCBnb2VzIGludG8gYG1kLypgIHVzZXItZ2VuZXJhdGVkCmRhdGEgZmlsZXMgZ28g
aW50byBgZGF0YS8qYC4KCioqQVRURU5USU9OOioqIFRoZSBmaWxlcyBpbiB0aGUgZGlyZWN0
b3JpZXMgYGJ1aWxkLypgIGFyZQoqKmF1dG8tZ2VuZXJhdGVkKiouIEFsbCB1c2VyIGZpbGVz
IGhhdmUgdG8gYmUgcGxhY2VkIGluc2lkZSB0aGUKZGlyZWN0b3J5IGBtZC8qYC4gSW52b2tp
bmcgYG1ha2UgY2xlYW5gIHdpbGwgKipkZWxldGUgYWxsIGZpbGVzKioKaW4gYGh0bWwvYCwg
YGJ1aWxkL2AgYW5kIGBwZGYvYC4KCiMjIEludGVncmF0ZWQgRG9jdW1lbnRhdGlvbgoKYG1h
cmt5YCBoYXMgYW4gaW50ZWdyYXRlZCBlbnZpcm9ubWVudC4gVXNpbmcgYG1ha2UgaGVscGAg
ZGlzcGxheXMKYSBzaG9ydCBpbmZvIGFib3V0IHRoZSBgbWFya3lgIGRlcGVuZGVuY2llcywg
bWFrZSB0YXJnZXRzIGFuZApleGFtcGxlcy4KYGBgYmFzaAo8PwpfX18odGV4dF9wcm9jKCJt
YWtlIGhlbHAiKSkKPz4KYGBgCgojIGBtYXJreWAgRmVhdHVyZXMKCkluIG9yZGVyIHRvIHF1
aWNrIHN0YXJ0IGEgbmV3IE1hcmtkb3duIHByb2plY3QsIGp1c3QgbGluayB0aGUKYG1hcmt5
LnB5YCBleGVjdXRhYmxlIGluIHRoZSBwcm9qZWN0IGRpciBhbmQgaW5pdGlhbGl6ZQp0aGUg
ZW52aXJvbm1lbnQuCmBgYGJhc2gKbWtkaXIgbXlfcHJvamVjdApjZCBteV9wcm9qZWN0Ci4v
bWFya3kucHkgLS1pbml0CmBgYAoKTm93IGBtYXJreWAgaXMgcmVhZHkgZm9yIG9wZXJhdGlv
bi4gUGxhY2UgYSBuZXcgZmlsZSBpbiBgbWQvZmlsZS5tZGAKYW5kIHJ1biB0aGUgZm9sbG93
aW5nIGNvbW1hbmRzLgpgYGBiYXNoCnRvdWNoIG1kL2ZpbGUubWQKbWFrZSBzY2FuCiMgV1JJ
VEUgYnVpbGQvZmlsZS5tYWtlCmBgYAoKYG1hcmt5YCBkaXNjb3ZlcnMgdGhlIG5ldyBkb2N1
bWVudCB3aGVuIGludm9raW5nIGBtYWtlIHNjYW5gLgpgbWFya3lgIGFsc28gcmVuZGVycyBg
aHRtbGAgYW5kIGBwZGZgIHVzaW5nIG1ha2UgdGFyZ2V0cy4KYGBgYmFzaAptYWtlIGh0bWwv
ZmlsZQptYWtlIHBkZi9maWxlCmBgYAoKIyMgTWV0YSBEYXRhIGluIEZyb250IE1hdHRlcgoK
SWYgZG9jdW1lbnQgc3RhcnRzIHdpdGggYC0tLWAsIHlhbWwgaXMgdXNlZCB0byBwYXJzZQp0
aGUgZnJvbnQgbWF0dGVyIGJsb2NrIGRlbGltaXRlZCBieSBgLS0tYC4KQWxsIG1ldGEgZGF0
YSBrZXlzIHdpbGwgYmUgZXhwb3NlZCBpbnRvIHRoZSBweXRob24gc2NvcGUgYXMgYSBsb2Nh
bAp2YXJpYWJsZSwgdW5sZXNzIHRoZSB2YXJpYWJsZSBhbHJlYWR5IGV4aXN0cy4KCiMjIyMg
RXhhbXBsZSB7LX0KYGBgbWFya2Rvd24KLS0tCnRpdGxlOiAie3t0aXRsZX19IgphdXRob3I6
IC4uLgpkYXRlOiAyMDIyLTAxLTAxCi0tLQpUaGUgdGl0bGUgb2YgdGhpcyBkb2N1bWVudCBp
cyB7XHt0aXRsZX1cfS4KYGBgCiMjIyMgT3V0cHV0IHstfQpgYGBtYXJrZG93bgotLS0KdGl0
bGU6ICJ7e3RpdGxlfX0iCmF1dGhvcjogLi4uCmRhdGU6IDIwMjItMDEtMDEKLS0tClRoZSB0
aXRsZSBvZiB0aGlzIGRvY3VtZW50IGlzIHt7dGl0bGV9fS4KYGBgCgojIyBJbmxpbmUgRm9y
bWF0dGVkIE91dHB1dAoKUHl0aG9uIGxvY2FsIHZhcmlhYmxlcyBhbmQgdmFyaWFibGVzIGZy
b20gbWV0YSBkYXRhIGluIGZyb250IG1hdHRlcgpjYW4gYmUgYWNjZXNzZWQgZGlyZXRseSBm
cm9tIHRoZSBtYXJrZG93biB0ZXh0LgpUaGUgYHtcey4uLn1cfWAgc3RhdGVtZW50IHVzZXMg
c3ludGF4IHNpbWlsYXIgdG8gcHl0aG9uIGBmYC1zdHJpbmdzIGZvcgpmb3JtYXR0ZWQgb3V0
cHV0IG9mIHZhcmlhYmxlcyBhbmQgcmVzdWx0cyBvZiBleHByZXNzaW9ucyBpbnRvIE1hcmtk
b3duCnRleHQuIFRoZSBgbWFya3lgIG9wZXJhdG9yIGB7XHs8ZXhwcmVzc2lvbj5bOjxmb3Jt
YXQ+XX1cfWAgdXNlcyB0aGUKc3ludGF4IG9mIFtgZmAtc3RyaW5nc10oaHR0cHM6Ly9kb2Nz
LnB5dGhvbi5vcmcvMy9yZWZlcmVuY2UvbGV4aWNhbF9hbmFseXNpcy5odG1sI2Ytc3RyaW5n
cykuCgojIyMjIEV4YW1wbGUgMSB7LX0KYGBgYmFzaApUaXRsZSBvZiB0aGlzIGRvY3VtZW50
IGlzIHtce3RpdGxlfVx9IGFuZCBmb250IHNpemUgaXMge1x7Zm9udHNpemV9XH0uCmB4YCBp
cyB7XHt4fVx9IGFuZCB7XHsiLCIuam9pbihbc3RyKGkpIGZvciBpIGluIHJhbmdlKHgtMTAs
eCldKX1cfS4KYGBgCiMjIyMgT3V0cHV0IHstfQo+IFRpdGxlIG9mIHRoaXMgZG9jdW1lbnQg
aXMge3t0aXRsZX19IGFuZCBmb250IHNpemUgaXMge3tmb250c2l6ZX19Lgo+IGB4YCBpcyB7
e3h9fSBhbmQge3siLCIuam9pbihbc3RyKGkpIGZvciBpIGluIHJhbmdlKHgtMTAseCldKX19
LgoKIyMjIyBFeGFtcGxlIDIgey19Cjw/IQp4ID0gaW50KDEpCnkgPSBmbG9hdCgyLjMpCnog
PSAwCmEgPSBbMSwgMiwgM10KYiA9ICg0LCA1KQo/PgpgYGBweXRob24Ke3tfX18oY29kZT1U
cnVlLCBjcm9wPVRydWUpfX0KYGBgCmBgYG1hcmtkb3duClRoaXMgaXMgYSBwYXJhZ3JhcGgg
YW5kIHggaXMge1x7eDowM2R9XH0gYW5kIHkgaXMge1x7eTouMmZ9XH0uCk90aGVyIGNvbnRl
bnQgaXM6IGEgPSB7XHthfVx9LCBiID0ge1x7Yn1cfS4KYGBgCiMjIyMgT3V0cHV0IHstfQo+
IFRoaXMgaXMgYSBwYXJhZ3JhcGggYW5kIHggaXMge3t4OjAzZH19IGFuZCB5IGlzIHt7eTou
MmZ9fS4KPiBPdGhlciBjb250ZW50IGlzOiBhID0ge3thfX0sIGIgPSB7e2J9fS4KCiMjIEVt
YmVkZGluZyBQeXRob24gQ29kZQoKUHl0aG9uIGNvZGUgYmxvY2tzIGFyZSBlbWJlZGRlZCBp
bnRvIE1hcmtkb3duIHVzaW5nIGA8XD8uLi4/XD5gIGFuZCBge1x7Li4ufVx9YC4KQWxsIGNv
ZGUgYmxvY2tzIHNwYW4gb25lIGxhcmdlIHNjb3BlIHNoYXJpbmcgZnVuY3Rpb25zIGFuZCBs
b2NhbAp2YXJpYWJsZXMuIE1ldGEgZGF0YSBpcyBpbXBvcnRlZCBmcm9tIE1hcmtkb3duIGZy
b250IG1hdHRlciBhcyBsb2NhbAp2YXJpYWJsZXMgaW4gdGhlIHB5dGhvbiBzY29wZS4gVGhl
IGBpbXBvcnRgIHN0YXRlbWVudCBjYW4gYmUgdXNlZCBpbgpweXRob24gY29kZSBpbiBvcmRl
ciB0byBhY2Nlc3MgaW5zdGFsbGVkIHB5dGhvbiBwYWNrYWdlcyBhcyB1c3VhbC4KCiMjIyBW
aXNpYmxlIENvZGUKClVzaW5nIGA8XD8hLi4uP1w+YCBjb2RlIGlzIGV4ZWN1dGVkIGFuZCBz
dG9yZWQuClRoZSB0ZXh0IG9mIHRoZSBsYXN0IGA8XD8hLi4uP1w+YCBibG9jayBjYW4gYmUK
YWNjZXNzZWQgYW5kIHBsYWNlZCB2aWEgYHtce19fXyhjb2RlPVRydWUpfVx9YC4KCiMjIyMg
RXhhbXBsZSB7LX0KYGBgcHl0aG9uCjxcPyEKeCA9IDQyICMgdmlzaWJsZSBjb2RlCnByaW50
KCJIZWxsbyBjb25zb2xlISIpCj9cPgp7XHtfX18oY29kZT1UcnVlKX1cfQpgYGAKCiMjIyMg
UnVuIGFuZCBPdXRwdXQgey19Cjw/IQp4ID0gNDIgIyB2aXNpYmxlIGNvZGUKcHJpbnQoIkhl
bGxvIGNvbnNvbGUhIikKPz4KYGBgcHl0aG9uCnt7X19fKGNvZGU9VHJ1ZSwgY3JvcD1UcnVl
KX19CmBgYAoKKipBVFRFTlRJT046KiogVXNpbmcgdGhlIGBwcmludCgpYCBmdW5jdGlvbiB0
aGUgdGV4dCB3aWxsIGJlIHByaW50ZWQKdG8gdGhlIGNvbnNvbGUgYW5kICoqbm90KiogaW5z
aWRlIHRoZSByZXN1bHRpbmcgTWFya2Rvd24gdGV4dC4KCiMjIyBIaWRkZW4gQ29kZQoKVXNp
bmcgYDxcPy4uLj9cPmAgY29kZSBpcyBleGVjdXRlZCBidXQgbm90IHNob3duIGluIE1hcmtk
b3duLgoKIyMjIyBFeGFtcGxlIHstfQpgYGBweXRob24KPFw/e3tfX18oY29kZT1UcnVlKX19
P1w+CmBgYAojIyMjIFJ1biBhbmQgT3V0cHV0IHstfQpgYGBweXRob24KPD8hCnggPSA0MSAj
IGhpZGRlbiBjb2RlCl9fXyhmIk91dHB1dCB0byBNYXJrZG93bi4geCA9IHt4fSEiKQo/Pgpg
YGAKCioqQVRURU5USU9OOioqIFVzaW5nIHRoZSBgX19fKClgIGZ1bmN0aW9uIHRoZSB0ZXh0
IHdpbGwgYmUgcHJpbnRlZAppbnNpZGUgdGhlIHJlc3VsdGluZyBNYXJrZG93biB0ZXh0ICoq
YW5kIG5vdCoqIG9uIHRoZSBjb25zb2xlLgoKIyMgVGhlIGBfX18oKWAgRnVuY3Rpb24KClVz
aW5nIHRoZSBgcHJpbnQoKWAgc3RhdGVtZW50IHRoZSB0ZXh0IHdpbGwgYmUgcHJpbnRlZCB0
byB0aGUgY29uc29sZS4KV2hlbiB1c2luZyB0aGUgYF9fXygpYCBzdGF0ZW1lbnQgbmV3IE1h
cmtkb3duIHRleHQgaXMKaW5zZXJ0ZWQgZHluYW1pY2FsbHkgaW50byB0aGUgZG9jdW1lbnQg
ZHVyaW5nIHByZXByb2Nlc3NpbmcuCgojIyMjIEV4YW1wbGU6IExpbmUgQnJlYWsgey19CmBg
YHB5dGhvbgo8XD97e19fXyhjb2RlPVRydWUpfX0/XD4KYGBgCiMjIyMgUnVuIGFuZCBPdXRw
dXQgey19CmBgYGJhc2gKPD8hCnggPSA0MCAjIGhpZGRlbiBjb2RlCl9fXygiT3V0cHV0IGlu
ICIsIF9fXykKX19fKCJzaW5nbGUgbGluZSEgIiwgX19fKQpfX18oZiJ4ID0ge3h9IikKPz4K
YGBgCgojIyMjIEV4YW1wbGU6IFNoaWZ0LCBDcm9wLCBSZXR1cm4gey19CmBgYHB5dGhvbgo8
XD97e19fXyhjb2RlPVRydWUpfX0/XD4KYGBgCiMjIyMgUnVuIGFuZCBPdXRwdXQgey19CmBg
YGJhc2gKPD8hCnJlc3VsdCA9IF9fXygiIiIKICAgKiB0ZXh0IGlzIGNyb3BwZWQgYW5kIHNo
aWZ0ZWQKICAgICAgICAgKiBzaGlmdCBhbmQgY3JvcAogICAgICAgICAgICAqIGNhbiBiZSBj
b21iaW5lZAogICAgICAgICAgKiByZXR1cm5pbmcgdGhlIHJlc3VsdAoiIiIsIHNoaWZ0PSIj
IyMjIyMjIyIsIGNyb3A9VHJ1ZSwgcmV0PVRydWUpCl9fXyhyZXN1bHQpCj8+CmBgYAoKIyMg
QWxnb3JpdGhtaWMgVGFibGUgRXhhbXBsZQoKQHRibDphbGd0IGlzIGdlbmVyYXRlZCB1c2lu
ZyB0aGUgZm9sbG93aW5nIHB5dGhvbiBjbG9kZSBibG9jay4KCjw/IQpuID0gNQp0YWJsZSA9
ICIiCmRlYyA9IFsiKiVzKiIsICIqKiVzKioiLCAifn4lc35+IiwgImAlc2AiLAogICAgICAg
ciIkXHRpbWVzXiVzJCIsICIkXGluZnR5XyVzJCJdCnRhYmxlICs9ICJ8Ii5qb2luKCJYIipu
KSArICJcbiIgKyAifCIuam9pbigiLSIqbikgKyAiXG4iCmZvciBpIGluIHJhbmdlKG4pOgoJ
ZmlsbCA9IFtjaHIob3JkKCJBIikrKDIqaSszKmspJTI2KSBmb3IgayBpbiByYW5nZShpKzEp
XQoJZmlsbCA9IFtkZWNbKGwraSklbGVuKGRlYyldJWsgZm9yIGwsIGsgaW4gZW51bWVyYXRl
KGZpbGwpXQoJdGV4dCA9IGxpc3QoIjAiKSpuCgl0ZXh0WyhuPj4xKS0oaT4+MSk6KG4+PjEp
KyhpPj4xKV0gPSBmaWxsCgl0YWJsZSArPSAifCIuam9pbih0ZXh0KSArICJcbiIKPz4KYGBg
cHl0aG9uCnt7X19fKGNvZGU9VHJ1ZSwgY3JvcD1UcnVlKX19CmBgYAoKe3t0YWJsZX19CgpU
YWJsZTogVGFibGUgaXMgZ2VuZXJhdGVkIHVzaW5nIGNvZGUgYW5kIHRoZSBgX19fKClgIHN0
YXRlbWVudC4geyN0Ymw6YWxndH0KCiMjIEZvcm1hdCBMaW5rIEV4dGVuc2lvbgoKV2hlbiB3
cml0aW5nIG11bHRpcGxlIGRvY3VtZW50cywgb2Z0ZW4gZG9jdW1lbnRzIGFyZSByZWZlcmVu
Y2VkCmJldHdlZW4gZWFjaCBvdGhlciB1c2luZyBsaW5rcy4gSW4gb3JkZXIgdG8gcmVmZXIg
dG8gZXh0ZXJuYWwKYGh0bWxgIGFuZCBgcGRmYCBkb2N1bWVudHMgdGhlIE1hcmtkb3duIGxp
bmsgc3RhdGVtZW50IGlzIHVzZWQuCmBgYG1kCltMaW5rIENhcHRpb25dKHBhdGgvdG8vZmls
ZS5odG1sKQpbTGluayBDYXB0aW9uXShwYXRoL3RvL2ZpbGUucGRmKQpgYGAKT25lIGxpbmsg
c3RhdGVtZW50IGNhbm5vdCBiZSB1c2VkIGZvciByZW5kZXJpbmcgYGh0bWxgIGFuZCBgcGRm
YAp3aXRoIGNvbnNpc3RlbnQgcGF0aHMuIFVzaW5nIHRoZSBgbWFya3lgIGZvcm1hdCBsaW5r
CiBgLlw/Pz9gIGZpbGUgZXh0ZW5zaW9uIHJlc3VsdHMgaW4gY29uc2lzdGVudCBsaW5rcyBm
b3IgYGh0bWxgIGFuZApgcGRmYCBkb2N1bWVudHMuCgojIyMjIEV4YW1wbGUgey19CmBgYG1k
CltMaW5rIHRvIHRoaXMgRG9jdW1lbnRdKG1hcmt5Llw/Pz8pCmBgYAojIyMjIE91dHB1dCB7
LX0KPiBbTGluayB0byB0aGlzIERvY3VtZW50XShtYXJreS4/Pz8pCgojIyBGb3JtYXQgQ29k
ZXMKCk9mdGVuIHdoZW4gd3JpdGluZyBtYXJrZG93biBmb3IgYGh0bWxgIGFuZCBgcGRmYCBk
b2N1bWVudHMsIHRoZQpvdXRwdXQgbmVlZHMgdG8gYmUgdHdlYWtlZCBhY2NvcmRpbmdseS4K
YG1hcmt5YCBzdXBwb3J0cyBmb3JtYXQgc3BlY2lmaWMgdHdlYWtpbmcgYnkgaW5qZWN0aW5n
CnJhdyBgaHRtbGAgb3IgYHRleGAgY29kZSBpbnRvIE1hcmtkb3duIHVzaW5nIGZvcm1hdCBj
b2Rlcy4KCkluIG9yZGVyIHRvIGluamVjdCBmb3JtYXQgc3BlY2lmaWMgY29kZSB0aGUgYGZt
dGNvZGVgIGNsYXNzIGlzIHVzZWQuClRoZSBgZm10Y29kZWAgY2xhc3MgbWFuYWdlcyBpbmpl
Y3Rpb24gb2YgYGh0bWxgIGFuZCBgdGV4YCBjb2RlCmRlcGVuZGluZyBvbiB0aGUgb3V0cHV0
IGZvcm1hdC4KCioqQVRURU5USU9OOioqIGB0ZXhgIHBhY2thZ2VzIGhhdmUgdG8gYmUgaW5j
bHVkZWQgZm9yIGBwZGZgIGFzIHdlbGwgYXMKSmF2YVNjcmlwdCBhbmQgc3R5bGUgc2hlZXRz
IGZvciBgaHRtbGAgdXNpbmcgdGhlIG1ldGEgZGF0YSBmaWVsZHMKYGhlYWRlci1pbmNsdWRl
cy0tcGRmYCBhbmQgYGhlYWRlci1pbmNsdWRlcy0taHRtbGAgcmVzcGVjdGl2ZWx5LgoKIyMj
IyBFeGFtcGxlOiBgZm10Y29kZWAgey19Cjw/IQpGID0gZm10Y29kZShodG1sPSJIPHN1cD5U
PC9zdXA+PHN1Yj5NPC9zdWI+TCIsIHBkZj1yIlxMYVRlWCIpCj8+CmBgYHB5dGhvbgp7e19f
Xyhjb2RlPVRydWUsIGNyb3A9VHJ1ZSl9fQpgYGAKYGBgbWFya2Rvd24KSW52b2NhdGlvbiBv
ZiBmb3JtYXQgY29kZSByZXN1bHRzIGluOiB7XHtGKCl9XH0uCmBgYAojIyMjIE91dHB1dCB7
LX0KPiBJbnZvY2F0aW9uIG9mIGZvcm1hdCBjb2RlIHJlc3VsdHMgaW46IHt7RigpfX0uCgoj
IyMjIEV4YW1wbGU6IENvbG9yIHstfQo8PyEKQyA9IGxhbWJkYSBjb2xvcjogZm10Y29kZSgK
CWh0bWw9IjxzcGFuIHN0eWxlPSdjb2xvcjolczsnPnswfTwvc3Bhbj4iICUgY29sb3IsCglw
ZGY9ciJcdGV4dGNvbG9ye3slc319e3t7MH19fSIgJSBjb2xvcgopCkIgPSBDKCJibHVlIikK
UiA9IEMoInJlZCIpCj8+CmBgYHB5dGhvbgp7e19fXyhjb2RlPVRydWUsIGNyb3A9VHJ1ZSl9
fQpgYGAKYGBgbWFya2Rvd24KVGV4dCB3aXRoIHtce0IoImJsdWUiKX1cfSBhbmQge1x7Uigi
UkVEIil9XH0uCmBgYAojIyMjIE91dHB1dCB7LX0KPiBUZXh0IHdpdGgge3tCKCJibHVlIil9
fSBhbmQge3tSKCJSRUQiKX19LgoKCiMjIyMgRXhhbXBsZTogQ2xhc3NlcyB7LX0KPD8hCmNs
YXNzIGNvbG9yOgoJZGVmIF9faW5pdF9fKHNlbGYsIGNvbG9yKToKCQlzZWxmLmNvbG9yID0g
Y29sb3IKCWRlZiB1cHBlcihzZWxmLCB4KToKCQlyZXR1cm4gc2VsZi50ZXh0KHgudXBwZXIo
KSkKCWRlZiBsb3dlcihzZWxmLCB4KToKCQlyZXR1cm4gc2VsZi50ZXh0KHgubG93ZXIoKSkK
CmNsYXNzIGh0bWwoY29sb3IpOgoJZGVmIHRleHQoc2VsZiwgeCk6CgkJcmV0dXJuIGYiPHNw
YW4gc3R5bGU9J2NvbG9yOntzZWxmLmNvbG9yfTsnPnt4fTwvc3Bhbj4iCgpjbGFzcyBwZGYo
Y29sb3IpOgoJZGVmIHRleHQoc2VsZiwgeCk6CgkJcmV0dXJuIHJmIlx0ZXh0Y29sb3J7e3tz
ZWxmLmNvbG9yfX19e3t7eH19fSIKCkNDID0gbGFtYmRhIHg6IGZtdGNvZGUoaHRtbD1odG1s
KHgpLCBwZGY9cGRmKHgpKQpCQiA9IENDKCJibHVlIikKUlIgPSBDQygicmVkIikKPz4KYGBg
cHl0aG9uCnt7X19fKGNvZGU9VHJ1ZSwgY3JvcD1UcnVlKX19CmBgYApgYGBtYXJrZG93bgpU
ZXh0IHdpdGgge1x7QkIudXBwZXIoImJsdWUiKX1cfSBhbmQge1x7UlIubG93ZXIoIlJFRCIp
fVx9LgpgYGAKIyMjIyBPdXRwdXQgey19Cj4gVGV4dCB3aXRoIHt7QkIudXBwZXIoImJsdWUi
KX19IGFuZCB7e1JSLmxvd2VyKCJSRUQiKX19LgoKIyMgTWFya2Rvd24gSW5jbHVkZQoKT2Z0
ZW4gd2hlbiB3cml0aW5nIG1hcmtkb3duIGZvciBgaHRtbGAgYW5kIGBwZGZgIGRvY3VtZW50
cywKY2VydGFpbiBwYXJhZ3JhcGhzIG5lZWQgdG8gYmUgZHVwbGljYXRlZCwgb3IgcmVuZGVy
ZWQKd2l0aCBvdGhlciBwYXJhbWV0ZXJzLiBgbWFya3kgc3VwcG9ydHNgIGluY2x1ZGluZwpv
dGhlciBkb2N1bWVudHMgdmlhIGBfX18oZmlsZSlgdGhlCm91dHB1dCBuZWVkcyB0byBiZSB0
d2Vha2VkIGFjY29yZGluZ2x5LgpgbWFya3lgIHN1cHBvcnRzIGZvcm1hdCBzcGVjaWZpYyB0
d2Vha2luZyBieSBpbmplY3RpbmcKcmF3IGBodG1sYCBvciBgdGV4YCBjb2RlIGludG8gTWFy
a2Rvd24gdXNpbmcgZm9ybWF0IGNvZGVzLgoKIyBNZXRhIERhdGEgaW4gRnJvbnQgTWF0dGVy
CgpNZXRhIGRhdGEgaXMgYW5ub3RhdGVkIGluIHRoZSBmcm9udCBtYXR0ZXIgb2YgYSBNYXJr
ZG93biB0ZXh0IGRvY3VtZW50LgpUaGUgZnJvbnQgbWF0dGVyIG11c3Qgc3RhcnQgaW4gdGhl
IGZpcnN0IGxpbmUgd2l0aCBgLS0tYCBhbmQgcHJlY2VkZXMgYWxsCm90aGVyIHRleHQgYmVp
bmcgZmVuY2VkIGJ5IGAtLS1gLiBUaGUgbWV0YSBkYXRhIGlzIGluIGB5YW1sYCBmb3JtYXQu
ClRoZSBgeWFtbGAgYmxvY2sgaXMgcGFyc2VkIHVzaW5nIGBweXRob24tcHl5YW1sYC4gQWxs
IG1ldGEKZGF0YSBpcyBpbXBvcnRlZCBpbnRvIHRoZSBwcmVwcm9jZXNzZWQgZG9jdW1lbnQu
CgojIyBQYW5kb2MgRnJvbnQgTWF0dGVyCgojIyMjIEV4YW1wbGUgey19CmBgYHlhbWwKLS0t
CnRpdGxlOiBNeSBEb2N1bWVudApkYXRlOiAyMDIyLTAxLTAxCmF1dGhvcjogLi4uCmxpbmst
Y2l0YXRpb25zOiB0cnVlCmJpYmxpb2dyYXBoeTogZGF0YS9tYXJreS5iaWIKaGVhZGVyLWlu
Y2x1ZGVzOiA+CiAgIFxoeXBlcnNldHVwe2NvbG9ybGlua3M9ZmFsc2UsCiAgIGFsbGJvcmRl
cmNvbG9ycz17MCAwIDB9LAogICBwZGZib3JkZXJzdHlsZT17L1MvVS9XIDF9XH0KeG5vcy1j
bGV2ZXJlZjogdHJ1ZQp4bm9zLWNhcGl0YWxpc2U6IHRydWUKZm9udHNpemU6IDExcHQKLS0t
CmBgYApUaGUgbWV0YSBkYXRhIGZpZWxkcwpbYHRpdGxlYCwgYGRhdGVgLCBgYXV0aG9yYF0o
aHR0cHM6Ly9wYW5kb2Mub3JnL01BTlVBTC5odG1sI21ldGFkYXRhLXZhcmlhYmxlcyksCltg
bGluay1jaXRhdGlvbnNgXShodHRwczovL3BhbmRvYy5vcmcvTUFOVUFMLmh0bWwjb3RoZXIt
cmVsZXZhbnQtbWV0YWRhdGEtZmllbGRzKSwKW2BiaWJsaW9ncmFwaHlgXShodHRwczovL3Bh
bmRvYy5vcmcvTUFOVUFMLmh0bWwjY2l0YXRpb24tcmVuZGVyaW5nKSBhbmQKW2BoZWFkZXIt
aW5jbHVkZXNgXShodHRwczovL3BhbmRvYy5vcmcvTUFOVUFMLmh0bWwjdmFyaWFibGVzLXNl
dC1hdXRvbWF0aWNhbGx5KQphcmUgcHJvY2Vzc2VkIGJ5IGBwYW5kb2NgIGR1cmluZyBkb2N1
bWVudCByZW5kZXJpbmcuIGBmb250c2l6ZWAgYWRqdXN0cyB0aGUKZm9udCBzaXplIGluIFtg
aHRtbGBdKGh0dHBzOi8vcGFuZG9jLm9yZy9NQU5VQUwuaHRtbCN2YXJpYWJsZXMtZm9yLWh0
bWwpCmFuZCBbYHBkZmBdKGh0dHBzOi8vcGFuZG9jLm9yZy9NQU5VQUwuaHRtbCN2YXJpYWJs
ZXMtZm9yLWxhdGV4KSBkb2N1bWVudHMuClRoZSBgeG5vcy1jbGV2ZXJlZmAgYW5kIGB4bm9z
LWNhcGl0YWxpc2VgCmZpZWxkcyBhcmUgdXNlZCBieSB0aGUgW2BwYW5kb2MteG5vc2BdKGh0
dHBzOi8vZ2l0aHViLmNvbS90b21kdWNrL3BhbmRvYy14bm9zKQpleHRlbnNpb25zIGZvciBy
ZWZlcmVuY2luZwpbZmlndXJlc10oaHR0cHM6Ly9naXRodWIuY29tL3RvbWR1Y2svcGFuZG9j
LWZpZ25vcyNjdXN0b21pemF0aW9uKSwKW3RhYmxlc10oaHR0cHM6Ly9naXRodWIuY29tL3Rv
bWR1Y2svcGFuZG9jLXRhYmxlbm9zI2N1c3RvbWl6YXRpb24pLApbc2VjdGlvbnNdKGh0dHBz
Oi8vZ2l0aHViLmNvbS90b21kdWNrL3BhbmRvYy1zZWNub3MjY3VzdG9taXphdGlvbikgYW5k
CltlcXVhdGlvbnNdKGh0dHBzOi8vZ2l0aHViLmNvbS90b21kdWNrL3BhbmRvYy1lcW5vcyNj
dXN0b21pemF0aW9uKS4KCiMjIGBtYXJreWAgRm9ybWF0IEZpZWxkcwoKKipFeGFtcGxlKioK
YGBgeWFtbAotLS0KaGVhZGVyLWluY2x1ZGVzLS1wZGY6ID4KICBcaHlwZXJzZXR1cHsKICBj
b2xvcmxpbmtzPWZhbHNlLAogIGFsbGJvcmRlcmNvbG9ycz17MCAwIDB9LAogIHBkZmJvcmRl
cnN0eWxlPXsvUy9VL1cgMX1cfQpoZWFkZXItaW5jbHVkZXMtLWh0bWw6ID4KICA8c3R5bGU+
KiB7IGJveC1zaXppbmc6IGJvcmRlci1ib3g7IH08L3N0eWxlPgotLS0KYGBgCgpUaGUgcGFu
ZG9jIGBoZWFkZXItaW5jbHVkZXNgIGZpZWxkIGlzIHVzZWQgZm9yIGBwZGZgIGFuZCBgaHRt
bGAgZG9jdW1lbnRzLAp0aGVyZWZvcmUgaXQgbXVzdCBjb250YWluIGNvcnJlc3BvbmRpbmcg
dGV4IGFuZCBgaHRtbGAgY29kZS4KClRoZSBmaWVsZCBgaGVhZGVyLWluY2x1ZGVzYCBlbmRp
bmcgd2l0aCBgLS1wZGZgIG9yIGAtLWh0bWxgCnNwZWNpZmllcyBjb3JyZXNwb25kaW5nIG9w
dGlvbnMgZm9yIHRoZSBnZW5lcmF0aW9uIG9mIGBwZGZgIGFuZCBgaHRtbGAKZG9jdW1lbnRz
LiBEdXJpbmcgbWFrZSwgYG1hcmt5YCBzY2FucyBhbGwgbWV0YSBkYXRhIGZpZWxkcywgYW5k
CmZpZWxkcyB3aGljaCBlbmQgd2l0aCBgLS1wZGZgIGFuZCBgLS1odG1sYCBhcmUgc2VsZWN0
ZWQgYW5kIGZvcndhcmRlZAp0byBgcGFuZG9jYCBiYXNlZCBvbiB0aGUgZm9ybWF0IHRvIGJl
IHJlbmRlcmVkLgoKIyBTY2llbnRpZmljIFdyaXRpbmcgaW4gTWFya2Rvd24geyNzZWM6cGFu
bWR9CgpbTWFya2Rvd25dKGh0dHBzOi8vcGFuZG9jLm9yZy9NQU5VQUwuaHRtbCNwYW5kb2Nz
LW1hcmtkb3duKSBpcyBhIG1hcmt1cApsYW5ndWFnZSBmb3IgdGVjaG5pY2FsIHdyaXRpbmcs
IHdpdGggZW1waGFzaXMgb24gcmVhZGFiaWxpdHkuIE1hcmtkb3duCmNhbiBiZSByZW5kZXJl
ZCBpbiBtYW55IGZvcm1hdHMgaW5jbHVkaW5nIGBodG1sYCBhbmQgYHBkZmAgYnkgdXNpbmcK
W2BwYW5kb2NgXShodHRwczovL3BhbmRvYy5vcmcvKSBmb3IgZXhhbXBsZS4KClVzaW5nIHZh
cmlvdXMgTWFya2Rvd24gZXh0ZW5zaW9ucyBvZiBgcGFuZG9jYCBhIHN1ZmZpY2llbnQgc3Ry
dWN0dXJlIGZvcgp3cml0aW5nIHNjaWVudGlmaWMgZG9jdW1lbnRzIGlzIHJlZmxlY3RlZCB1
c2luZyBNYXJrZG93biBzeW50YXguCmBtYXJreWAgYnkgZGVmYXVsdCB1c2VzIHRoZSBmb2xs
b3dpbmcgYHBhbmRvY2AgTWFya2Rvd24gZXh0ZW5zaW9ucy4KKiBwYXJzaW5nIGV4dGVuc2lv
bnMKCSogW2FsbF9zeW1ib2xzX2VzY2FwYWJsZV0oaHR0cHM6Ly9wYW5kb2Mub3JnL01BTlVB
TC5odG1sI2V4dGVuc2lvbi1hbGxfc3ltYm9sc19lc2NhcGFibGUpCgkqIFtpbnRyYXdvcmRf
dW5kZXJzY29yZXNdKGh0dHBzOi8vcGFuZG9jLm9yZy9NQU5VQUwuaHRtbCNleHRlbnNpb24t
aW50cmF3b3JkX3VuZGVyc2NvcmVzKQoJKiBbZXNjYXBlZF9saW5lX2JyZWFrc10oaHR0cHM6
Ly9wYW5kb2Mub3JnL01BTlVBTC5odG1sI2V4dGVuc2lvbi1lc2NhcGVkX2xpbmVfYnJlYWtz
KQoJKiBbc3BhY2VfaW5fYXR4X2hlYWRlcl0oaHR0cHM6Ly9wYW5kb2Mub3JnL01BTlVBTC5o
dG1sI2V4dGVuc2lvbi1zcGFjZV9pbl9hdHhfaGVhZGVyKQoJKiBbbGlzdHNfd2l0aG91dF9w
cmVjZWRpbmdfYmxhbmtsaW5lXShodHRwczovL3BhbmRvYy5vcmcvTUFOVUFMLmh0bWwjZXh0
ZW5zaW9uLWxpc3RzX3dpdGhvdXRfcHJlY2VkaW5nX2JsYW5rbGluZSkKKiBzdHlsaW5nIGV4
dGVuc2lvbnMKCSogW2lubGluZV9jb2RlX2F0dHJpYnV0ZXNdKGh0dHBzOi8vcGFuZG9jLm9y
Zy9NQU5VQUwuaHRtbCNleHRlbnNpb24taW5saW5lX2NvZGVfYXR0cmlidXRlcykKCSogW3N0
cmlrZW91dF0oaHR0cHM6Ly9wYW5kb2Mub3JnL01BTlVBTC5odG1sI2V4dGVuc2lvbi1zdHJp
a2VvdXQpCiogc3RydWN0dXJpbmcgZXh0ZW5zaW9ucwoJKiBbeWFtbF9tZXRhZGF0YV9ibG9j
a10oaHR0cHM6Ly9wYW5kb2Mub3JnL01BTlVBTC5odG1sI2V4dGVuc2lvbi15YW1sX21ldGFk
YXRhX2Jsb2NrKQoJKiBbcGlwZV90YWJsZXNdKGh0dHBzOi8vcGFuZG9jLm9yZy9NQU5VQUwu
aHRtbCNleHRlbnNpb24tcGlwZV90YWJsZXMpCgkqIFtsaW5lX2Jsb2Nrc10oaHR0cHM6Ly9w
YW5kb2Mub3JnL01BTlVBTC5odG1sI2V4dGVuc2lvbi1saW5lX2Jsb2NrcykKCSogW2ltcGxp
Y2l0X2ZpZ3VyZXNdKGh0dHBzOi8vcGFuZG9jLm9yZy9NQU5VQUwuaHRtbCNleHRlbnNpb24t
aW1wbGljaXRfZmlndXJlcykKCSogW2FiYnJldmlhdGlvbnNdKGh0dHBzOi8vcGFuZG9jLm9y
Zy9NQU5VQUwuaHRtbCNleHRlbnNpb24tYWJicmV2aWF0aW9ucykKCSogW2lubGluZV9ub3Rl
c10oaHR0cHM6Ly9wYW5kb2Mub3JnL01BTlVBTC5odG1sI2V4dGVuc2lvbi1pbmxpbmVfbm90
ZXMpCiogY29kZSBpbmplY3Rpb24KCSogW3Jhd19odG1sXShodHRwczovL3BhbmRvYy5vcmcv
TUFOVUFMLmh0bWwjZXh0ZW5zaW9uLXJhd19odG1sKQoJKiBbcmF3X3RleF0oaHR0cHM6Ly9w
YW5kb2Mub3JnL01BTlVBTC5odG1sI2V4dGVuc2lvbi1yYXdfdGV4KQoKYHBhbmRvY2Agc3Vw
cG9ydHMKW2VxdWF0aW9uc10oaHR0cHM6Ly9wYW5kb2Mub3JnL01BTlVBTC5odG1sI2V4dGVu
c2lvbi10ZXhfbWF0aF9kb2xsYXJzKQpyZW5kZXJlZCBpbmxpbmUgYW5kIHNpbmdsZS1saW5l
IGluIHRleC1zdHlsZSB1c2luZyBgJC4uLiRgIGFuZCBgJCQuLi4kJGAsCltiaWJsaW9ncmFw
aHldKGh0dHBzOi8vcGFuZG9jLm9yZy9NQU5VQUwuaHRtbCNjaXRhdGlvbnMpCnVzaW5nIHRo
ZSBgLS1jaXRlcHJvY2Agb3B0aW9uLApbc2VjdGlvbiBudW1iZXJpbmddKGh0dHBzOi8vcGFu
ZG9jLm9yZy9NQU5VQUwuaHRtbCNleHRlbnNpb24taGVhZGVyX2F0dHJpYnV0ZXMpCnVzaW5n
IHRoZSBgLS1udW1iZXItc2VjdGlvbnNgIG9wdGlvbiBhbmQKW3RhYmxlIG9mIGNvbnRlbnRz
XShodHRwczovL3BhbmRvYy5vcmcvTUFOVUFMLmh0bWwjb3B0aW9uLS10b2MpCnVzaW5nIHRo
ZSBgLS10YWJsZS1vZi1jb250ZW50c2Agb3B0aW9uLgoKYHBhbmRvY2Agc3VwcG9ydHMgW2B4
bm9zYF0oaHR0cHM6Ly9naXRodWIuY29tL3RvbWR1Y2svcGFuZG9jLXhub3MpIGZpbHRlcnMK
Zm9yIHJlZmVyZW5jaW5nIGRvY3VtZW50IGNvbnRlbnQgbGlrZQpbZmlndXJlc10oaHR0cHM6
Ly9naXRodWIuY29tL3RvbWR1Y2svcGFuZG9jLWZpZ25vcyN1c2FnZSksCltlcXVhdGlvbnNd
KGh0dHBzOi8vZ2l0aHViLmNvbS90b21kdWNrL3BhbmRvYy1lcW5vcyN1c2FnZSksClt0YWJs
ZXNdKGh0dHBzOi8vZ2l0aHViLmNvbS90b21kdWNrL3BhbmRvYy10YWJsZW5vcyN1c2FnZSks
CltzZWN0aW9uc10oaHR0cHM6Ly9naXRodWIuY29tL3RvbWR1Y2svcGFuZG9jLXNlY25vcyN1
c2FnZSkKYnkgdXNpbmcgdGhlIGAtLWZpbHRlciBwYW5kb2MteG5vc2Agb3B0aW9uLgpgeG5v
c2AgaW50ZWdyYXRlcyBjbGV2ZXIgcmVmZXJlbmNlcywgd2hpY2ggbWVhbnMgIkZpZy4iLCAi
U2VjLiIsICJFcS4iCmFuZCAiVGFiLiIgYXJlIGFkZGVkIGF1dG9tYXRpY2FsbHkgdG8gdGhl
IGNvcnJlc3BvbmRpbmcgZWxlbWVudC4KSWYgdGhlIHByZWZpeCBpcyB0byBiZSBvbWl0dGVk
LCB0aGUgcmVmZXJlbmNlIGlzIHdyaXR0ZW4gYXMKYFwhQHJlZjpsYWJlbGAuCgojIyMjIEV4
YW1wbGUgey19CmBgYG1kCiMjIFJlZmVyZW5jZWQgU2VjdGlvbiB7I3NlYzpsYWJlbH0KClRo
aXMgaXMgYSByZWZlcmVuY2UgdG8gQHNlYzpsYWJlbC4KCiFbVGhpcyBpcyB0aGUgY2FwdGlv
bl0oZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TClVoRVVnQUFBQVVB
QUFBRkNBWUFBQUNOYnlibEFBQUFIRWxFUVZRSTEyUDQvLzgvdzM4R0lBWERJQktFMERICnhn
bGpOQkFBTzlUWEwwWTRPSHdBQUFBQkpSVTVFcmtKZ2dnPT0peyNmaWc6bGFiZWx9CgpUaGlz
IGlzIGEgcmVmZXJlbmNlIHRvIEBmaWc6bGFiZWwuCgpBICB8QiAgfEMgIHxECi0tLXwtLS18
LS0tfC0tLQowMDB8MTExfDQ0NHw1NTUKMjIyfDMzM3w2NjZ8Nzc3CgpUYWJsZTogVGhpcyBp
cyB0aGUgY2FwdGlvbiB7I3RibDpsYWJlbH0KClRoaXMgaXMgYSByZWZlcmVuY2UgdG8gQHRi
bDpsYWJlbC4KCiQkXG1ib3h7ZX1ee1xtYm94e2l9XHBpfSsxPTAkJHsjZXE6bGFiZWx9CgpU
aGlzIGlzIGEgcmVmZXJlbmNlIHRvIEBlcTpsYWJlbC4KClRoaXMgaXMgYSBjaXRhdGlvbiBb
QE11bGxlcjE5OTNdLgpgYGAKClRoZSBmaWxlIGBtYXJreS5iaWJgIGlzIHNwZWNpZmllZCBp
biB0aGUgbWV0YSBkYXRhIGluIHRoZSBmcm9udAptYXR0ZXIgb2YgdGhlIE1hcmtkb3duIHRl
eHQuCgojIyBSZWZlcmVuY2VkIFNlY3Rpb24geyNzZWM6bGFiZWx9CgpUaGlzIGlzIGEgcmVm
ZXJlbmNlIHRvIEBzZWM6bGFiZWwuCgohW1RoaXMgaXMgdGhlIGNhcHRpb25dKGRhdGE6aW1h
Z2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQVVBQUFBRkNBWUFBQUNO
YnlibEFBQUFIRWxFUVZRSTEyUDQvLzgvdzM4R0lBWERJQktFMERIeGdsak5CQUFPOVRYTDBZ
NE9Id0FBQUFCSlJVNUVya0pnZ2c9PSl7I2ZpZzpsYWJlbH0KClRoaXMgaXMgYSByZWZlcmVu
Y2UgdG8gQGZpZzpsYWJlbC4KCkEgIHxCICB8QyAgfEQKLS0tfC0tLXwtLS18LS0tCjAwMHwx
MTF8NDQ0fDU1NQoyMjJ8MzMzfDY2Nnw3NzcKClRhYmxlOiBUaGlzIGlzIHRoZSBjYXB0aW9u
LiB7I3RibDpsYWJlbH0KClRoaXMgaXMgYSByZWZlcmVuY2UgdG8gQHRibDpsYWJlbC4KCiQk
XG1ib3h7ZX1ee2lccGl9KzE9MCQkeyNlcTpsYWJlbH0KClRoaXMgaXMgYSByZWZlcmVuY2Ug
dG8gQGVxOmxhYmVsLgoKVGhpcyBpcyBhIGNpdGF0aW9uIFtATXVsbGVyMTk5M10uCgotLS0K
CipUaGFua3MgZm9yIHJlYWRpbmcsIHBsZWFzZSB0cnkqIGBtYXJreWAuCgotLS0KCiMgUmVm
ZXJlbmNlcwo=
'''
pack_marky_bib = '''
QGFydGljbGV7TXVsbGVyMTk5MywKICAgIGF1dGhvciAgPSB7UGV0ZXIgTXVsbGVyfSwKICAg
IHRpdGxlICAgPSB7VGhlIHRpdGxlIG9mIHRoZSB3b3JrfSwKICAgIGpvdXJuYWwgPSB7VGhl
IG5hbWUgb2YgdGhlIGpvdXJuYWx9LAogICAgeWVhciAgICA9IHsxOTkzfSwKICAgIG51bWJl
ciAgPSB7Mn0sCiAgICBwYWdlcyAgID0gezIwMS0yMTN9LAogICAgbW9udGggICA9IHs3fSwK
ICAgIG5vdGUgICAgPSB7QW4gb3B0aW9uYWwgbm90ZX0sCiAgICB2b2x1bWUgID0gezR9Cn0K
'''
pack__gitignore = '''
YnVpbGQvCmh0bWwvCg==
'''

###!!!:::marky_pack_data:::!!!###
########################################################################
# SECTION IS AUTO-PACKAGED USING ./marky.py --pack --force
########################################################################

########################################################################

def _marky_front_join(y, text):
	return """---\n%s\n---\n%s""" % (
		yaml.dump(y, allow_unicode=True, default_flow_style=False),
		text
	)

def _marky_front_split(t):
	global _MARKY_EXEC_GLOBALS
	if not t.startswith("---\n"):
		return dict(), t, 0
	y = t.split("---\n")[1]
	meta_lines = len(y.split("\n")) + 2
	mark = "---\n".join(t.split("---\n")[2:])
	print("---\n" + y + "---", flush=True)
	data = dict()
	try:
		data = yaml.safe_load(y)
	except Exception as ex:
		print("# YAML ERROR", type(ex), str(ex))
		sys.exit(1)
	return data, mark, meta_lines

########################################################################

def _marky_file_mtime_older(f1, f2):
	return os.path.getmtime(f1) < os.path.getmtime(f2)

def _marky_file_mtime_newer(f1, f2):
	return os.path.getmtime(f1) > os.path.getmtime(f2)

def _marky_mdtext_print(*args, sep=" ", shift="", crop=False, ret=False, code=False, pop=True,
	file=None, __marky__=False, raw=False, aux=False):
	# MD output: args, sep=" ", shift="", crop=False, ret=False
	# MD code output: code=False, pop=True
	# MD include: file, __marky__, raw, aux
	global _MARKY_EXEC_QUIET
	global _MARKY_EXEC_TEXT
	global _MARKY_EXEC_APPEND
	global _MARKY_PASTE_CODE
	if code:
		if len(_MARKY_PASTE_CODE) == 0: return ""
		code = _MARKY_PASTE_CODE[0]
		if pop: _MARKY_PASTE_CODE = _MARKY_PASTE_CODE[1:]
		return _marky_mdtext_print(code, shift=shift, crop=crop, ret=True, code=False)
	if not file is None:
		if aux:
			_MARKY_INCLUDE_LIST.append(_MARKY_MD_DIR + file)
		elif raw:
			if not os.path.exists(file):
				print("# ERROR", "no such file", file)
				sys.exit(1)
			___(open(file, "r").read(), ___)
		else:
			_marky_run(_MARKY_MD_DIR + file, "/".join(file.split("/")[0:-1]), __marky__)
		return
	if len(args) == 0:
		if _MARKY_EXEC_APPEND == False: _MARKY_EXEC_TEXT.append("")
		_MARKY_EXEC_APPEND = False
	else:
		if ret: return _marky_mdtext_ret(args[0], shift, crop)
		if crop or shift != "":
			_marky_mdtext_crop(args[0], shift, crop)
			if args[-1] == _marky_mdtext_print:
				_MARKY_EXEC_APPEND = True
			return
		exec_append_new = False
		if args[-1] == _marky_mdtext_print:
			exec_append_new = True
			args = args[0:-1]
		text = sep.join([str(i) for i in args])
		if _MARKY_EXEC_APPEND and len(_MARKY_EXEC_TEXT) > 0:
			_MARKY_EXEC_TEXT[-1] += text
		else:
			_MARKY_EXEC_TEXT.append(text)
		_MARKY_EXEC_APPEND = exec_append_new
		if not _MARKY_EXEC_QUIET: print(text, end="" if _MARKY_EXEC_APPEND else "\n", flush=True)

def _marky_mdtext_crop(arg, shift, crop):
	global _MARKY_EXEC_TEXT
	global _MARKY_EXEC_APPEND
	if not type(arg) is str:
		arg = str(arg)
	arg = arg.split("\n")
	if crop:
		if len(arg[0].strip()) == 0:
			arg = arg[1:]
		if len(arg[-1].strip()) == 0:
			arg = arg[:-1]
	n = len(arg[0]) - len(arg[0].lstrip())
	for i in arg:
		if crop and len(i[0:n].lstrip()) == 0:
			i = i[n:]
		_MARKY_EXEC_TEXT.append(shift + i)

def _marky_mdtext_ret(arg, shift="", crop=True):
	if not type(arg) is str:
		arg = str(arg)
	text = []
	arg = arg.split("\n")
	if crop:
		if len(arg[0].strip()) == 0:
			arg = arg[1:]
		if len(arg[-1].strip()) == 0:
			arg = arg[:-1]
	n = len(arg[0]) - len(arg[0].lstrip())
	for i in arg:
		if crop and len(i[0:n].lstrip()) == 0:
			i = i[n:]
		text.append(shift + i)
	return "\n".join(text)

########################################################################

class _marky_fmtcall:
	def __init__(self, name, fmtc):
		self.name = name
		self.fmtc = fmtc
	def __call__(self, *args, **kwargs):
		text = "<<?html "
		f = getattr(self.fmtc.html, self.name)
		if callable(f):
			v = f(*args, **kwargs)
			if type(v) is str: text += v
		elif type(f) is str:
			text += f.format(*args, **kwargs)
		text += " html?>>"
		text += "<<?pdf "
		f = getattr(self.fmtc.pdf, self.name)
		if callable(f):
			v = f(*args, **kwargs)
			if type(v) is str: text += v
		elif type(f) is str:
			text += f.format(*args, **kwargs)
		text += " pdf?>>"
		return text

class _marky_fmtcode:
	def __init__(self, pdf=None, html=None):
		if not html is None: self.html = html
		if not pdf is None: self.pdf = pdf
	def __call__(self, *args, **kwargs):
		text = "<<?html "
		f = self.html
		if callable(f):
			v = f(*args, **kwargs)
			if type(v) is str: text += v
		elif type(f) is str:
			text += f.format(*args, **kwargs)
		text += " html?>>"
		text += "<<?pdf "
		f = self.pdf
		if callable(f):
			v = f(*args, **kwargs)
			if type(v) is str: text += v
		elif type(f) is str:
			text += f.format(*args, **kwargs)
		text += " pdf?>>"
		return text
	def __getattr__(self, name):
		return _marky_fmtcall(name, self)

########################################################################

def _marky_rebrace(t):
	t = t.replace("{{", "<<brace?")
	t = t.replace("}}", "?brace>>")
	t = t.replace("{", "{{")
	t = t.replace("}", "}}")
	t = t.replace("<<brace?", "{")
	t = t.replace("?brace>>", "}")
	return t

def _marky_code_text(t, fstring=True):
	if fstring:
		if not '"""' in t and not t.endswith('"'):
			return '___(rf"""' + _marky_rebrace(t) + '""", ___); '
		elif not "'''" in t and not t.endswith("'"):
			return "___(rf'''" + _marky_rebrace(t) + "''', ___); "
		else:
			print("# ERROR", "python code contains \"\"\" as well as '''.")
			sys.exit(1)
	else:
		if not '"""' in t and not t.endswith('"'):
			return '___(r"""' + t + '""", ___); '
		elif not "'''" in t and not t.endswith("'"):
			return "___(r'''" + t + "''', ___); "
		else:
			print("# ERROR", "python code contains \"\"\" as well as '''.")
			sys.exit(1)

def _marky_paste_code(t):
	global _MARKY_PASTE_CODE
	# ~ show_code = False
	if t.startswith("!"):
		t = t[1:]
		_MARKY_PASTE_CODE.append(t)
		# ~ show_code = True
	# ~ if show_code:
		# ~ return _marky_code_text(t, fstring=False) + t
	return t

def _marky_meta_merge(old, front):
	global _MARKY_EXEC_GLOBALS
	meta = {}
	meta.update(old)
	try:
		for k, v in front.items():
			x = k.split("--")
			if "--" in k and x[-1] in _MARKY_FORMAT:
				if k in meta:
					if type(v) is list:
						print("<!-- field link, merge yaml list %s --!>" % k)
						meta[k].extend(v)
					if type(v) is dict:
						print("<!-- field link, merge yaml dict %s --!>" % k)
						meta[k].update(v)
					if type(v) is str:
						print("<!-- field link, merge yaml str %s --!>" % k)
						meta[k] += " " + v
					else:
						print("<!-- field exists, skip yaml %s %s --!>" % (str(type(v)), k))
				else:
					print("<!-- field link, set yaml %s --!>" % k)
					meta[k] = v
			else:
				if k in meta:
					print("<!-- field exists, skip yaml %s --!>" % k)
				else:
					meta[k] = v
				k = k.replace("-", "_")
				if k in _MARKY_EXEC_GLOBALS:
					print("<!-- field exists, skip local %s --!>" % k)
				else:
					_MARKY_EXEC_GLOBALS[k] = v
	except Exception as ex:
		print("# META MERGE ERROR", type(ex), str(ex))
		sys.exit(1)
	return meta

def _marky_run(fname, inbase, run=True):
	global _MARKY_EXEC_GLOBALS
	global _MARKY_META_DICT
	global _MARKY_INCLUDE_LIST
	_MARKY_INCLUDE_LIST.append(fname)
	with open(fname, "r") as h:
		front, t, meta_lines = _marky_front_split(h.read())
	_MARKY_META_DICT = _marky_meta_merge(_MARKY_META_DICT, front)
	p = 0
	r = ""
	while True:
		p0 = t.find("<?", p)
		p1 = t.find("?>", p)
		if p0 > -1:
			if p1 < p0:
				print(t[max(0, p0-250):p0+2])
				print("# ERROR", "?> before <?", r"... (can use <\? and ?\> for escaping)")
				if "<!?" in t:
					print("# there is <!? in text, did you mean: <?!")
				sys.exit(1)
			if p0 > 0: r += _marky_code_text(t[p:p0])
			p1 = t.find("?>", p0)
			if p1 > -1:
				code = t[p0+2:p1]
				r += _marky_paste_code(code)
				p = p1 + 2
			else:
				print("# ERROR", "missing ?>")
				sys.exit(1)
		else:
			r += _marky_code_text(t[p:])
			break
	for a, b, c, count in [
		("", "<%s?", "", 1),
		("", "?%s>", "", 1),
		("", "{%s", "{", 3),
		("}", "%s}", "", 3)
	]:
		for j in reversed(range(1, count+1)):
			for i in range(3):
				X = "\\"*(i + 1)
				Y = "\\"*(i + 0)
				r = r.replace(a + (b % X)*j + c, a + (b % Y)*j + c)
	open(_MARKY_BUILD_DIR + inbase + ".py", "w").write(r)
	try:
		old_val = _MARKY_EXEC_GLOBALS["__marky__"]
		_MARKY_EXEC_GLOBALS["__marky__"] = run
		exec(r, _MARKY_EXEC_GLOBALS, None)
		_MARKY_EXEC_GLOBALS["__marky__"] = old_val
	except Exception as ex:
		_marky_print_trace(ex, meta_lines, r)
		sys.exit(1)

def _marky_print_trace(ex, mlines, code):
	print("# TRACEBACK")
	import traceback
	traceback.print_tb(ex.__traceback__)
	if hasattr(ex, "filename") and ex.filename == "<string>":
		print("# ERROR LOCATION")
		code = code.split("\n")
		print(len(code))
		for i in range(max(0, ex.lineno-5), min(len(code), ex.lineno+5)):
			print("*" if i + 1 == ex.lineno else " ", "%03d" % i, code[i])
	print("# PYTHON ERROR")
	print(type(ex), str(ex))

########################################################################

def _marky_meta_link(front, link):
	flink = {}
	try:
		for k, v in front.items():
			if "--" in k: continue
			if not k in flink:
				flink[k] = v
			else:
				print("<!-- field exists, skip yaml %s --!>" % k)
		for k, v in front.items():
			if not "--" in k: continue
			x = k.split("--")
			if x[-1] in _MARKY_FORMAT:
				if x[-1] == link:
					k = "--".join(x[0:-1])
					if k in flink:
						print("<!-- field link, merge yaml %s --!>" % k)
						if type(v) is list: flink[k].extend(v)
						if type(v) is dict: flink[k].update(v)
						if type(v) is str: flink[k] += " " + v
						else: flink[k] = v
					else:
						print("<!-- field link, set yaml %s --!>" % k)
						flink[k] = v
	except Exception as ex:
		print("# META LINK ERROR", type(ex), str(ex))
		sys.exit(1)
	return flink

def _marky_link(front, md_text, link):
	md_text = md_text.replace(".???", "." + link)
	md_text = md_text.replace(r".\???", r".???")
	md_text = md_text.replace(r".\\???", r".\???")
	lsep = 3
	len_args = len(link) + 1
	c = 0
	newtext = ""
	p = md_text.find("<<?")
	while p >= 0:
		q = md_text.find("?>>", p + lsep)
		if q > 0:
			newtext += md_text[c:p]
			expr = md_text[p+lsep:q]
			if expr.startswith(link) and expr.endswith(link):
				newtext += expr[len_args:-len_args]
			c = q + lsep
			p = md_text.find("<<?", c)
		else:
			p = md_text.find("<<?", p + lsep)
	newtext += md_text[c:]
	flink = _marky_meta_link(front, link)
	return _marky_front_join(flink, newtext)

def _marky_write_build(inbase, outdir, front, mark):
	os.makedirs(_MARKY_BUILD_DIR + outdir, exist_ok=True)
	open(_MARKY_BUILD_DIR + inbase + ".deps", "w").write("\n".join(list(set(_MARKY_INCLUDE_LIST[1:]))))
	if not mark is None:
		open(_MARKY_BUILD_DIR + inbase + ".md", "w").write(_marky_front_join(front, mark))
		for fmt in _MARKY_FORMAT:
			open(_MARKY_BUILD_DIR + inbase + "." + fmt + ".md", "w").write(_marky_link(front, mark, fmt))

	with open(_MARKY_BUILD_DIR + inbase + ".make", "w") as fhnd:
		fhnd.write(f"""# auto-generated
all_md:=$(all_md) {_MARKY_MD_DIR+inbase}.md

{_MARKY_BUILD_DIR+inbase}.md: {_MARKY_MD_DIR+inbase}.md $(file < {_MARKY_BUILD_DIR+inbase}.deps)
	mkdir -p "{_MARKY_BUILD_DIR+outdir}"
	ln -snf ../{_MARKY_DATA_DIR} {_MARKY_BUILD_DIR+_MARKY_DATA_DIR}
	ln -snf ../{_MARKY_DATA_DIR} {_MARKY_MD_DIR+_MARKY_DATA_DIR}
	./marky.py --base="{inbase}.md"

.PHONY: build/{inbase}
build/{inbase}: {_MARKY_BUILD_DIR+inbase}.md

all_build:=$(all_build) build/{inbase}
"""
		)
		if "pdf" in _MARKY_FORMAT:
			fhnd.write(f"""
{_MARKY_BUILD_DIR+inbase}.tex: {_MARKY_BUILD_DIR+inbase}.pdf.md {_MARKY_MD_DIR+inbase}.md
	mkdir -p "{_MARKY_BUILD_DIR+outdir}"
	./pandoc-run tex {_MARKY_BUILD_DIR+inbase}.pdf.md {_MARKY_BUILD_DIR+inbase}.tex

all_tex:=$(all_tex) {_MARKY_BUILD_DIR+inbase}.tex
"""
			)
		for fmt in _MARKY_FORMAT:
			fhnd.write(f"""
{_MARKY_BUILD_DIR+inbase}.{fmt}.md: {_MARKY_BUILD_DIR+inbase}.md

{fmt}/{inbase}.{fmt}: {_MARKY_BUILD_DIR+inbase}.{fmt}.md {_MARKY_MD_DIR+inbase}.md
	mkdir -p "{fmt}/{outdir}"
	./pandoc-run {fmt} {_MARKY_BUILD_DIR+inbase}.{fmt}.md {fmt}/{inbase}.{fmt}

.PHONY: {fmt}/{inbase}
{fmt}/{inbase}: {fmt}/{inbase}.{fmt}

all_{fmt}:=$(all_{fmt}) {fmt}/{inbase}.{fmt}
"""
			)

########################################################################

def _marky_pack_b64enc(x, n=72):
	x = base64.b64encode(bytes(x, "utf-8")).decode("ascii")
	return "\n".join([x[i:i+n] for i in range(0, len(x), n)])

def _marky_pack_b64dec(x):
	return base64.b64decode(bytes(x.replace("\n", ""), "ascii")).decode("utf-8")

def _marky_load_pack(i):
	return _marky_pack_b64dec(eval("pack_" + i.split("/")[-1].replace(".", "_").replace("-", "_")))

def _marky_pack_write_file(fname, force=False):
	if not os.path.exists(fname) or force:
		print("# WRITE", fname)
		open(fname, "w").write(_marky_load_pack("./" + fname))
	else:
		print("# EXISTS", fname)

def _marky_store_pack(i, ftext):
	return "pack_%s = '''\n%s\n'''\n" % (i.split("/")[-1].replace(".", "_").replace("-", "_"), _marky_pack_b64enc(ftext))

def _marky_pack_read_file(fname):
	return _marky_store_pack("./" + fname, open(fname, "r").read())

########################################################################

_MARKY_FORMAT = ["html", "pdf"]
_MARKY_BUILD_DIR = "build/"  #< WITH trailing /
_MARKY_MD_DIR = "md/"  #< WITH trailing /
_MARKY_DATA_DIR = "data" #< no trailing /
_MARKY_PACK_DIRS = [
	_MARKY_BUILD_DIR,
	_MARKY_DATA_DIR,
	_MARKY_MD_DIR
]
_MARKY_PACK_FILES = [
	"Makefile",
	"pandoc-run",
	"md/marky.md",
	"data/marky.bib",
	".gitignore"
]
_MARKY_EXEC_QUIET = False
_MARKY_EXEC_TEXT = list()
_MARKY_EXEC_APPEND = False
_MARKY_EXEC_GLOBALS = dict()
_MARKY_EXEC_GLOBALS["___"] = _marky_mdtext_print
_MARKY_EXEC_GLOBALS["fmtcode"] = _marky_fmtcode
_MARKY_EXEC_GLOBALS["__marky__"] = True
_MARKY_META_DICT = dict()
_MARKY_INCLUDE_LIST = list()
_MARKY_PASTE_CODE = list()

########################################################################

if __name__ == "__main__":

	parser = argparse.ArgumentParser(add_help=False)

	parser.add_argument("--version", action='store_true', help="version is v" + ".".join([str(i) for i in _MARKY_VERSION]))
	parser.add_argument("--help", action='store_true', help="show this help message")
	parser.add_argument("--base", type=str, default="", help="path to input markdown text")
	parser.add_argument("--init", action='store_true', help="create dirs (" + ", ".join(_MARKY_PACK_DIRS) + ") and files (" + ", ".join(_MARKY_PACK_FILES) + ")")
	parser.add_argument("--force", action='store_true', help="force overwrite of files for --init/--pack")
	parser.add_argument("--pack", action='store_true', help="pack files (" + ", ".join(_MARKY_PACK_FILES) + ") into marky.py.pack source")
	parser.add_argument("--scan", action='store_true', help="create build/*.make from md/*.md")
	parser.add_argument("--quiet", action='store_true', help="do not show Markdown output")

	# ~ args, uargs = parser.parse_known_args()
	args = parser.parse_args()

	sys.path.append("/".join(sys.argv[0].split("/")[0:-1]) + "/lib")

########################################################################

	if args.version:
		print(".".join([str(i) for i in _MARKY_VERSION]))
		sys.exit(0)
	elif args.help or len(sys.argv) == 1:
		parser.print_help()
		sys.exit(0)
	elif args.init:
		for i in _MARKY_PACK_DIRS:
			if not os.path.exists(i):
				print("# MKDIR", i)
				os.mkdir(i)
			else:
				print("# EXISTS", i)
		for i in _MARKY_PACK_FILES:
			_marky_pack_write_file(i, args.force)
		print("# USAGE")
		print("make help")
		sys.exit(0)
	elif args.pack:
		print("# PACK", ", ".join(_MARKY_PACK_FILES))
		marky_text = open(sys.argv[0], "r").read()
		head, src, tail = tuple(marky_text.split("\n###!!!:::marky_pack_data:::!!!###\n"))
		src = "".join([_marky_pack_read_file(i) for i in _MARKY_PACK_FILES])
		marky_text = "\n###!!!:::marky_pack_data:::!!!###\n".join([head, src, tail])
		open(sys.argv[0] + ".pack", "w").write(marky_text)
		if args.force:
			print("# UPDATE OF `marky` FORCED")
			print("# -----------------------")
			print("# mv marky.py.pack marky.py")
			print("# chmod 775 marky.py")
			os.replace("marky.py.pack", "marky.py")
			os.chmod("marky.py", 0o775)
		else:
			print("# MANUAL UPDATE NEEDED")
			print("# --------------------")
			print("mv marky.py.pack marky.py")
			print("chmod +x marky.py")
		sys.exit(0)
	elif args.scan:
		for i in glob.glob("md/**/*.md", recursive=True):
			inbase = i[3:-3]
			outdir = "/".join(inbase.split("/")[0:-1])
			print("# WRITE", _MARKY_BUILD_DIR + inbase + ".make")
			_marky_write_build(inbase, outdir, None, None)
		sys.exit(0)
		pass
	elif args.force:
		print("# ERROR", "--force can only be used with --pack/--init")
		sys.exit(1)
	elif args.quiet:
		_MARKY_EXEC_QUIET = True

########################################################################

	infile = _MARKY_MD_DIR + args.base
	if len(args.base) == 0:
		print("# ERROR", "empty base: use --base file.md")
		sys.exit(1)
	if not os.path.exists(infile):
		print("# ERROR", "wrong base %s: file not found %s" % (args.base, infile))
		sys.exit(1)
	inbase = args.base if not "." in args.base.split("/")[-1] else ".".join(args.base.split(".")[0:-1])
	outdir = "/".join(inbase.split("/")[0:-1])

	if os.path.exists(_MARKY_BUILD_DIR):
		_marky_run(infile, inbase)
		mark = "\n".join(_MARKY_EXEC_TEXT)
		_marky_write_build(inbase, outdir, _MARKY_META_DICT, mark)
	else:
		print("# ERROR", "no build dir: mkdir build")
		sys.sys.exit(1)
