#!/usr/bin/env python3
# -*- coding: utf-8 -*-

########################################################################
# marky Markdown Preprocessor ###########################################
########################################################################

# Quick Make Example Project
############################
#
#  > mkdir project
#  > cp /path/to/marky.py project
#  > cd project
#  > chmod +x marky.py
#  > ./marky.py --init
#  > make scan html-all pdf-all httpd
#
# Open: project/pdf/*.pdf
# Goto: http://localhost:8000/

########################################################################

import sys
import argparse
import glob
import os
import base64
import yaml

########################################################################

if not sys.version_info.major == 3 and sys.version_info.minor >= 6:
	try:
		raise ValueError("marky requires Python 3.6 or higher.")
	except Exception as ex:
		print("# ERROR", type(ex), str(ex))
		sys.exit(1)

########################################################################

_MARKY_VERSION = (0, 9)

########################################################################
# SECTION IS AUTO-PACKAGED USING ./marky.py --pack --force
########################################################################
###!!!:::marky_pack_data:::!!!###
pack_Makefile = '''
IyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMj
IyMjIyMjIyMjIyMjIyMjIyMjCgouUEhPTlk6IGhlbHAKaGVscDoKCSMgbWFya3kgREVQRU5E
RU5DSUVTCgkjIyMjIyMjIyMjIyMjIyMjIyMjIwoJIyAqIHBhbmRvYyA+PSAyLjEwCgkjICog
cGlwIGluc3RhbGwgcGFuZG9jLWZpZ25vcwoJIyAqIHBpcCBpbnN0YWxsIHBhbmRvYy1lcW5v
cwoJIyAqIHBpcCBpbnN0YWxsIHBhbmRvYy1zZWNub3MKCSMgKiBwaXAgaW5zdGFsbCBwYW5k
b2MtdGFibGVub3MKCSMgKiBwaXAgaW5zdGFsbCBwYW5kb2MteG5vcwoJIyAqIHBpcCBpbnN0
YWxsIHB5eWFtbAoJIwoJIyBBVFRFTlRJT04KCSMjIyMjIyMjIyMjCgkjIEFsbCBmaWxlcyBp
biBgYnVpbGQvKi5tZGAgYW5kIGBodG1sLyouaHRtbGAgYXJlIGF1dG8tZ2VuZXJhdGVkIQoJ
IyBVc2VyIGZpbGVzIGAqLm1kYCBoYXZlIHRvIGJlIHBsYWNlZCBpbiBgbWQvKi5tZGAhCgkj
IGBtYWtlIGNsZWFuYCBkZWxldGVzIGFsbCBmaWxlcyBpbiBgYnVpbGQvYCwgYGh0bWwvYCBh
bmQgYHBkZi9gLgoJIwoJIyBtYXJreSBVVElMUwoJIyMjIyMjIyMjIyMjIwoJIyAqIG1ha2Ug
aGVscCAgICAgICAgICAgIC0gc2hvdyB0aGlzICpIZWxwIE1lc3NhZ2UqCgkjICogbWFrZSB0
cmVlICAgICAgICAgICAgLSBzaG93IHRoZSAqUHJvamVjdCBUcmVlKgoJIyAqIG1ha2UgaHR0
cGQgICAgICAgICAgIC0gcnVuIHB5dGhvbiAtbSBodHRwZC5zZXJ2ZXIgaW4gYGh0bWwvYAoJ
IyAqIG1ha2UgY2xlYW4gICAgICAgICAgIC0gZGVsZXRlOiBgYnVpbGQvKmAsIGBodG1sLypg
LCBgcGRmLypgCgkjICogbWFrZSBzY2FuICAgICAgICAgICAgLSBidWlsZCBtYWtlIGRlcHM6
IGBidWlsZC8qLm1ha2VgCgkjICogbWFrZSBsaXN0ICAgICAgICAgICAgLSBsaXN0IGFsbCBz
Y2FubmVkIGZpbGVzIGFuZCB0YXJnZXRzCgkjCgkjIG1hcmt5IEJVSUxEIEFMTAoJIyMjIyMj
IyMjIyMjIyMjIyMKCSMgKiBtYWtlIGJ1aWxkICAgICAgICAgICAtPiBgYnVpbGQvKi57aHRt
bCxwZGZ9Lm1kYAoJIyAqIG1ha2UgdGV4ICAgICAgICAgICAgIC0+IGBidWlsZC8qLnRleGAK
CSMgKiBtYWtlIGh0bWwgICAgICAgICAgICAtPiBgaHRtbC8qLmh0bWxgCgkjICogbWFrZSBw
ZGYgICAgICAgICAgICAgLT4gYHBkZi8qLnBkZmAKCSMgKiBtYWtlIGFsbCAgICAgICAgICAg
ICAtPiBgaHRtbC8qLmh0bWxgLCBgcGRmLyoucGRmYAoJIwoJIyBtYXJreSBCVUlMRCBGSUxF
CgkjIyMjIyMjIyMjIyMjIyMjIyMKCSMgKiBtYWtlIGJ1aWxkL2ZpbGUgICAgICAtPiBgYnVp
bGQvZmlsZS57aHRtbCxwZGZ9Lm1kYAoJIyAqIG1ha2UgYnVpbGQvZmlsZS50ZXggIC0+IGBi
dWlsZC9maWxlLnRleGAKCSMgKiBtYWtlIGh0bWwvZmlsZSAgICAgICAtPiBgaHRtbC9maWxl
Lmh0bWxgCgkjICogbWFrZSBwZGYvZmlsZSAgICAgICAgLT4gYHBkZi9wZGYuaHRtbGAKCSMK
CSMgRVhBTVBMRQoJIyMjIyMjIyMjCgkjIDEuIHJ1biBgbWFrZSBzY2FuOyBtYWtlIGh0bWwv
ZmlsZS5odG1sIGh0dHBkYDoKCSMgICAgKiBnZW5lcmF0ZSBgYnVpbGQvZmlsZS5tYWtlYAoJ
IyAgICAqIHRyYW5zZm9ybSBgbWQvZmlsZS5tZGAgLT4gYGh0bWwvZmlsZS5odG1sYAoJIyAg
ICAqIHN0YXJ0IGEgcHl0aG9uIGh0dHBkIHNlcnZlciBpbiBgaHRtbGAKCSMgMi4gcnVuIGBt
YWtlIHNjYW47IG1ha2UgcGRmL2ZpbGUucGRmYAoJIyAgICAqIGdlbmVyYXRlIGBidWlsZC9m
aWxlLm1ha2VgCgkjICAgICogdHJhbnNmb3JtIGBtZC9maWxlLm1kYCAtPiBgcGRmL2ZpbGUu
cGRmYAoJIwoKLlBIT05ZOiB0cmVlCnRyZWU6CgkjIFBST0pFQ1QgVFJFRQoJIyMjIyMjIyMj
IyMjIyMKCSMgPHdvcmtpbmdfZGlyPgoJIyB8LSBtYXJreS5weSAgICAgICAgICAgIC0gbWFy
a3kgZXhlY3V0YWJsZQoJIyB8LSBNYWtlZmlsZSAgICAgICAgKCopIC0gbWFya3kgTWFrZWZp
bGUKCSMgfC0gcGFuZG9jLXJ1biAgICAgICgqKSAtIHBhbmRvYyB3cmFwcGVyCgkjIHwtIG1k
LyAgICAgICAgICAgICAoKikgLSB1c2VyIE1hcmtkb3duIGRpcgoJIyB8ICB8LSAqLm1kICAg
ICAgICAgICAgIC0gdXNlciBNYXJrZG93biB0ZXh0CgkjIHwtIGRhdGEvICAgICAgICAgICAo
KikgLSB1c2VyIGRhdGEgZGlyCgkjIHwgIHwtICouKiAgICAgICAgICAgICAgICB1c2VyIGRh
dGEgZmlsZXMKCSMgfC0gYnVpbGQvICAgICAgICAgICgqKSAtIGJ1aWxkIE1hcmtkb3duIGRp
cgoJIyB8ICB8LSAqLnB5ICAgICAgICAgKCopIC0gTWFya2Rvd24gbWFya3kgY29kZQoJIyB8
ICB8LSAqLm1ha2UgICAgICAgKCopIC0gTWFrZWZpbGUgcnVsZXMKCSMgfCAgfC0gKi5odG1s
Lm1kICAgICgqKSAtIE1hcmtkb3duIGZvciBodG1sIGZvcm1hdAoJIyB8ICB8LSAqLnBkZi5t
ZCAgICAgKCopIC0gTWFya2Rvd24gZm9yIHBkZiBmb3JtYXQKCSMgfC0gaHRtbC8qLmh0bWwg
ICAgICgqKSAtIHJlbmRlcmVkIGh0bWwgZGlyCgkjIHwtIHBkZi8qLnBkZiAgICAgICAoKikg
LSByZW5kZXJlZCBwZGYgZGlyCgkjCgkjICgqKSBkaXJlY3Rvcmllcy9maWxlcyBhcmUgYXV0
by1nZW5lcmF0ZWQgdXNpbmcKCSMgICAgYC4vbWFya3kucHkgLS1pbml0OyBtYWtlIHNjYW47
IG1ha2UgYWxswrQKCSMKCi5QSE9OWTogY2xlYW4KY2xlYW46CglybSAtcmYgLi9idWlsZC8q
IC4vaHRtbC8qIC4vcGRmLyoKCi5QSE9OWTogaHR0cGQKaHR0cGQ6CgljZCBodG1sICYmIHB5
dGhvbiAtbSBodHRwLnNlcnZlcgoKLlBIT05ZOiBzY2FuCnNjYW46CgkuL21hcmt5LnB5IC0t
c2NhbgoKIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMj
IyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjCgphbGxfbWQ6PQphbGxfYnVpbGQ6PQphbGxfaHRt
bDo9CmFsbF9wZGY6PQphbGxfdGV4Oj0KCi1pbmNsdWRlIGJ1aWxkLyoubWFrZSBidWlsZC8q
Ki8qLm1ha2UKCiMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMj
IyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIwoKLlBIT05ZOiBsaW5rCmJ1aWxkOiAkKGFs
bF9idWlsZCkKCi5QSE9OWTogaHRtbApodG1sOiAkKGFsbF9odG1sKQoKLlBIT05ZOiBwZGYK
cGRmOiAkKGFsbF9wZGYpCgouUEhPTlk6IHRleAp0ZXg6ICQoYWxsX3RleCkKCi5QSE9OWTog
YWxsCmFsbDogaHRtbCBwZGYKCi5QSE9OWTogbGlzdApsaXN0OgoJIyBtYXJreSBUQVJHRVRT
CgkjIyMjIyMjIyMjIyMjIyMKCSMgKiBgbWFrZSBzY2FuYCAtLSBGSUxFUzokKGFsbF9tZCkK
CSMgKiBgbWFrZSBidWlsZGAgLS0gYG1ha2UkKGFsbF9idWlsZClgCgkjICogYG1ha2UgaHRt
bGAgLS0gYG1ha2UkKGFsbF9odG1sKWAKCSMgKiBgbWFrZSBwZGZgIC0tIGBtYWtlJChhbGxf
cGRmKWAKCSMgKiBgbWFrZSB0ZXhgIC0tIGBtYWtlJChhbGxfdGV4KWAKCSMK
'''
pack_pandoc_run = '''
IyEvYmluL2Jhc2gKClsgJCMgPT0gMCBdICYmIGVjaG8gIiIiCiMgVXNhZ2U6ICQwOiA8Rk9S
TUFUPiA8SU5GSUxFPiA8T1VURklMRT4KIyBFeGFtcGxlOgojICQwIGh0bWwgYnVpbGQvZmls
ZS5odG1sLm1kIGh0bWwvZmlsZS5odG1sCiMgJDAgcGRmIGJ1aWxkL2ZpbGUucGRmLm1kIHBk
Zi9maWxlLnBkZgoiIiIgJiYgZXhpdCAxCgpQQU5ET0M9cGFuZG9jCgpNREVYVD1cCmFsbF9z
eW1ib2xzX2VzY2FwYWJsZStcCmludHJhd29yZF91bmRlcnNjb3JlcytcCmVzY2FwZWRfbGlu
ZV9icmVha3MrXApzcGFjZV9pbl9hdHhfaGVhZGVyK1wKbGlzdHNfd2l0aG91dF9wcmVjZWRp
bmdfYmxhbmtsaW5lK1wKaW5saW5lX2NvZGVfYXR0cmlidXRlcytcCnN0cmlrZW91dCtcCnlh
bWxfbWV0YWRhdGFfYmxvY2srXApwaXBlX3RhYmxlcytcCmxpbmVfYmxvY2tzK1wKaW1wbGlj
aXRfZmlndXJlcytcCmFiYnJldmlhdGlvbnMrXAppbmxpbmVfbm90ZXMKClBET1BUPSIiIgot
LXRhYmxlLW9mLWNvbnRlbnRzCi0tbnVtYmVyLXNlY3Rpb25zCiIiIgoKaWYgWyAkMSA9PSBo
dG1sIF0gOyB0aGVuCiRQQU5ET0MgIiQyIiBcCi0tZmlsdGVyIHBhbmRvYy14bm9zIFwKLS1j
aXRlcHJvYyBcCi0tZnJvbT1tYXJrZG93bityYXdfaHRtbCskTURFWFQgXAotLXRvPWh0bWw1
IFwKLS1zZWxmLWNvbnRhaW5lZCBcCi0tb3V0cHV0PSIkMyIgXAotLXJlc291cmNlLXBhdGg9
Ii4vYnVpbGQvIiBcCiRQRE9QVApmaQoKaWYgWyAkMSA9PSBwZGYgXSA7IHRoZW4KJFBBTkRP
QyAiJDIiIFwKLS1maWx0ZXIgcGFuZG9jLXhub3MgXAotLWNpdGVwcm9jIFwKLS1mcm9tPW1h
cmtkb3duK3Jhd190ZXgrJE1ERVhUIFwKLS10bz1sYXRleCBcCi0tb3V0cHV0PSIkMyIgXAot
LXJlc291cmNlLXBhdGg9Ii4vYnVpbGQvIiBcCi0tcGRmLWVuZ2luZT14ZWxhdGV4IFwKJFBE
T1BUCmZpCgppZiBbICQxID09IHRleCBdIDsgdGhlbgokUEFORE9DICIkMiIgXAotLWZpbHRl
ciBwYW5kb2MteG5vcyBcCi0tY2l0ZXByb2MgXAotLWZyb209bWFya2Rvd24rcmF3X3RleCsk
TURFWFQgXAotLXRvPWxhdGV4IFwKLS1vdXRwdXQ9IiQzIiBcCi0tcmVzb3VyY2UtcGF0aD0i
Li9idWlsZC8iIFwKJFBET1BUCmZpCg==
'''
pack_marky_md = '''
LS0tCnRpdGxlOiAiYG1hcmt5YCBEb2N1bWVudGF0aW9uICIKdGl0bGUtLXBkZjogIi0tIGBw
ZGZgIgp0aXRsZS0taHRtbDogIi0tIGBodG1sYCIKYmlibGlvZ3JhcGh5OiBkYXRhL21hcmt5
LmJpYgpoZWFkZXItaW5jbHVkZXMtLXBkZjogPgogICBcaHlwZXJzZXR1cHtjb2xvcmxpbmtz
PWZhbHNlLAogICBhbGxib3JkZXJjb2xvcnM9ezAgMCAwfSwKICAgcGRmYm9yZGVyc3R5bGU9
ey9TL1UvVyAxfX0KaGVhZGVyLWluY2x1ZGVzLS1odG1sOiA+CiAgIDxzdHlsZT4qIHsgYm94
LXNpemluZzogYm9yZGVyLWJveDsgfTwvc3R5bGU+Cnhub3MtY2xldmVyZWY6IHRydWUKeG5v
cy1jYXBpdGFsaXNlOiB0cnVlCmZvbnRzaXplOiAxMXB0CgotLS0KPD8KY29sID0gZm10Y29k
ZSgKCWh0bWw9IjxzcGFuIHN0eWxlPSdjb2xvcjp7MX07Jz57MH08L3NwYW4+IiwKCXBkZj1y
Ilx0ZXh0Y29sb3J7e3sxfX19e3t7MH19fSIKKQpkZWYgdGV4dF9wcm9jKGNtZCwgY3JvcD1U
cnVlKToKCWltcG9ydCBzdWJwcm9jZXNzIGFzIHNwCgl0ZXh0ID0gIiIKCWZvciBpIGluIHNw
LmNoZWNrX291dHB1dChjbWQuc3BsaXQoKSkuZGVjb2RlKCJ1dGYtOCIpLnNwbGl0KCJcbiIp
OgoJCWlmIG5vdCBjcm9wOgoJCQl0ZXh0ICs9IGkgKyAiXG4iCgkJZWxpZiBpLnN0YXJ0c3dp
dGgoIiMgIik6CgkJCXRleHQgKz0gaVsyOl0gKyAiXG4iCgkJZWxpZiBpID09ICIjIjoKCQkJ
dGV4dCArPSAiXG4iCgkJZWxpZiBpLnN0YXJ0c3dpdGgoIiMiKToKCQkJdGV4dCArPSBpICsg
IlxuIgoJcmV0dXJuIHRleHQKdmVyc2lvbiA9IHRleHRfcHJvYygicHl0aG9uIG1hcmt5LnB5
IC0tdmVyc2lvbiIsIGNyb3A9RmFsc2UpLnN0cmlwKCkKPz4KLS0tCgo+ICoqQWJzdHJhY3Qq
KiAtLSBgbWFya3lgIGlzIGEgcHJlcHJvY2Vzc29yIHdpdGggYW4gZWFzeSBhbmQgaW50dWl0
aXZlCj4gc3ludGF4IGZvciBleGVjdXRpb24gb2YgZW1iZWRkZWQge3tjb2woInB5aG9uIiwi
Ymx1ZSIpfX0gY29kZSBkdXJpbmcgcmVuZGVyaW5nCj4gYGh0bWxgIGFuZCBgcGRmYCBkb2N1
bWVudHMgZnJvbSBNYXJrZG93biB0ZXh0Lgo+IFRoaXMgZG9jdW1lbnQgaXMgY3JlYXRlZCB1
c2luZyBgbWFya3lgLCB2ZXJzaW9uICp7e3ZlcnNpb259fSouCj4gRm9yIG1vcmUgaW5mb3Jt
YXRpb24gcGxlYXNlIHJlZmVyIHRvIHRoZQo+IFtgbWFya3lgIHJlcG9zaXRvcnldKGh0dHBz
Oi8vZ2l0aHViLmNvbS9sZWhtYW5uNy9tYXJreSkuCgotLS0KCiMgYG1hcmt5YCBEeW5hbWlj
IE1hcmtkb3duCgpgbWFya3lgIGlzIGEgTWFya2Rvd24gcHJlcHJvY2Vzc29yIHdoaWNoIHRy
YW5zZm9ybXMgYSBNYXJrZG93biBkb2N1bWVudAp1c2luZyBweXRob24uIGBtYXJreWAgaW1w
bGVtZW50cyB0aHJlZSBzdGF0ZW1lbnRzIHdpdGggZXh0cmVtZWx5IGVhc3kKYW5kIGludHVp
dGl2ZSBzeW50YXgsIHdoaWNoIGFyZSBlbWJlZGRlZCBkaXJlY3RseSBpbiB0aGUgTWFya2Rv
d24gdGV4dDoKCjEuIGA8XD8uLi4/XD5gOiBQeXRob24gY29kZSBibG9jay4KMi4gYHtcey4u
Ln1cfWA6IGBmYC1zdHJpbmcgb3V0cHV0IGludG8gTWFya2Rvd24uCjMuIGBfX18oKWA6IEZ1
bmN0aW9uIGZvciBvdXRwdXQgaW50byBNYXJrZG93bi4KClVzaW5nIGA8XD8uLi4/XD5gIGFu
ZCBge1x7Li4ufVx9YCBweXRob24gcHJvY2Vzc2luZyBhbmQgYGZgLXN0cmluZyBvdXRwdXQK
aXMgZW1iZWRkZWQgZGlyZWN0bHkgaW5zaWRlIHRoZSBNYXJrZG93biB0ZXh0LiBVc2luZyB0
aGUgYF9fXygpYApmdW5jdGlvbiB0ZXh0IGlzIGdlbmVyYXRlZCBmcm9tIHB5dGhvbiBhbGdv
cml0aG1zIGFuZApkeW5hbWljYWxseSBpbnNlcnRlZCBpbnRvIHRoZSByZXN1bHRpbmcgTWFy
a2Rvd24uCgpUaGUgZm9sbG93aW5nIGV4YW1wbGUgY2FuIGJlIHByb2R1Y2VkIGJ5IGp1c3Qg
Y2FsbGluZwpgbWFrZSBwZGYvZmlsZWAgb3IgYG1ha2UgaHRtbC9maWxlYC4KCiMjIyMgRXhh
bXBsZTogYG1kL2ZpbGUubWRgIHstfQpgYGBwaHAKLS0tCnRpdGxlOiBBbiBFeGFtcGxlCi0t
LQo8XD8KZGVmIGNhcF9maXJzdCh4KToKCXJldHVybiAiICIuam9pbihbaVswXS51cHBlcigp
ICsgaVsxOl0gZm9yIGkgaW4gaS5zcGxpdCgpXSkKZm9yIGkgaW4gWyJ2ZXJ5IiwgIm5vdCBz
byJdOgoJP1w+Cioqe1x7Y2FwX2ZpcnN0KGkpfVx9IFNlY3Rpb24qKgoKVG8gZGF5IGlzIGEg
e1x7aX1cfSB2ZXJ5IG5pY2UgZGF5LgpUaGUgc3VuIGlzIHNoaW5pbmcge1x7aX1cfSBicmln
aHQgYW5kCnRoZSBiaXJkcyBhcmUgc2luZ2luZyB7XHtpfVx9IGxvdWQgYW5kCmZseSB7XHtp
fVx9IGhpZ2ggaW4gdGhlIHtce2l9XH0gYmx1ZSBza3kuCgk8XD8KP1w+CmBgYAojIyMjIE91
dHB1dCBgYnVpbGQvZmlsZS5tZGAgey19CmBgYG1hcmtkb3duCi0tLQp0aXRsZTogQW4gRXhh
bXBsZQotLS0KPD8KZGVmIGNhcF9maXJzdCh4KToKCXJldHVybiAiICIuam9pbihbaVswXS51
cHBlcigpICsgaVsxOl0gZm9yIGkgaW4gaS5zcGxpdCgpXSkKZm9yIGkgaW4gWyJ2ZXJ5Iiwg
Im5vdCBzbyJdOgoJPz4KKip7e2NhcF9maXJzdChpKX19IFNlY3Rpb24qKgoKVG8gZGF5IGlz
IGEge3tpfX0gdmVyeSBuaWNlIGRheS4KVGhlIHN1biBpcyBzaGluaW5nIHt7aX19IGJyaWdo
dCBhbmQKdGhlIGJpcmRzIGFyZSBzaW5naW5nIHt7aX19IGxvdWQgYW5kCmZseSB7e2l9fSBo
aWdoIGluIHRoZSB7e2l9fSBibHVlIHNreS4KCTw/Cj8+CmBgYAoKIyBIb3cgZG9lcyBgbWFy
a3lgIHdvcmsgaW50ZXJuYWxseT8KCmBtYXJreWAgdXNlcyBhbiBleHRyZW1lbHkgc2ltcGxl
IG1lY2hhbmlzbSBmb3IgZ2VuZXJhdGluZyBhIHB5dGhvbiBwcm9ncmFtbQpmcm9tIHRoZSBN
YXJrZG93biB0ZXh0LiBVc2luZyB0aGUgYDxcPy4uLj9cPmAgYW5kIGB7XHsuLi59XH1gIHN0
YXRlbWVudCwKUHl0aG9uIGNvZGUgaXMgZW1iZWRkZWQgaW50byB0aGUgTWFya2Rvd24gdGV4
dCBhbmQgdHJhbnNsYXRlZCBpbnRvIGEgc2VyaWVzCm9mIGNhbGxzIHRvIHRoZSBgX19fKClg
IGZ1bmN0aW9uIHVzaW5nIGBmYC1zdHJpbmdzIGFzIGFyZ3VtZW50cywgd2hlcmUKcHl0aG9u
IHZhcmlhYmxlcyBhcmUgcmVmZXJlbmNlZC4gVGhpcyByZXN1bHRzIGludG8gYSBweXRob24g
cHJvZ3JhbQp3aGljaCBjYW4gZ2VuZXJhdGUgTWFya2Rvd24gdGV4dCBhbGdvcml0aG1pY2Fs
bHkuCgojIyMjIEV4YW1wbGU6IGBtZC9maWxlLm1kYCB7LX0KYGBgcGhwCiogVGhpcyBpcyB7
Zmlyc3R9LiA8XD8KeCA9IDEgIyB0aGlzIGlzIGNvZGUKZm9yIGkgaW4gcmFuZ2UoMyk6Cglp
ZiB4OgoJCT9cPgp7XHtpKzF9XH0uIFRoZSB2YWx1ZSBpcyB7XHtce3h9XH1cfS4KPFw/Cgll
bHNlOgoJCT9cPntce2krMX1cfS4gVGhlIHZhbHVlIGlzIHplcm8uCjxcPwoJeCA9IDAKP1w+
KiBUaGlzIGlzIGxhc3QuCmBgYApUaGUgZmlsZSBwcm9kdWNlcyB0aGUgZm9sbG93aW5nIE1h
cmtkb3duIG91dHB1dC4KCiMjIyMgT3V0cHV0OiBNYXJrZG93biB7LX0KYGBgYmFzaAoqIFRo
aXMgaXMge2ZpcnN0fS4gPD8KeCA9IDEgIyB0aGlzIGlzIGNvZGUKZm9yIGkgaW4gcmFuZ2Uo
Myk6CglpZiB4OgoJCT8+Cnt7aSsxfX0uIFRoZSB2YWx1ZSBpcyB7e3t4fX19Lgo8PwoJZWxz
ZToKCQk/Pnt7aSsxfX0uIFRoZSB2YWx1ZSBpcyB6ZXJvLgo8PwoJeCA9IDAKPz4qIFRoaXMg
aXMgbGFzdC4KYGBgCgpgbWFya3lgIHRyYW5zZm9ybXMgdGhlIE1hcmtkb3duIGludG8gUHl0
aG9uIHNvdXJjZSBjb2RlLgpFeGVjdXRpb24gb2YgdGhlIFB5dGhvbiBzb3VyY2UgY29kZSB5
aWVsZHMgdGhlIG5ldyBNYXJrZG93biB0ZXh0LgoKIyMjIyBPdXRwdXQ6IGBidWlsZC9maWxl
LnB5YCB7LX0KYGBgcHl0aG9uCl9fXyhyZiIiIiogVGhpcyBpcyB7XHtmaXJzdH1cfS4gIiIi
LCBfX18pOwp4ID0gMSAjIHRoaXMgaXMgY29kZQpmb3IgaSBpbiByYW5nZSgzKToKCWlmIHg6
CgkJX19fKHJmIiIiCntpKzF9LiBUaGUgdmFsdWUgaXMge1x7XHt4fVx9XH0uCiIiIiwgX19f
KTsKCWVsc2U6CgkJX19fKHJmIiIie2krMX0uIFRoZSB2YWx1ZSBpcyB6ZXJvLgoiIiIsIF9f
Xyk7Cgl4ID0gMApfX18ocmYiIiIqIFRoaXMgaXMgbGFzdC4KIiIiLCBfX18pOwpgYGAKCiMg
UXVpY2sgU3RhcnQKCiMjIGBtYXJreWAgRGVwZW5kZW5jaWVzCgpgbWFya3lgIGRlcGVuZHMg
b24gYHBhbmRvY2AgYW5kIGBweXlhbWxgLiBgcGFuZG9jYCBpcyB1c2VkIGZvciByZW5kZXJp
bmcKdGhlIE1hcmtkb3duIGludG8gYGh0bWxgIGFuZCBgcGRmYC4gYG1hcmt5YCB1c2VzCltw
YW5kb2NdKGh0dHBzOi8vd3d3LnBhbmRvYy5vcmcvKSBmb3IgcmVuZGVyaW5nIGBodG1sYCBh
bmQgYHBkZmAuCmBwYW5kb2M+PTIuMTBgIHJlbGVhc2VzIGNhbiBiZSBmb3VuZApbaGVyZV0o
aHR0cHM6Ly9naXRodWIuY29tL2pnbS9wYW5kb2MvcmVsZWFzZXMpLgpUaGUgb3RoZXIgcGFj
a2FnZXMgY2FuIGJlIGluc3RhbGxlZCB3aXRoIGBwaXBgLgoKYGBgYmFzaApwaXAgaW5zdGFs
bCBwYW5kb2MtZmlnbm9zCnBpcCBpbnN0YWxsIHBhbmRvYy1lcW5vcwpwaXAgaW5zdGFsbCBw
YW5kb2Mtc2Vjbm9zCnBpcCBpbnN0YWxsIHBhbmRvYy10YWJsZW5vcwpwaXAgaW5zdGFsbCBw
YW5kb2MteG5vcwpwaXAgaW5zdGFsbCBweXlhbWwKYGBgCgojIyBgbWFya3lgIFdvcmtmbG93
CgpXb3JrZmxvdyBmb3IgY3JlYXRpbmcgYGh0bWxgIG9yIGBwZGZgIHVzaW5nIGBtYXJreWAg
YnkKaW52b2NhdGlvbiBvZiBgbWFrZSBzY2FuYCBhbmQgYG1ha2UgYWxsYC4KCiptYWtlKnwx
LiAqd3JpdGUqICB8ICB8Mi4gKmJ1aWxkKiAgICAgICAgICB8ICB8My4gKnJlbmRlcioKLS0t
LS0tfC0tLS0tLS0tLS0tLXwtLXwtLS0tLS0tLS0tLS0tLS0tLS0tLXwtLXwtLS0tLS0tLS0t
LS0tLS0tCmBwZGZgIHwgICAgICAgICAgICB8ICB8YGJ1aWxkL2ZpbGUuaHRtbC5tZGB8LT58
YGh0bWwvZmlsZS5odG1sYApgLWAgICB8YG1kL2ZpbGUubWRgfC0+fCAgICAgICAgICAgICAg
ICAgICAgfCAgfApgaGZtbGB8ICAgICAgICAgICAgfCAgfGBidWlsZC9maWxlLnBkZi5tZGAg
fC0+fGBwZGYvZmlsZS5wZGZgCgoxLiAqKndyaXRlKio6IHVzZXIgd3JpdGVzIGEgTWFya2Rv
d24gdGV4dCBmaWxlIGFuZCBwbGFjZXMgaXQgaW4gYG1kLyoubWRgCmRpcmVjdG9yeSB3aXRo
IHRoZSBleHRlbnNpb24gYC5tZGAuCjIuICoqYnVpbGQqKjogbWFya3lgIHRyYW5zZm9ybXMg
dGhlIGZpbGVzIGluIGBtZC8qLm1kYCBpbnRvIHJlZ3VsYXIgTWFya2Rvd24gdGV4dAphbmQg
cGxhY2VzIHRoZSB0cmFuc2Zvcm1lZCBmaWxlcyBpbiBgYnVpbGQvYC4KMy4gKipyZW5kZXIq
KjogdGhlIHJlZ3VsYXIgTWFya2Rvd24gdGV4dCBpbiB0aGUgZmlsZXMgYGJ1aWxkLyoubWRg
IGlzIHJlbmRlcmVkIGludG8KYGh0bWxgIGFuZCBgcGRmYCB1c2luZyBgcGFuZG9jYC4KClRo
ZSB0aHJlZSBzdGVwcyBhcmUgaW1wbGVtZW50ZWQgaW4gYSBNYWtlZmlsZS4KCiMjIERvd25s
b2FkIGFuZCBJbml0aWFsaXplCgpgbWFya3lgIGlzIHN1cHBsaWVkIGFzIGEgc2luZ2xlLWZp
bGUgc2NyaXB0IHdoaWNoIGF1dG9tYXRpY2FsbHkKc2V0cyB1cCB0aGUgcHJvamVjdCBzdHJ1
Y3R1cmUgY29udGFpbmluZyBhbGwgc2NyaXB0cwpyZXF1aXJlZCBmb3IgcHJvY2Vzc2luZyBh
bmQgcmVuZGVyaW5nIE1hcmtkb3duLgoKRm9yIGV4YW1wbGUsIGRvd25sb2FkIGBtYXJreWAg
ZnJvbSBnaXRodWIuCmBgYGJhc2gKZ2l0IGNsb25lIGh0dHBzOi8vbGVobWFubjcuZ2l0aHVi
LmNvbS9tYXJreS5naXQKY2QgbWFya3kKYGBgCgpBZnRlciBkb3dubG9hZCwgdGhlIGBtYXJr
eWAgZW52aXJvbm1lbnQgaXMgaW5pdGlhbGl6ZWQgdXNpbmcgYG1hcmt5YC4KYGBgYmFzaAou
L21hcmt5LnB5IC0taW5pdAojIG1rZGlyIGJ1aWxkLwojIG1rZGlyIGRhdGEKIyBta2RpciBt
ZC8KIyBXUklURSBNYWtlZmlsZQojIFdSSVRFIHBhbmRvYy1ydW4KIyBXUklURSBtZC9tYXJr
eS5tZAojIFdSSVRFIC5naXRpZ25vcmUKIyBVU0FHRQptYWtlIGhlbHAKYGBgCgojIyBgbWFy
a3lgIEVudmlyb25tZW50CgpEdXJpbmcgaW5pdGlhbGl6YXRpb24sIGBtYXJreWAgY3JlYXRl
cyBkaXJlY3RvcmllcyBhbmQgZmlsZXMuCkFmdGVyIGluaXRpYWxpemF0aW9uLCB0aGUgZm9s
bG93aW5nIHN0cnVjdHVyZSBpcyBhdXRvLWdlbmVyYXRlZAppbiB0aGUgcHJvamVjdCBkaXJl
Y3RvcnkuIGBtYXJreWAgc2hvd3MgdGhlIHByb2plY3Qgc3RydWN0dXJlCndoZW4gaW52b2tp
bmcgYG1ha2UgdHJlZWAuCmBgYGJhc2gKPD8KX19fKHRleHRfcHJvYygibWFrZSB0cmVlIikp
Cj8+CmBgYAoKVGhlIHNjcmlwdCBgcGFuZG9jLXJ1bmAgY2FuIGJlIGFkanVzdGVkIGluIGNh
c2Ugc3BlY2lmaWMKYHBhbmRvY2Agb3B0aW9ucyBhcmUgcmVxdWlyZWQgZm9yIHJlbmRlcmlu
ZyB0aGUgYGh0bWxgIGFuZCBgcGRmYCBkb2N1bWVudHMuCgojIyBEb2N1bWVudCBSZW5kZXJp
bmcKCkJ5IGludm9raW5nIGBtYWtlIGFsbGAgYWxsIGZpbGVzIGBtZC8qLm1kYCBhcmUgdHJh
bnNmb3JtZWQKaW50byBjb3JyZXNwb25kaW5nIGBodG1sLyouaHRtbGAgYW5kIGBwZGYvKi5w
ZGZgIGZpbGVzLiBCeQppbnZva2luZyBgbWFrZSBodHRwZGAgYSBweXRob24gd2ViIHNlcnZl
ciBpcyBzdGFydGVkIGluIGBodG1sL2AuCgpBbGwgdXNlci1nZW5lcmF0ZWQgTWFya2Rvd24g
Y29udGVudCBnb2VzIGludG8gYG1kLypgIHVzZXItZ2VuZXJhdGVkCmRhdGEgZmlsZXMgZ28g
aW50byBgZGF0YS8qYC4KCioqQVRURU5USU9OOioqIFRoZSBmaWxlcyBpbiB0aGUgZGlyZWN0
b3JpZXMgYGJ1aWxkLypgIGFyZQoqKmF1dG8tZ2VuZXJhdGVkKiouIEFsbCB1c2VyIGZpbGVz
IGhhdmUgdG8gYmUgcGxhY2VkIGluc2lkZSB0aGUKZGlyZWN0b3J5IGBtZC8qYC4gSW52b2tp
bmcgYG1ha2UgY2xlYW5gIHdpbGwgKipkZWxldGUgYWxsIGZpbGVzKioKaW4gYGh0bWwvYCwg
YGJ1aWxkL2AgYW5kIGBwZGYvYC4KCiMjIEludGVncmF0ZWQgRG9jdW1lbnRhdGlvbgoKYG1h
cmt5YCBoYXMgYW4gaW50ZWdyYXRlZCBlbnZpcm9ubWVudC4gVXNpbmcgYG1ha2UgaGVscGAg
ZGlzcGxheXMKYSBzaG9ydCBpbmZvIGFib3V0IHRoZSBgbWFya3lgIGRlcGVuZGVuY2llcywg
bWFrZSB0YXJnZXRzIGFuZApleGFtcGxlcy4KYGBgYmFzaAo8PwpfX18odGV4dF9wcm9jKCJt
YWtlIGhlbHAiKSkKPz4KYGBgCgojIGBtYXJreWAgRmVhdHVyZXMKClBsYWNlIGEgbmV3IGZp
bGUgaW4gYG1kL2ZpbGUubWRgIGFuZCBydW4gdGhlIGZvbGxvd2luZyBjb21tYW5kcy4KYGBg
YmFzaAp0b3VjaCBtZC9maWxlLm1kCmBgYAoKYG1hcmt5YCBkaXNjb3ZlcnMgdGhlIG5ldyBk
b2N1bWVudCB3aGVuIGludm9raW5nIGBtYWtlIHNjYW5gLgpgYGBiYXNoCm1ha2Ugc2Nhbgoj
IFdSSVRFIGJ1aWxkL2ZpbGUubWFrZQpgYGAKCmBtYXJreWAgcmVuZGVycyBgaHRtbGAgYW5k
IGBwZGZgIHVzaW5nIG1ha2UgdGFyZ2V0cy4KYGBgYmFzaAptYWtlIGh0bWwvZmlsZQptYWtl
IHBkZi9maWxlCmBgYAoKIyMgTWV0YSBEYXRhIGluIEZyb250IE1hdHRlcgoKSWYgZG9jdW1l
bnQgc3RhcnRzIHdpdGggYC0tLWAsIHlhbWwgaXMgdXNlZCB0byBwYXJzZQp0aGUgZnJvbnQg
bWF0dGVyIGJsb2NrIGRlbGltaXRlZCBieSBgLS0tYC4KQWxsIG1ldGEgZGF0YSBrZXlzIHdp
bGwgYmUgZXhwb3NlZCBpbnRvIHRoZSBweXRob24gc2NvcGUgYXMgYSBsb2NhbAp2YXJpYWJs
ZSwgdW5sZXNzIHRoZSB2YXJpYWJsZSBhbHJlYWR5IGV4aXN0cy4KCmBgYG1kCi0tLQp0aXRs
ZTogIk15IERvY3VtZXQiCmF1dGhvcjogLi4uCmRhdGU6IDIwMjItMDEtMDEKLS0tClRoZSB0
aXRsZSBvZiB0aGlzIGRvY3VtZW50IGlzIHtce3RpdGxlfVx9LgpgYGAKCiMjIEVtYmVkZGlu
ZyBQeXRob24gQ29kZQoKUHl0aG9uIGNvZGUgYmxvY2tzIGFyZSBlbWJlZGRlZCBpbnRvIE1h
cmtkb3duIHVzaW5nIGA8XD8uLi4/XD5gIGFuZCBge1x7Li4ufVx9YC4KQWxsIGNvZGUgYmxv
Y2tzIHNwYW4gb25lIGxhcmdlIHNjb3BlIHNoYXJpbmcgZnVuY3Rpb25zIGFuZCBsb2NhbAp2
YXJpYWJsZXMuIE1ldGEgZGF0YSBpcyBpbXBvcnRlZCBmcm9tIE1hcmtkb3duIGZyb250IG1h
dHRlciBhcyBsb2NhbAp2YXJpYWJsZXMgaW4gdGhlIHB5dGhvbiBzY29wZS4gVGhlIGBpbXBv
cnRgIHN0YXRlbWVudCBjYW4gYmUgdXNlZCBpbgpweXRob24gY29kZSBpbiBvcmRlciB0byBh
Y2Nlc3MgaW5zdGFsbGVkIHB5dGhvbiBwYWNrYWdlcyBhcyB1c3VhbC4KCiMjIyBWaXNpYmxl
IENvZGUKClVzaW5nIGA8XD8hLi4uP1w+YCBjb2RlIGlzIGV4ZWN1dGVkIGFuZCBhbHNvIHNo
b3duIGluIE1hcmtkb3duLgoKIyMjIyBFeGFtcGxlIHstfQpgYGBweXRob24KPFw/IQp4ID0g
NDIgIyB2aXNpYmxlIGNvZGUKcHJpbnQoIkhlbGxvIGNvbnNvbGUhIikKP1w+CmBgYAoKIyMj
IyBSdW4gYW5kIE91dHB1dCB7LX0KYGBgcHl0aG9uPD8hCnggPSA0MiAjIHZpc2libGUgY29k
ZQpwcmludCgiSGVsbG8gY29uc29sZSEiKQo/PgpgYGAKCioqQVRURU5USU9OOioqIFVzaW5n
IHRoZSBgcHJpbnQoKWAgZnVuY3Rpb24gdGhlIHRleHQgd2lsbCBiZSBwcmludGVkCnRvIHRo
ZSBjb25zb2xlIGFuZCAqKm5vdCoqIGluc2lkZSB0aGUgcmVzdWx0aW5nIE1hcmtkb3duIHRl
eHQuCgojIyMgSGlkZGVuIENvZGUKClVzaW5nIGA8XD8uLi4/XD5gIGNvZGUgaXMgZXhlY3V0
ZWQgYnV0IG5vdCBzaG93biBpbiBNYXJrZG93bi4KCiMjIyMgRXhhbXBsZSB7LX0KYGBgcHl0
aG9uCjxcPwp4ID0gNDEgIyBoaWRkZW4gY29kZQpfX18oZiJPdXRwdXQgdG8gTWFya2Rvd24u
IHggPSB7eH0hIikKP1w+CmBgYAojIyMjIFJ1biBhbmQgT3V0cHV0IHstfQpgYGBweXRob24K
PD8KeCA9IDQxICMgaGlkZGVuIGNvZGUKX19fKGYiT3V0cHV0IHRvIE1hcmtkb3duLiB4ID0g
e3h9ISIpCj8+CmBgYAoKKipBVFRFTlRJT046KiogVXNpbmcgdGhlIGBfX18oKWAgZnVuY3Rp
b24gdGhlIHRleHQgd2lsbCBiZSBwcmludGVkCmluc2lkZSB0aGUgcmVzdWx0aW5nIE1hcmtk
b3duIHRleHQgKiphbmQgbm90Kiogb24gdGhlIGNvbnNvbGUuCgojIyBUaGUgYF9fXygpYCBG
dW5jdGlvbgoKVXNpbmcgdGhlIGBwcmludCgpYCBzdGF0ZW1lbnQgdGhlIHRleHQgd2lsbCBi
ZSBwcmludGVkIHRvIHRoZSBjb25zb2xlLgpXaGVuIHVzaW5nIHRoZSBgX19fKClgIHN0YXRl
bWVudCBuZXcgTWFya2Rvd24gdGV4dCBpcwppbnNlcnRlZCBkeW5hbWljYWxseSBpbnRvIHRo
ZSBkb2N1bWVudCBkdXJpbmcgcHJlcHJvY2Vzc2luZy4KCiMjIyMgRXhhbXBsZTogTGluZSBC
cmVhayB7LX0KYGBgcHl0aG9uCjxcPwp4ID0gNDAgIyBoaWRkZW4gY29kZQpfX18oIk91dHB1
dCBpbiIsIF9fXykKX19fKCJzaW5nbGUgbGluZSEgIiwgX19fKQpfX18oZiJ4ID0ge3h9IikK
P1w+CmBgYAojIyMjIFJ1biBhbmQgT3V0cHV0IHstfQpgYGBiYXNoCjw/CnggPSA0MCAjIGhp
ZGRlbiBjb2RlCl9fXygiT3V0cHV0IGluICIsIF9fXykKX19fKCJzaW5nbGUgbGluZSEgIiwg
X19fKQpfX18oZiJ4ID0ge3h9IikKPz4KYGBgCgojIyMjIEV4YW1wbGU6IFNoaWZ0LCBDcm9w
LCBSZXR1cm4gey19CmBgYHB5dGhvbgo8XD8KcmVzdWx0ID0gX19fKCIiIgogICAqIHRleHQg
aXMgY3JvcHBlZCBhbmQgc2hpZnRlZAogICAgICAgICAqIHNoaWZ0IGFuZCBjcm9wCiAgICAg
ICAgICAgICogY2FuIGJlIGNvbWJpbmVkCiAgICAgICAgICAqIHJldHVybmluZyB0aGUgcmVz
dWx0CiIiIiwgc2hpZnQ9IiMjIyMjIyMjIiwgY3JvcD1UcnVlLCByZXQ9VHJ1ZSkKX19fKHJl
c3VsdCkKP1w+CmBgYAojIyMjIFJ1biBhbmQgT3V0cHV0IHstfQpgYGBiYXNoCjw/CnJlc3Vs
dCA9IF9fXygiIiIKICAgKiB0ZXh0IGlzIGNyb3BwZWQgYW5kIHNoaWZ0ZWQKICAgICAgICAg
KiBzaGlmdCBhbmQgY3JvcAogICAgICAgICAgICAqIGNhbiBiZSBjb21iaW5lZAogICAgICAg
ICAgKiByZXR1cm5pbmcgdGhlIHJlc3VsdAoiIiIsIHNoaWZ0PSIjIyMjIyMjIyIsIGNyb3A9
VHJ1ZSwgcmV0PVRydWUpCl9fXyhyZXN1bHQpCj8+CmBgYAoKIyMgQWxnb3JpdGhtaWMgVGFi
bGUgRXhhbXBsZQoKQHRibDphbGd0IGlzIGdlbmVyYXRlZCB1c2luZyB0aGUgZm9sbG93aW5n
IHB5dGhvbiBjbG9kZSBibG9jay4KCmBgYHB5dGhvbjw/IQpuID0gNQp0YWJsZSA9ICIiCmRl
YyA9IFsiKiVzKiIsICIqKiVzKioiLCAifn4lc35+IiwgImAlc2AiLAogICAgICAgciIkXHRp
bWVzXiVzJCIsICIkXGluZnR5XyVzJCJdCnRhYmxlICs9ICJ8Ii5qb2luKCJYIipuKSArICJc
biIgKyAifCIuam9pbigiLSIqbikgKyAiXG4iCmZvciBpIGluIHJhbmdlKG4pOgoJZmlsbCA9
IFtjaHIob3JkKCJBIikrKDIqaSszKmspJTI2KSBmb3IgayBpbiByYW5nZShpKzEpXQoJZmls
bCA9IFtkZWNbKGwraSklbGVuKGRlYyldJWsgZm9yIGwsIGsgaW4gZW51bWVyYXRlKGZpbGwp
XQoJdGV4dCA9IGxpc3QoIjAiKSpuCgl0ZXh0WyhuPj4xKS0oaT4+MSk6KG4+PjEpKyhpPj4x
KV0gPSBmaWxsCgl0YWJsZSArPSAifCIuam9pbih0ZXh0KSArICJcbiIKPz4KYGBgCgp7e3Rh
YmxlfX0KClRhYmxlOiBUYWJsZSBpcyBnZW5lcmF0ZWQgdXNpbmcgY29kZSBhbmQgdGhlIGBf
X18oKWAgc3RhdGVtZW50LiB7I3RibDphbGd0fQoKIyMgSW5saW5lIEZvcm1hdHRlZCBPdXRw
dXQKClRoZSBge1x7Li4ufVx9YCBzdGF0ZW1lbnQgdXNlcyBzbnRheCBzaW1pbGFyIHRvIHB5
dGhvbiBgZmAtc3RyaW5ncyBmb3IKZm9ybWF0dGVkIG91dHB1dCBvZiB2YXJpYWJsZXMgYW5k
IHJlc3VsdHMgb2YgZXhwcmVzc2lvbnMgaW50byBNYXJrZG93bgp0ZXh0LiBUaGUgYG1hcmt5
YCBvcGVyYXRvciBge1x7PGV4cHJlc3Npb24+Wzo8Zm9ybWF0Pl19XH1gIHVzZXMgdGhlCnN5
bnRheCBvZiBbYGZgLXN0cmluZ3NdKGh0dHBzOi8vZG9jcy5weXRob24ub3JnLzMvcmVmZXJl
bmNlL2xleGljYWxfYW5hbHlzaXMuaHRtbCNmLXN0cmluZ3MpLgoKIyMjIyBFeGFtcGxlIDEg
ey19CmBgYGJhc2gKYHhgIGlzIHtce3h9XH0gYW5kIHtceyIsIi5qb2luKFtzdHIoaSkgZm9y
IGkgaW4gcmFuZ2UoeC0xMCx4KV0pfVx9LgpgYGAKIyMjIyBPdXRwdXQgey19Cj4gYHhgIGlz
IHt7eH19IGFuZCB7eyIsIi5qb2luKFtzdHIoaSkgZm9yIGkgaW4gcmFuZ2UoeC0xMCx4KV0p
fX0uCgojIyMjIEV4YW1wbGUgMiB7LX0KYGBgcHl0aG9uPD8hCnggPSBpbnQoMSkKeSA9IGZs
b2F0KDIuMykKeiA9IDAKYSA9IFsxLCAyLCAzXQpiID0gKDQsIDUpCj8+CmBgYApgYGBtYXJr
ZG93bgpUaGlzIGlzIGEgcGFyYWdyYXBoIGFuZCB4IGlzIHtce3g6MDNkfVx9IGFuZCB5IGlz
IHtce3k6LjJmfVx9LgpPdGhlciBjb250ZW50IGlzOiBhID0ge1x7YX1cfSwgYiA9IHtce2J9
XH0uCmBgYAojIyMjIE91dHB1dCB7LX0KPiBUaGlzIGlzIGEgcGFyYWdyYXBoIGFuZCB4IGlz
IHt7eDowM2R9fSBhbmQgeSBpcyB7e3k6LjJmfX0uCj4gT3RoZXIgY29udGVudCBpczogYSA9
IHt7YX19LCBiID0ge3tifX0uCgojIyBGb3JtYXQgTGluayBFeHRlbnNpb24KCldoZW4gd3Jp
dGluZyBtdWx0aXBsZSBkb2N1bWVudHMsIG9mdGVuIGRvY3VtZW50cyBhcmUgcmVmZXJlbmNl
ZApiZXR3ZWVuIGVhY2ggb3RoZXIgdXNpbmcgbGlua3MuIEluIG9yZGVyIHRvIHJlZmVyIHRv
IGV4dGVybmFsCmBodG1sYCBhbmQgYHBkZmAgZG9jdW1lbnRzIHRoZSBNYXJrZG93biBsaW5r
IHN0YXRlbWVudCBpcyB1c2VkLgpgYGBtZApbTGluayBDYXB0aW9uXShwYXRoL3RvL2ZpbGUu
aHRtbCkKW0xpbmsgQ2FwdGlvbl0ocGF0aC90by9maWxlLnBkZikKYGBgCk9uZSBsaW5rIHN0
YXRlbWVudCBjYW5ub3QgYmUgdXNlZCBmb3IgcmVuZGVyaW5nIGBodG1sYCBhbmQgYHBkZmAK
d2l0aCBjb25zaXN0ZW50IHBhdGhzLiBVc2luZyB0aGUgYG1hcmt5YCBmb3JtYXQgbGluawog
YC5cPz8/YCBmaWxlIGV4dGVuc2lvbiByZXN1bHRzIGluIGNvbnNpc3RlbnQgbGlua3MgZm9y
IGBodG1sYCBhbmQKYHBkZmAgZG9jdW1lbnRzLgoKIyMjIyBFeGFtcGxlIHstfQpgYGBtZApb
TGluayB0byB0aGlzIERvY3VtZW50XShtYXJreS5cPz8/KQpgYGAKIyMjIyBPdXRwdXQgey19
Cj4gW0xpbmsgdG8gdGhpcyBEb2N1bWVudF0obWFya3kuPz8/KQoKIyMgRm9ybWF0IENvZGVz
CgpPZnRlbiB3aGVuIHdyaXRpbmcgbWFya2Rvd24gZm9yIGBodG1sYCBhbmQgYHBkZmAgZG9j
dW1lbnRzLCB0aGUKb3V0cHV0IG5lZWRzIHRvIGJlIHR3ZWFrZWQgYWNjb3JkaW5nbHkuCmBt
YXJreWAgc3VwcG9ydHMgZm9ybWF0IHNwZWNpZmljIHR3ZWFraW5nIGJ5IGluamVjdGluZwpy
YXcgYGh0bWxgIG9yIGB0ZXhgIGNvZGUgaW50byBNYXJrZG93biB1c2luZyBmb3JtYXQgY29k
ZXMuCgpJbiBvcmRlciB0byBpbmplY3QgZm9ybWF0IHNwZWNpZmljIGNvZGUgdGhlIGBmbXRj
b2RlYCBjbGFzcyBpcyB1c2VkLgpUaGUgYGZtdGNvZGVgIGNsYXNzIG1hbmFnZXMgaW5qZWN0
aW9uIG9mIGBodG1sYCBhbmQgYHRleGAgY29kZQpkZXBlbmRpbmcgb24gdGhlIG91dHB1dCBm
b3JtYXQuCgoqKkFUVEVOVElPTjoqKiBgdGV4YCBwYWNrYWdlcyBoYXZlIHRvIGJlIGluY2x1
ZGVkIGZvciBgcGRmYCBhcyB3ZWxsIGFzCkphdmFTY3JpcHQgYW5kIHN0eWxlIHNoZWV0cyBm
b3IgYGh0bWxgIHVzaW5nIHRoZSBtZXRhIGRhdGEgZmllbGRzCmBoZWFkZXItaW5jbHVkZXMt
LXBkZmAgYW5kIGBoZWFkZXItaW5jbHVkZXMtLWh0bWxgIHJlc3BlY3RpdmVseS4KCiMjIyMg
RXhhbXBsZTogYGZtdGNvZGVgIHstfQpgYGBweXRob248PyEKRiA9IGZtdGNvZGUoaHRtbD0i
SDxzdXA+VDwvc3VwPjxzdWI+TTwvc3ViPkwiLCBwZGY9ciJcTGFUZVgiKQo/PgpgYGAKYGBg
bWFya2Rvd24KSW52b2NhdGlvbiBvZiBmb3JtYXQgY29kZSByZXN1bHRzIGluOiB7XHtGKCl9
XH0uCmBgYAojIyMjIE91dHB1dCB7LX0KPiBJbnZvY2F0aW9uIG9mIGZvcm1hdCBjb2RlIHJl
c3VsdHMgaW46IHt7RigpfX0uCgojIyMjIEV4YW1wbGU6IENvbG9yIHstfQpgYGBweXRob248
PyEKQyA9IGxhbWJkYSBjb2xvcjogZm10Y29kZSgKCWh0bWw9IjxzcGFuIHN0eWxlPSdjb2xv
cjolczsnPnswfTwvc3Bhbj4iICUgY29sb3IsCglwZGY9ciJcdGV4dGNvbG9ye3slc319e3t7
MH19fSIgJSBjb2xvcgopCkIgPSBDKCJibHVlIikKUiA9IEMoInJlZCIpCj8+CmBgYApgYGBt
YXJrZG93bgpUZXh0IHdpdGgge1x7QigiYmx1ZSIpfVx9IGFuZCB7XHtSKCJSRUQiKX1cfS4K
YGBgCiMjIyMgT3V0cHV0IHstfQo+IFRleHQgd2l0aCB7e0IoImJsdWUiKX19IGFuZCB7e1Io
IlJFRCIpfX0uCgoKIyMjIyBFeGFtcGxlOiBDbGFzc2VzIHstfQpgYGBweXRob248PyEKY2xh
c3MgY29sb3I6CglkZWYgX19pbml0X18oc2VsZiwgY29sb3IpOgoJCXNlbGYuY29sb3IgPSBj
b2xvcgoJZGVmIHVwcGVyKHNlbGYsIHgpOgoJCXJldHVybiBzZWxmLnRleHQoeC51cHBlcigp
KQoJZGVmIGxvd2VyKHNlbGYsIHgpOgoJCXJldHVybiBzZWxmLnRleHQoeC5sb3dlcigpKQoK
Y2xhc3MgaHRtbChjb2xvcik6CglkZWYgdGV4dChzZWxmLCB4KToKCQlyZXR1cm4gZiI8c3Bh
biBzdHlsZT0nY29sb3I6e3NlbGYuY29sb3J9Oyc+e3h9PC9zcGFuPiIKCmNsYXNzIHBkZihj
b2xvcik6CglkZWYgdGV4dChzZWxmLCB4KToKCQlyZXR1cm4gcmYiXHRleHRjb2xvcnt7e3Nl
bGYuY29sb3J9fX17e3t4fX19IgoKQ0MgPSBsYW1iZGEgeDogZm10Y29kZShodG1sPWh0bWwo
eCksIHBkZj1wZGYoeCkpCkJCID0gQ0MoImJsdWUiKQpSUiA9IENDKCJyZWQiKQo/PgpgYGAK
YGBgbWFya2Rvd24KVGV4dCB3aXRoIHtce0JCLnVwcGVyKCJibHVlIil9XH0gYW5kIHtce1JS
Lmxvd2VyKCJSRUQiKX1cfS4KYGBgCiMjIyMgT3V0cHV0IHstfQo+IFRleHQgd2l0aCB7e0JC
LnVwcGVyKCJibHVlIil9fSBhbmQge3tSUi5sb3dlcigiUkVEIil9fS4KCiMgTWV0YSBEYXRh
IGluIEZyb250IE1hdHRlcgoKTWV0YSBkYXRhIGlzIGFubm90YXRlZCBpbiB0aGUgZnJvbnQg
bWF0dGVyIG9mIGEgCU1hcmtkb3duIHRleHQgZG9jdW1lbnQuClRoZSBmcm9udCBtYXR0ZXIg
bXVzdCBzdGFydCBpbiB0aGUgZmlyc3QgbGluZSB3aXRoIGAtLS1gIGFuZCBwcmVjZWRlcyBh
bGwKb3RoZXIgdGV4dCBiZWluZyBmZW5jZWQgYnkgYC0tLWAuIFRoZSBtZXRhIGRhdGEgaXMg
aW4gYHlhbWxgIGZvcm1hdC4KVGhlIGB5YW1sYCBibG9jayBpcyBwYXJzZWQgdXNpbmcgYHB5
dGhvbi1weXlhbWxgLiBBbGwgbWV0YQpkYXRhIGlzIGltcG9ydGVkIGludG8gdGhlIHByZXBy
b2Nlc3NlZCBkb2N1bWVudC4KCiMjIFBhbmRvYyBGcm9udCBNYXR0ZXIKCiMjIyMgRXhhbXBs
ZSB7LX0KYGBgeWFtbAotLS0KdGl0bGU6IE15IERvY3VtZW50CmRhdGU6IDIwMjItMDEtMDEK
YXV0aG9yOiAuLi4KbGluay1jaXRhdGlvbnM6IHRydWUKYmlibGlvZ3JhcGh5OiBkYXRhL21h
cmt5LmJpYgpoZWFkZXItaW5jbHVkZXM6ID4KICAgXGh5cGVyc2V0dXB7Y29sb3JsaW5rcz1m
YWxzZSwKICAgYWxsYm9yZGVyY29sb3JzPXswIDAgMH0sCiAgIHBkZmJvcmRlcnN0eWxlPXsv
Uy9VL1cgMX1cfQp4bm9zLWNsZXZlcmVmOiB0cnVlCnhub3MtY2FwaXRhbGlzZTogdHJ1ZQpm
b250c2l6ZTogMTFwdAotLS0KYGBgClRoZSBtZXRhIGRhdGEgZmllbGRzCltgdGl0bGVgLCBg
ZGF0ZWAsIGBhdXRob3JgXShodHRwczovL3BhbmRvYy5vcmcvTUFOVUFMLmh0bWwjbWV0YWRh
dGEtdmFyaWFibGVzKSwKW2BsaW5rLWNpdGF0aW9uc2BdKGh0dHBzOi8vcGFuZG9jLm9yZy9N
QU5VQUwuaHRtbCNvdGhlci1yZWxldmFudC1tZXRhZGF0YS1maWVsZHMpLApbYGJpYmxpb2dy
YXBoeWBdKGh0dHBzOi8vcGFuZG9jLm9yZy9NQU5VQUwuaHRtbCNjaXRhdGlvbi1yZW5kZXJp
bmcpIGFuZApbYGhlYWRlci1pbmNsdWRlc2BdKGh0dHBzOi8vcGFuZG9jLm9yZy9NQU5VQUwu
aHRtbCN2YXJpYWJsZXMtc2V0LWF1dG9tYXRpY2FsbHkpCmFyZSBwcm9jZXNzZWQgYnkgYHBh
bmRvY2AgZHVyaW5nIGRvY3VtZW50IHJlbmRlcmluZy4gYGZvbnRzaXplYCBhZGp1c3RzIHRo
ZQpmb250IHNpemUgaW4gW2BodG1sYF0oaHR0cHM6Ly9wYW5kb2Mub3JnL01BTlVBTC5odG1s
I3ZhcmlhYmxlcy1mb3ItaHRtbCkKYW5kIFtgcGRmYF0oaHR0cHM6Ly9wYW5kb2Mub3JnL01B
TlVBTC5odG1sI3ZhcmlhYmxlcy1mb3ItbGF0ZXgpIGRvY3VtZW50cy4KVGhlIGB4bm9zLWNs
ZXZlcmVmYCBhbmQgYHhub3MtY2FwaXRhbGlzZWAKZmllbGRzIGFyZSB1c2VkIGJ5IHRoZSBb
YHBhbmRvYy14bm9zYF0oaHR0cHM6Ly9naXRodWIuY29tL3RvbWR1Y2svcGFuZG9jLXhub3Mp
CmV4dGVuc2lvbnMgZm9yIHJlZmVyZW5jaW5nCltmaWd1cmVzXShodHRwczovL2dpdGh1Yi5j
b20vdG9tZHVjay9wYW5kb2MtZmlnbm9zI2N1c3RvbWl6YXRpb24pLApbdGFibGVzXShodHRw
czovL2dpdGh1Yi5jb20vdG9tZHVjay9wYW5kb2MtdGFibGVub3MjY3VzdG9taXphdGlvbiks
CltzZWN0aW9uc10oaHR0cHM6Ly9naXRodWIuY29tL3RvbWR1Y2svcGFuZG9jLXNlY25vcyNj
dXN0b21pemF0aW9uKSBhbmQKW2VxdWF0aW9uc10oaHR0cHM6Ly9naXRodWIuY29tL3RvbWR1
Y2svcGFuZG9jLWVxbm9zI2N1c3RvbWl6YXRpb24pLgoKIyMgYG1hcmt5YCBGb3JtYXQgRmll
bGRzCgoqKkV4YW1wbGUqKgpgYGB5YW1sCi0tLQpoZWFkZXItaW5jbHVkZXMtLXBkZjogPgog
IFxoeXBlcnNldHVwewogIGNvbG9ybGlua3M9ZmFsc2UsCiAgYWxsYm9yZGVyY29sb3JzPXsw
IDAgMH0sCiAgcGRmYm9yZGVyc3R5bGU9ey9TL1UvVyAxfVx9CmhlYWRlci1pbmNsdWRlcy0t
aHRtbDogPgogIDxzdHlsZT4qIHsgYm94LXNpemluZzogYm9yZGVyLWJveDsgfTwvc3R5bGU+
Ci0tLQpgYGAKClRoZSBwYW5kb2MgYGhlYWRlci1pbmNsdWRlc2AgZmllbGQgaXMgdXNlZCBm
b3IgYHBkZmAgYW5kIGBodG1sYCBkb2N1bWVudHMsCnRoZXJlZm9yZSBpdCBtdXN0IGNvbnRh
aW4gY29ycmVzcG9uZGluZyB0ZXggYW5kIGBodG1sYCBjb2RlLgoKVGhlIGZpZWxkIGBoZWFk
ZXItaW5jbHVkZXNgIGVuZGluZyB3aXRoIGAtLXBkZmAgb3IgYC0taHRtbGAKc3BlY2lmaWVz
IGNvcnJlc3BvbmRpbmcgb3B0aW9ucyBmb3IgdGhlIGdlbmVyYXRpb24gb2YgYHBkZmAgYW5k
IGBodG1sYApkb2N1bWVudHMuIER1cmluZyBtYWtlLCBgbWFya3lgIHNjYW5zIGFsbCBtZXRh
IGRhdGEgZmllbGRzLCBhbmQKZmllbGRzIHdoaWNoIGVuZCB3aXRoIGAtLXBkZmAgYW5kIGAt
LWh0bWxgIGFyZSBzZWxlY3RlZCBhbmQgZm9yd2FyZGVkCnRvIGBwYW5kb2NgIGJhc2VkIG9u
IHRoZSBmb3JtYXQgdG8gYmUgcmVuZGVyZWQuCgojIFNjaWVudGlmaWMgV3JpdGluZyBpbiBN
YXJrZG93biB7I3NlYzpwYW5tZH0KCltNYXJrZG93bl0oaHR0cHM6Ly9wYW5kb2Mub3JnL01B
TlVBTC5odG1sI3BhbmRvY3MtbWFya2Rvd24pIGlzIGEgbWFya3VwCmxhbmd1YWdlIGZvciB0
ZWNobmljYWwgd3JpdGluZywgd2l0aCBlbXBoYXNpcyBvbiByZWFkYWJpbGl0eS4gTWFya2Rv
d24KY2FuIGJlIHJlbmRlcmVkIGluIG1hbnkgZm9ybWF0cyBpbmNsdWRpbmcgYGh0bWxgIGFu
ZCBgcGRmYCBieSB1c2luZwpbYHBhbmRvY2BdKGh0dHBzOi8vcGFuZG9jLm9yZy8pIGZvciBl
eGFtcGxlLgoKVXNpbmcgdmFyaW91cyBNYXJrZG93biBleHRlbnNpb25zIG9mIGBwYW5kb2Ng
IGEgc3VmZmljaWVudCBzdHJ1Y3R1cmUgZm9yCndyaXRpbmcgc2NpZW50aWZpYyBkb2N1bWVu
dHMgaXMgcmVmbGVjdGVkIHVzaW5nIE1hcmtkb3duIHN5bnRheC4KYG1hcmt5YCBieSBkZWZh
dWx0IHVzZXMgdGhlIGZvbGxvd2luZyBgcGFuZG9jYCBNYXJrZG93biBleHRlbnNpb25zLgoq
IHBhcnNpbmcgZXh0ZW5zaW9ucwoJKiBbYWxsX3N5bWJvbHNfZXNjYXBhYmxlXShodHRwczov
L3BhbmRvYy5vcmcvTUFOVUFMLmh0bWwjZXh0ZW5zaW9uLWFsbF9zeW1ib2xzX2VzY2FwYWJs
ZSkKCSogW2ludHJhd29yZF91bmRlcnNjb3Jlc10oaHR0cHM6Ly9wYW5kb2Mub3JnL01BTlVB
TC5odG1sI2V4dGVuc2lvbi1pbnRyYXdvcmRfdW5kZXJzY29yZXMpCgkqIFtlc2NhcGVkX2xp
bmVfYnJlYWtzXShodHRwczovL3BhbmRvYy5vcmcvTUFOVUFMLmh0bWwjZXh0ZW5zaW9uLWVz
Y2FwZWRfbGluZV9icmVha3MpCgkqIFtzcGFjZV9pbl9hdHhfaGVhZGVyXShodHRwczovL3Bh
bmRvYy5vcmcvTUFOVUFMLmh0bWwjZXh0ZW5zaW9uLXNwYWNlX2luX2F0eF9oZWFkZXIpCgkq
IFtsaXN0c193aXRob3V0X3ByZWNlZGluZ19ibGFua2xpbmVdKGh0dHBzOi8vcGFuZG9jLm9y
Zy9NQU5VQUwuaHRtbCNleHRlbnNpb24tbGlzdHNfd2l0aG91dF9wcmVjZWRpbmdfYmxhbmts
aW5lKQoqIHN0eWxpbmcgZXh0ZW5zaW9ucwoJKiBbaW5saW5lX2NvZGVfYXR0cmlidXRlc10o
aHR0cHM6Ly9wYW5kb2Mub3JnL01BTlVBTC5odG1sI2V4dGVuc2lvbi1pbmxpbmVfY29kZV9h
dHRyaWJ1dGVzKQoJKiBbc3RyaWtlb3V0XShodHRwczovL3BhbmRvYy5vcmcvTUFOVUFMLmh0
bWwjZXh0ZW5zaW9uLXN0cmlrZW91dCkKKiBzdHJ1Y3R1cmluZyBleHRlbnNpb25zCgkqIFt5
YW1sX21ldGFkYXRhX2Jsb2NrXShodHRwczovL3BhbmRvYy5vcmcvTUFOVUFMLmh0bWwjZXh0
ZW5zaW9uLXlhbWxfbWV0YWRhdGFfYmxvY2spCgkqIFtwaXBlX3RhYmxlc10oaHR0cHM6Ly9w
YW5kb2Mub3JnL01BTlVBTC5odG1sI2V4dGVuc2lvbi1waXBlX3RhYmxlcykKCSogW2xpbmVf
YmxvY2tzXShodHRwczovL3BhbmRvYy5vcmcvTUFOVUFMLmh0bWwjZXh0ZW5zaW9uLWxpbmVf
YmxvY2tzKQoJKiBbaW1wbGljaXRfZmlndXJlc10oaHR0cHM6Ly9wYW5kb2Mub3JnL01BTlVB
TC5odG1sI2V4dGVuc2lvbi1pbXBsaWNpdF9maWd1cmVzKQoJKiBbYWJicmV2aWF0aW9uc10o
aHR0cHM6Ly9wYW5kb2Mub3JnL01BTlVBTC5odG1sI2V4dGVuc2lvbi1hYmJyZXZpYXRpb25z
KQoJKiBbaW5saW5lX25vdGVzXShodHRwczovL3BhbmRvYy5vcmcvTUFOVUFMLmh0bWwjZXh0
ZW5zaW9uLWlubGluZV9ub3RlcykKKiBjb2RlIGluamVjdGlvbgoJKiBbcmF3X2h0bWxdKGh0
dHBzOi8vcGFuZG9jLm9yZy9NQU5VQUwuaHRtbCNleHRlbnNpb24tcmF3X2h0bWwpCgkqIFty
YXdfdGV4XShodHRwczovL3BhbmRvYy5vcmcvTUFOVUFMLmh0bWwjZXh0ZW5zaW9uLXJhd190
ZXgpCgpgcGFuZG9jYCBzdXBwb3J0cwpbZXF1YXRpb25zXShodHRwczovL3BhbmRvYy5vcmcv
TUFOVUFMLmh0bWwjZXh0ZW5zaW9uLXRleF9tYXRoX2RvbGxhcnMpCnJlbmRlcmVkIGlubGlu
ZSBhbmQgc2luZ2xlLWxpbmUgaW4gdGV4LXN0eWxlIHVzaW5nIGAkLi4uJGAgYW5kIGAkJC4u
LiQkYCwKW2JpYmxpb2dyYXBoeV0oaHR0cHM6Ly9wYW5kb2Mub3JnL01BTlVBTC5odG1sI2Np
dGF0aW9ucykKdXNpbmcgdGhlIGAtLWNpdGVwcm9jYCBvcHRpb24sCltzZWN0aW9uIG51bWJl
cmluZ10oaHR0cHM6Ly9wYW5kb2Mub3JnL01BTlVBTC5odG1sI2V4dGVuc2lvbi1oZWFkZXJf
YXR0cmlidXRlcykKdXNpbmcgdGhlIGAtLW51bWJlci1zZWN0aW9uc2Agb3B0aW9uIGFuZApb
dGFibGUgb2YgY29udGVudHNdKGh0dHBzOi8vcGFuZG9jLm9yZy9NQU5VQUwuaHRtbCNvcHRp
b24tLXRvYykKdXNpbmcgdGhlIGAtLXRhYmxlLW9mLWNvbnRlbnRzYCBvcHRpb24uCgpgcGFu
ZG9jYCBzdXBwb3J0cyBbYHhub3NgXShodHRwczovL2dpdGh1Yi5jb20vdG9tZHVjay9wYW5k
b2MteG5vcykgZmlsdGVycwpmb3IgcmVmZXJlbmNpbmcgZG9jdW1lbnQgY29udGVudCBsaWtl
CltmaWd1cmVzXShodHRwczovL2dpdGh1Yi5jb20vdG9tZHVjay9wYW5kb2MtZmlnbm9zI3Vz
YWdlKSwKW2VxdWF0aW9uc10oaHR0cHM6Ly9naXRodWIuY29tL3RvbWR1Y2svcGFuZG9jLWVx
bm9zI3VzYWdlKSwKW3RhYmxlc10oaHR0cHM6Ly9naXRodWIuY29tL3RvbWR1Y2svcGFuZG9j
LXRhYmxlbm9zI3VzYWdlKSwKW3NlY3Rpb25zXShodHRwczovL2dpdGh1Yi5jb20vdG9tZHVj
ay9wYW5kb2Mtc2Vjbm9zI3VzYWdlKQpieSB1c2luZyB0aGUgYC0tZmlsdGVyIHBhbmRvYy14
bm9zYCBvcHRpb24uCmB4bm9zYCBpbnRlZ3JhdGVzIGNsZXZlciByZWZlcmVuY2VzLCB3aGlj
aCBtZWFucyAiRmlnLiIsICJTZWMuIiwgIkVxLiIKYW5kICJUYWIuIiBhcmUgYWRkZWQgYXV0
b21hdGljYWxseSB0byB0aGUgY29ycmVzcG9uZGluZyBlbGVtZW50LgpJZiB0aGUgcHJlZml4
IGlzIHRvIGJlIG9taXR0ZWQsIHRoZSByZWZlcmVuY2UgaXMgd3JpdHRlbiBhcwpgXCFAcmVm
OmxhYmVsYC4KCiMjIyMgRXhhbXBsZSB7LX0KYGBgbWQKIyMgUmVmZXJlbmNlZCBTZWN0aW9u
IHsjc2VjOmxhYmVsfQoKVGhpcyBpcyBhIHJlZmVyZW5jZSB0byBAc2VjOmxhYmVsLgoKIVtU
aGlzIGlzIHRoZSBjYXB0aW9uXShkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29B
QUFBTlMKVWhFVWdBQUFBVUFBQUFGQ0FZQUFBQ05ieWJsQUFBQUhFbEVRVlFJMTJQNC8vOC93
MzhHSUFYRElCS0UwREgKeGdsak5CQUFPOVRYTDBZNE9Id0FBQUFCSlJVNUVya0pnZ2c9PSl7
I2ZpZzpsYWJlbH0KClRoaXMgaXMgYSByZWZlcmVuY2UgdG8gQGZpZzpsYWJlbC4KCkEgIHxC
ICB8QyAgfEQKLS0tfC0tLXwtLS18LS0tCjAwMHwxMTF8NDQ0fDU1NQoyMjJ8MzMzfDY2Nnw3
NzcKClRhYmxlOiBUaGlzIGlzIHRoZSBjYXB0aW9uIHsjdGJsOmxhYmVsfQoKVGhpcyBpcyBh
IHJlZmVyZW5jZSB0byBAdGJsOmxhYmVsLgoKJCRcbWJveHtlfV57XG1ib3h7aX1ccGl9KzE9
MCQkeyNlcTpsYWJlbH0KClRoaXMgaXMgYSByZWZlcmVuY2UgdG8gQGVxOmxhYmVsLgoKVGhp
cyBpcyBhIGNpdGF0aW9uIFtATXVsbGVyMTk5M10uCmBgYAoKVGhlIGZpbGUgYG1hcmt5LmJp
YmAgaXMgc3BlY2lmaWVkIGluIHRoZSBtZXRhIGRhdGEgaW4gdGhlIGZyb250Cm1hdHRlciBv
ZiB0aGUgTWFya2Rvd24gdGV4dC4KCiMjIFJlZmVyZW5jZWQgU2VjdGlvbiB7I3NlYzpsYWJl
bH0KClRoaXMgaXMgYSByZWZlcmVuY2UgdG8gQHNlYzpsYWJlbC4KCiFbVGhpcyBpcyB0aGUg
Y2FwdGlvbl0oZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdB
QUFBVUFBQUFGQ0FZQUFBQ05ieWJsQUFBQUhFbEVRVlFJMTJQNC8vOC93MzhHSUFYRElCS0Uw
REh4Z2xqTkJBQU85VFhMMFk0T0h3QUFBQUJKUlU1RXJrSmdnZz09KXsjZmlnOmxhYmVsfQoK
VGhpcyBpcyBhIHJlZmVyZW5jZSB0byBAZmlnOmxhYmVsLgoKQSAgfEIgIHxDICB8RAotLS18
LS0tfC0tLXwtLS0KMDAwfDExMXw0NDR8NTU1CjIyMnwzMzN8NjY2fDc3NwoKVGFibGU6IFRo
aXMgaXMgdGhlIGNhcHRpb24uIHsjdGJsOmxhYmVsfQoKVGhpcyBpcyBhIHJlZmVyZW5jZSB0
byBAdGJsOmxhYmVsLgoKJCRcbWJveHtlfV57aVxwaX0rMT0wJCR7I2VxOmxhYmVsfQoKVGhp
cyBpcyBhIHJlZmVyZW5jZSB0byBAZXE6bGFiZWwuCgpUaGlzIGlzIGEgY2l0YXRpb24gW0BN
dWxsZXIxOTkzXS4KCiMgUmVmZXJlbmNlcwo=
'''
pack_marky_bib = '''
QGFydGljbGV7TXVsbGVyMTk5MywKICAgIGF1dGhvciAgPSB7UGV0ZXIgTXVsbGVyfSwKICAg
IHRpdGxlICAgPSB7VGhlIHRpdGxlIG9mIHRoZSB3b3JrfSwKICAgIGpvdXJuYWwgPSB7VGhl
IG5hbWUgb2YgdGhlIGpvdXJuYWx9LAogICAgeWVhciAgICA9IHsxOTkzfSwKICAgIG51bWJl
ciAgPSB7Mn0sCiAgICBwYWdlcyAgID0gezIwMS0yMTN9LAogICAgbW9udGggICA9IHs3fSwK
ICAgIG5vdGUgICAgPSB7QW4gb3B0aW9uYWwgbm90ZX0sCiAgICB2b2x1bWUgID0gezR9Cn0K
'''
pack__gitignore = '''
YnVpbGQvCmh0bWwvCg==
'''

###!!!:::marky_pack_data:::!!!###
########################################################################
# SECTION IS AUTO-PACKAGED USING ./marky.py --pack --force
########################################################################

########################################################################

def _marky_front_join(y, text):
	return """---\n%s\n---\n%s""" % (
		yaml.dump(y, allow_unicode=True, default_flow_style=False),
		text
	)

def _marky_front_split(t):
	global _MARKY_EXEC_GLOBALS
	if not t.startswith("---\n"):
		return dict(), t, 0
	y = t.split("---\n")[1]
	meta_lines = len(y.split("\n")) + 2
	mark = "---\n".join(t.split("---\n")[2:])
	print("---\n" + y + "---", flush=True)
	data = dict()
	try:
		data = yaml.safe_load(y)
	except Exception as ex:
		print("# YAML ERROR", type(ex), str(ex))
		sys.exit(1)
	return data, mark, meta_lines

########################################################################

def _marky_mdtext_print(*args, sep=" ", shift="", crop=False, ret=False,
	file=None, run=False):
	global _MARKY_EXEC_QUIET
	global _MARKY_EXEC_TEXT
	global _MARKY_EXEC_APPEND
	if not file is None:
		_marky_run(_MARKY_MD_DIR + file, "/".join(file.split("/")[0:-1]), run)
		return
	if len(args) == 0:
		if _MARKY_EXEC_APPEND == False: _MARKY_EXEC_TEXT.append("")
		_MARKY_EXEC_APPEND = False
	else:
		if ret: return _marky_mdtext_ret(args[0], shift, crop)
		if crop or shift != "":
			_marky_mdtext_crop(args[0], shift, crop)
			if args[-1] == _marky_mdtext_print:
				_MARKY_EXEC_APPEND = True
			return
		exec_append_new = False
		if args[-1] == _marky_mdtext_print:
			exec_append_new = True
			args = args[0:-1]
		text = sep.join([str(i) for i in args])
		if _MARKY_EXEC_APPEND and len(_MARKY_EXEC_TEXT) > 0:
			_MARKY_EXEC_TEXT[-1] += text
		else:
			_MARKY_EXEC_TEXT.append(text)
		_MARKY_EXEC_APPEND = exec_append_new
		if not _MARKY_EXEC_QUIET: print(text, end="" if _MARKY_EXEC_APPEND else "\n", flush=True)

def _marky_mdtext_crop(arg, shift, crop):
	global _MARKY_EXEC_TEXT
	global _MARKY_EXEC_APPEND
	if not type(arg) is str:
		arg = str(arg)
	arg = arg.split("\n")
	if crop:
		if len(arg[0].strip()) == 0:
			arg = arg[1:]
		if len(arg[-1].strip()) == 0:
			arg = arg[:-1]
	n = len(arg[0]) - len(arg[0].lstrip())
	for i in arg:
		if crop and len(i[0:n].lstrip()) == 0:
			i = i[n:]
		_MARKY_EXEC_TEXT.append(shift + i)

def _marky_mdtext_ret(arg, shift="", crop=True):
	if not type(arg) is str:
		arg = str(arg)
	text = []
	arg = arg.split("\n")
	if crop:
		if len(arg[0].strip()) == 0:
			arg = arg[1:]
		if len(arg[-1].strip()) == 0:
			arg = arg[:-1]
	n = len(arg[0]) - len(arg[0].lstrip())
	for i in arg:
		if crop and len(i[0:n].lstrip()) == 0:
			i = i[n:]
		text.append(shift + i)
	return "\n".join(text)

########################################################################

class _marky_fmtcall:
	def __init__(self, name, fmtc):
		self.name = name
		self.fmtc = fmtc
	def __call__(self, *args, **kwargs):
		text = "<<?html "
		f = getattr(self.fmtc.html, self.name)
		if callable(f):
			v = f(*args, **kwargs)
			if type(v) is str: text += v
		elif type(f) is str:
			text += f.format(*args, **kwargs)
		text += " html?>>"
		text += "<<?pdf "
		f = getattr(self.fmtc.pdf, self.name)
		if callable(f):
			v = f(*args, **kwargs)
			if type(v) is str: text += v
		elif type(f) is str:
			text += f.format(*args, **kwargs)
		text += " pdf?>>"
		return text

class _marky_fmtcode:
	def __init__(self, pdf=None, html=None):
		if not html is None: self.html = html
		if not pdf is None: self.pdf = pdf
	def __call__(self, *args, **kwargs):
		text = "<<?html "
		f = self.html
		if callable(f):
			v = f(*args, **kwargs)
			if type(v) is str: text += v
		elif type(f) is str:
			text += f.format(*args, **kwargs)
		text += " html?>>"
		text += "<<?pdf "
		f = self.pdf
		if callable(f):
			v = f(*args, **kwargs)
			if type(v) is str: text += v
		elif type(f) is str:
			text += f.format(*args, **kwargs)
		text += " pdf?>>"
		return text
	def __getattr__(self, name):
		return _marky_fmtcall(name, self)

########################################################################

def _marky_rebrace(t):
	t = t.replace("{{", "<<brace?")
	t = t.replace("}}", "?brace>>")
	t = t.replace("{", "{{")
	t = t.replace("}", "}}")
	t = t.replace("<<brace?", "{")
	t = t.replace("?brace>>", "}")
	return t

def _marky_code_text(t, fstring=True):
	if fstring:
		if not '"""' in t and not t.endswith('"'):
			return '___(rf"""' + _marky_rebrace(t) + '""", ___); '
		elif not "'''" in t and not t.endswith("'"):
			return "___(rf'''" + _marky_rebrace(t) + "''', ___); "
		else:
			print("# ERROR", "python code contains \"\"\" as well as '''.")
			sys.exit(1)
	else:
		if not '"""' in t and not t.endswith('"'):
			return '___(r"""' + t + '""", ___); '
		elif not "'''" in t and not t.endswith("'"):
			return "___(r'''" + t + "''', ___); "
		else:
			print("# ERROR", "python code contains \"\"\" as well as '''.")
			sys.exit(1)

def _marky_paste_code(t):
	show_code = False
	if t.startswith("!"):
		t = t[1:]
		show_code = True
	if show_code:
		return _marky_code_text(t, fstring=False) + t
	return t

def _marky_meta_merge(old, front):
	global _MARKY_EXEC_GLOBALS
	meta = {}
	meta.update(old)
	try:
		for k, v in front.items():
			x = k.split("--")
			if "--" in k and x[-1] in _MARKY_FORMAT:
				if k in meta:
					if type(v) is list:
						print("<!-- field link, merge yaml list %s --!>" % k)
						meta[k].extend(v)
					if type(v) is dict:
						print("<!-- field link, merge yaml dict %s --!>" % k)
						meta[k].update(v)
					if type(v) is str:
						print("<!-- field link, merge yaml str %s --!>" % k)
						meta[k] += " " + v
					else:
						print("<!-- field exists, skip yaml %s %s --!>" % (str(type(v)), k))
				else:
					print("<!-- field link, set yaml %s --!>" % k)
					meta[k] = v
			else:
				if k in meta:
					print("<!-- field exists, skip yaml %s --!>" % k)
				else:
					meta[k] = v
				k = k.replace("-", "_")
				if k in _MARKY_EXEC_GLOBALS:
					print("<!-- field exists, skip local %s --!>" % k)
				else:
					_MARKY_EXEC_GLOBALS[k] = v
	except Exception as ex:
		print("# META MERGE ERROR", type(ex), str(ex))
		sys.exit(1)
	return meta

def _marky_run(fname, inbase, run=True):
	global _MARKY_EXEC_GLOBALS
	global _MARKY_META_DICT
	with open(fname, "r") as h:
		front, t, meta_lines = _marky_front_split(h.read())
	_MARKY_META_DICT = _marky_meta_merge(_MARKY_META_DICT, front)
	p = 0
	r = ""
	while True:
		p0 = t.find("<?", p)
		p1 = t.find("?>", p)
		if p0 > -1:
			if p1 < p0:
				print("# ERROR", "?> before <?")
				sys.exit(1)
			if p0 > 0: r += _marky_code_text(t[p:p0])
			p1 = t.find("?>", p0)
			if p1 > -1:
				code = t[p0+2:p1]
				r += _marky_paste_code(code)
				p = p1 + 2
			else:
				print("# ERROR", "missing ?>")
				sys.exit(1)
		else:
			r += _marky_code_text(t[p:])
			break
	for a, b, c, count in [
		("", "<%s?", "", 1),
		("", "?%s>", "", 1),
		("", "{%s", "{", 3),
		("}", "%s}", "", 3)
	]:
		for j in reversed(range(1, count+1)):
			for i in range(3):
				X = "\\"*(i + 1)
				Y = "\\"*(i + 0)
				r = r.replace(a + (b % X)*j + c, a + (b % Y)*j + c)
	open(_MARKY_BUILD_DIR + inbase + ".py", "w").write(r)
	# ~ print(_MARKY_EXEC_GLOBALS)
	try:
		old_val = _MARKY_EXEC_LOCALS["__marky__"]
		_MARKY_EXEC_LOCALS["__marky__"] = run
		exec(r, _MARKY_EXEC_GLOBALS, _MARKY_EXEC_LOCALS)
		_MARKY_EXEC_LOCALS["__marky__"] = old_val
	except Exception as ex:
		_marky_print_trace(ex, meta_lines, r)
		sys.exit(1)

def _marky_print_trace(ex, mlines, code):
	print("# TRACEBACK")
	import traceback
	traceback.print_tb(ex.__traceback__)
	if hasattr(ex, "filename") and ex.filename == "<string>":
		print("# ERROR LOCATION")
		code = code.split("\n")
		print(len(code))
		for i in range(max(0, ex.lineno-5), min(len(code), ex.lineno+5)):
			print("*" if i + 1 == ex.lineno else " ", "%03d" % i, code[i])
	print("# PYTHON ERROR")
	print(type(ex), str(ex))

########################################################################

def _marky_meta_link(front, link):
	flink = {}
	try:
		for k, v in front.items():
			if "--" in k: continue
			if not k in flink:
				flink[k] = v
			else:
				print("<!-- field exists, skip yaml %s --!>" % k)
		for k, v in front.items():
			if not "--" in k: continue
			x = k.split("--")
			if x[-1] in _MARKY_FORMAT:
				if x[-1] == link:
					k = "--".join(x[0:-1])
					if k in flink:
						print("<!-- field link, merge yaml %s --!>" % k)
						if type(v) is list: flink[k].extend(v)
						if type(v) is dict: flink[k].update(v)
						if type(v) is str: flink[k] += " " + v
						else: flink[k] = v
					else:
						print("<!-- field link, set yaml %s --!>" % k)
						flink[k] = v
	except Exception as ex:
		print("# META LINK ERROR", type(ex), str(ex))
		sys.exit(1)
	return flink

def _marky_link(front, md_text, link):
	md_text = md_text.replace(".???", "." + link)
	md_text = md_text.replace(r".\???", r".???")
	md_text = md_text.replace(r".\\???", r".\???")
	lsep = 3
	len_args = len(link) + 1
	c = 0
	newtext = ""
	p = md_text.find("<<?")
	while p >= 0:
		q = md_text.find("?>>", p + lsep)
		if q > 0:
			newtext += md_text[c:p]
			expr = md_text[p+lsep:q]
			if expr.startswith(link) and expr.endswith(link):
				newtext += expr[len_args:-len_args]
			c = q + lsep
			p = md_text.find("<<?", c)
		else:
			p = md_text.find("<<?", p + lsep)
	newtext += md_text[c:]
	flink = _marky_meta_link(front, link)
	return _marky_front_join(flink, newtext)

def _marky_write_build(inbase, outdir, front, mark):
	os.makedirs(_MARKY_BUILD_DIR + outdir, exist_ok=True)
	if not mark is None:
		open(_MARKY_BUILD_DIR + inbase + ".md", "w").write(_marky_front_join(front, mark))
		for fmt in _MARKY_FORMAT:
			open(_MARKY_BUILD_DIR + inbase + "." + fmt + ".md", "w").write(_marky_link(front, mark, fmt))

	with open(_MARKY_BUILD_DIR + inbase + ".make", "w") as fhnd:
		fhnd.write(f"""# auto-generated
all_md:=$(all_md) {_MARKY_MD_DIR+inbase}.md

{_MARKY_BUILD_DIR+inbase}.md: {_MARKY_MD_DIR+inbase}.md
	mkdir -p "{_MARKY_BUILD_DIR+outdir}"
	ln -snf ../{_MARKY_DATA_DIR} {_MARKY_BUILD_DIR+_MARKY_DATA_DIR}
	./marky.py --base="{inbase}.md"

.PHONY: build/{inbase}
build/{inbase}: {_MARKY_BUILD_DIR+inbase}.md

all_build:=$(all_build) build/{inbase}
"""
		)
		if "pdf" in _MARKY_FORMAT:
			fhnd.write(f"""
{_MARKY_BUILD_DIR+inbase}.tex: {_MARKY_BUILD_DIR+inbase}.pdf.md {_MARKY_MD_DIR+inbase}.md
	mkdir -p "{_MARKY_BUILD_DIR+outdir}"
	./pandoc-run tex {_MARKY_BUILD_DIR+inbase}.pdf.md {_MARKY_BUILD_DIR+inbase}.tex

all_tex:=$(all_tex) {_MARKY_BUILD_DIR+inbase}.tex
"""
			)
		for fmt in _MARKY_FORMAT:
			fhnd.write(f"""
{_MARKY_BUILD_DIR+inbase}.{fmt}.md: {_MARKY_BUILD_DIR+inbase}.md

{fmt}/{inbase}.{fmt}: {_MARKY_BUILD_DIR+inbase}.{fmt}.md {_MARKY_MD_DIR+inbase}.md
	mkdir -p "{fmt}/{outdir}"
	./pandoc-run {fmt} {_MARKY_BUILD_DIR+inbase}.{fmt}.md {fmt}/{inbase}.{fmt}

.PHONY: {fmt}/{inbase}
{fmt}/{inbase}: {fmt}/{inbase}.{fmt}

all_{fmt}:=$(all_{fmt}) {fmt}/{inbase}.{fmt}
"""
			)

########################################################################

def _marky_pack_b64enc(x, n=72):
	x = base64.b64encode(bytes(x, "utf-8")).decode("ascii")
	return "\n".join([x[i:i+n] for i in range(0, len(x), n)])

def _marky_pack_b64dec(x):
	return base64.b64decode(bytes(x.replace("\n", ""), "ascii")).decode("utf-8")

def _marky_load_pack(i):
	return _marky_pack_b64dec(eval("pack_" + i.split("/")[-1].replace(".", "_").replace("-", "_")))

def _marky_pack_write_file(fname, force=False):
	if not os.path.exists(fname) or force:
		print("# WRITE", fname)
		open(fname, "w").write(_marky_load_pack("./" + fname))
	else:
		print("# EXISTS", fname)

def _marky_store_pack(i, ftext):
	return "pack_%s = '''\n%s\n'''\n" % (i.split("/")[-1].replace(".", "_").replace("-", "_"), _marky_pack_b64enc(ftext))

def _marky_pack_read_file(fname):
	return _marky_store_pack("./" + fname, open(fname, "r").read())

########################################################################

_MARKY_FORMAT = ["html", "pdf"]
_MARKY_BUILD_DIR = "build/"  #< WITH trailing /
_MARKY_MD_DIR = "md/"  #< WITH trailing /
_MARKY_DATA_DIR = "data" #< no trailing /
_MARKY_PACK_DIRS = [
	_MARKY_BUILD_DIR,
	_MARKY_DATA_DIR,
	_MARKY_MD_DIR
]
_MARKY_PACK_FILES = [
	"Makefile",
	"pandoc-run",
	"md/marky.md",
	"data/marky.bib",
	".gitignore"
]
_MARKY_EXEC_QUIET = False
_MARKY_EXEC_TEXT = list()
_MARKY_EXEC_APPEND = False
_MARKY_EXEC_GLOBALS = dict()
_MARKY_EXEC_GLOBALS["___"] = _marky_mdtext_print
_MARKY_EXEC_GLOBALS["fmtcode"] = _marky_fmtcode
_MARKY_EXEC_LOCALS = dict()
_MARKY_EXEC_LOCALS["__marky__"] = True
_MARKY_META_DICT = dict()

########################################################################

if __name__ == "__main__":

	parser = argparse.ArgumentParser(add_help=False)

	parser.add_argument("--version", action='store_true', help="version is v" + ".".join([str(i) for i in _MARKY_VERSION]))
	parser.add_argument("--help", action='store_true', help="show this help message")
	parser.add_argument("--base", type=str, default="", help="path to input markdown text")
	parser.add_argument("--init", action='store_true', help="create dirs (" + ", ".join(_MARKY_PACK_DIRS) + ") and files (" + ", ".join(_MARKY_PACK_FILES) + ")")
	parser.add_argument("--force", action='store_true', help="force overwrite of files for --init/--pack")
	parser.add_argument("--pack", action='store_true', help="pack files (" + ", ".join(_MARKY_PACK_FILES) + ") into marky.py.pack source")
	parser.add_argument("--scan", action='store_true', help="create build/*.make from md/*.md")
	parser.add_argument("--quiet", action='store_true', help="do not show Markdown output")

	# ~ args, uargs = parser.parse_known_args()
	args = parser.parse_args()

	sys.path.append("/".join(sys.argv[0].split("/")[0:-1]) + "/lib")

########################################################################

	if args.version:
		print(".".join([str(i) for i in _MARKY_VERSION]))
		sys.exit(0)
	elif args.help or len(sys.argv) == 1:
		parser.print_help()
		sys.exit(0)
	elif args.init:
		for i in _MARKY_PACK_DIRS:
			if not os.path.exists(i):
				print("# MKDIR", i)
				os.mkdir(i)
			else:
				print("# EXISTS", i)
		for i in _MARKY_PACK_FILES:
			_marky_pack_write_file(i, args.force)
		print("# USAGE")
		print("make help")
		sys.exit(0)
	elif args.pack:
		print("# PACK", ", ".join(_MARKY_PACK_FILES))
		marky_text = open(sys.argv[0], "r").read()
		head, src, tail = tuple(marky_text.split("\n###!!!:::marky_pack_data:::!!!###\n"))
		src = "".join([_marky_pack_read_file(i) for i in _MARKY_PACK_FILES])
		marky_text = "\n###!!!:::marky_pack_data:::!!!###\n".join([head, src, tail])
		open(sys.argv[0] + ".pack", "w").write(marky_text)
		if args.force:
			print("# UPDATE OF `marky` FORCED")
			print("# -----------------------")
			print("# mv marky.py.pack marky.py")
			print("# chmod 775 marky.py")
			os.replace("marky.py.pack", "marky.py")
			os.chmod("marky.py", 0o775)
		else:
			print("# MANUAL UPDATE NEEDED")
			print("# --------------------")
			print("mv marky.py.pack marky.py")
			print("chmod +x marky.py")
		sys.exit(0)
	elif args.scan:
		for i in glob.glob("md/**/*.md", recursive=True):
			inbase = i[3:-3]
			outdir = "/".join(inbase.split("/")[0:-1])
			print("# WRITE", _MARKY_BUILD_DIR + inbase + ".make")
			_marky_write_build(inbase, outdir, None, None)
		sys.exit(0)
		pass
	elif args.force:
		print("# ERROR", "--force can only be used with --pack/--init")
		sys.exit(1)
	elif args.quiet:
		_MARKY_EXEC_QUIET = True

########################################################################

	infile = _MARKY_MD_DIR + args.base
	if len(args.base) == 0:
		print("# ERROR", "empty base: use --base file.md")
		sys.exit(1)
	if not os.path.exists(infile):
		print("# ERROR", "wrong base %s: file not found %s" % (args.base, infile))
		sys.exit(1)
	inbase = args.base if not "." in args.base.split("/")[-1] else ".".join(args.base.split(".")[0:-1])
	outdir = "/".join(inbase.split("/")[0:-1])

	if os.path.exists(_MARKY_BUILD_DIR):
		_marky_run(infile, inbase)
		mark = "\n".join(_MARKY_EXEC_TEXT)
		_marky_write_build(inbase, outdir, _MARKY_META_DICT, mark)
	else:
		print("# ERROR", "no build dir: mkdir build")
		sys.sys.exit(1)
