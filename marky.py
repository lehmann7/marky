#!/usr/bin/env python3
# -*- coding: utf-8 -*-

########################################################################
# marky Markdown Preprocessor ##########################################
########################################################################

# Quick Make Example Project
############################
#
#  > mkdir project
#  > cp /path/to/marky.py project
#  > cd project
#  > chmod +x marky.py
#  > ./marky.py --init
#  > make scan html-all pdf-all httpd
#
# Open: project/pdf/*.pdf
# Goto: http://localhost:8000/

########################################################################

import sys
import argparse
import glob
import os
import base64
import yaml

########################################################################

if not sys.version_info.major == 3 and sys.version_info.minor >= 6:
	try:
		raise ValueError("marky requires Python 3.6 or higher.")
	except Exception as ex:
		print("# ERROR", type(ex), str(ex))
		sys.exit(1)

########################################################################

_MARKY_VERSION = (0, 9)

########################################################################
# SECTION IS AUTO-PACKAGED USING ./marky.py --pack --force
########################################################################
###!!!:::marky_pack_data:::!!!###
pack_Makefile = '''
IyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMj
IyMjIyMjIyMjIyMjIyMjIyMjCgouUEhPTlk6IGhlbHAKaGVscDoKCSMKCSMgbWFya3kgREVQ
RU5ERU5DSUVTCgkjIyMjIyMjIyMjIyMjIyMjIyMjIwoJIyAqIHBhbmRvYyA+PSAyLjEwCgkj
ICogcGlwIGluc3RhbGwgcGFuZG9jLWZpZ25vcwoJIyAqIHBpcCBpbnN0YWxsIHBhbmRvYy1l
cW5vcwoJIyAqIHBpcCBpbnN0YWxsIHBhbmRvYy1zZWNub3MKCSMgKiBwaXAgaW5zdGFsbCBw
YW5kb2MtdGFibGVub3MKCSMgKiBwaXAgaW5zdGFsbCBwYW5kb2MteG5vcwoJIyAqIHBpcCBp
bnN0YWxsIHB5eWFtbAoJIwoJIyBBVFRFTlRJT04KCSMjIyMjIyMjIyMjCgkjIEFsbCBmaWxl
cyBpbiBgYnVpbGQvKi5tZGAgYW5kIGBodG1sLyouaHRtbGAgYXJlIGF1dG8tZ2VuZXJhdGVk
IQoJIyBVc2VyIGZpbGVzIGAqLm1kYCBoYXZlIHRvIGJlIHBsYWNlZCBpbiBgbWQvKi5tZGAh
CgkjIGBtYWtlIGNsZWFuYCBkZWxldGVzIGFsbCBmaWxlcyBpbiBgYnVpbGQvYCwgYGh0bWwv
YCBhbmQgYHBkZi9gLgoJIwoJIyBtYXJreSBVVElMUwoJIyMjIyMjIyMjIyMjIwoJIyAqIG1h
a2UgaGVscCAgICAgICAgICAgIC0gc2hvdyB0aGlzICpIZWxwIE1lc3NhZ2UqCgkjICogbWFr
ZSB0cmVlICAgICAgICAgICAgLSBzaG93IHRoZSAqUHJvamVjdCBUcmVlKgoJIyAqIG1ha2Ug
aHR0cGQgICAgICAgICAgIC0gcnVuIHB5dGhvbiAtbSBodHRwZC5zZXJ2ZXIgaW4gYGh0bWwv
YAoJIyAqIG1ha2UgY2xlYW4gICAgICAgICAgIC0gZGVsZXRlOiBgYnVpbGQvKmAsIGBodG1s
LypgLCBgcGRmLypgCgkjICogbWFrZSBxdWlldCBbLi4uXSAgICAgLSBidWlsZCB3aXRoIGAu
L21hcmt5IC0tcXVpZXQgWy4uLl1gCgkjICogbWFrZSBsaXN0ICAgICAgICAgICAgLSBsaXN0
IGFsbCBzY2FubmVkIGZpbGVzIGFuZCB0YXJnZXRzCgkjCgkjIG1hcmt5IEJVSUxEIEFMTAoJ
IyMjIyMjIyMjIyMjIyMjIyMKCSMgKiBtYWtlIHJlc2NhbiAgICAgICAgICAtPiBgYnVpbGQv
Ki5tYWtlYCwgb3ZlcndyaXRlIGFsbAoJIyAqIG1ha2Ugc2NhbiAgICAgICAgICAgIC0+IGBi
dWlsZC8qLm1ha2VgLCBvbmx5IG5ldyBmaWxlcwoJIyAqIG1ha2UgYnVpbGQgICAgICAgICAg
IC0+IGBidWlsZC8qLntodG1sLHBkZn0ubWRgCgkjICogbWFrZSB0ZXggICAgICAgICAgICAg
LT4gYGJ1aWxkLyoudGV4YAoJIyAqIG1ha2UgaHRtbCAgICAgICAgICAgIC0+IGBodG1sLyou
aHRtbGAKCSMgKiBtYWtlIHBkZiAgICAgICAgICAgICAtPiBgcGRmLyoucGRmYAoJIyAqIG1h
a2UgdGV4ICAgICAgICAgICAgIC0+IGBidWlsZC8qLnRleGAKCSMgKiBtYWtlIGF1eCAgICAg
ICAgICAgICAtPiBydW4gYWxsIGF1eCBjb21tYW5kcwoJIyAqIG1ha2UgYWxsICAgICAgICAg
ICAgIC0+IGBodG1sLyouaHRtbGAsIGBwZGYvKi5wZGZgCgkjCgkjIG1hcmt5IEJVSUxEIEZJ
TEUKCSMjIyMjIyMjIyMjIyMjIyMjIwoJIyAqIG1ha2Ugc2Nhbi9maWxlICAgICAgIC0+IGBi
dWlsZC9maWxlLm1ha2VgLCBvdmVyd3JpdGUKCSMgKiBtYWtlIGJ1aWxkL2ZpbGUgICAgICAt
PiBgYnVpbGQvZmlsZS57aHRtbCxwZGZ9Lm1kLHB5YAoJIyAqIG1ha2UgdGV4L2ZpbGUgICAg
ICAgIC0+IGBidWlsZC9maWxlLnRleGAKCSMgKiBtYWtlIGh0bWwvZmlsZSAgICAgICAtPiBg
aHRtbC9maWxlLmh0bWxgCgkjICogbWFrZSBwZGYvZmlsZSAgICAgICAgLT4gYHBkZi9wZGYu
cGRmYAoJIyAqIG1ha2UgYXV4L2ZpbGUgICAgICAgIC0+IHJ1biBhdXggY29tbWFuZHMgZm9y
IGZpbGUKCSMgKiBtYWtlIGNsZWFuL2ZpbGUgICAgICAtPiBjbGVhbiwgYnV0IGtlZXAgYG1h
a2UscGRmLGh0bWwsdGV4YAoJIwoJIyBFWEFNUExFCgkjIyMjIyMjIyMKCSMgMS4gcnVuIGBt
YWtlIHNjYW47IG1ha2UgaHRtbC9maWxlLmh0bWwgaHR0cGRgOgoJIyAgICAqIGdlbmVyYXRl
IGBidWlsZC9maWxlLm1ha2VgCgkjICAgICogdHJhbnNmb3JtIGBtZC9maWxlLm1kYCAtPiBg
aHRtbC9maWxlLmh0bWxgCgkjICAgICogc3RhcnQgYSBweXRob24gaHR0cGQgc2VydmVyIGlu
IGBodG1sYAoJIyAyLiBydW4gYG1ha2Ugc2NhbjsgbWFrZSBwZGYvZmlsZS5wZGZgCgkjICAg
ICogZ2VuZXJhdGUgYGJ1aWxkL2ZpbGUubWFrZWAKCSMgICAgKiB0cmFuc2Zvcm0gYG1kL2Zp
bGUubWRgIC0+IGBwZGYvZmlsZS5wZGZgCgkjIDMuIHJ1biBgbWFrZSBzY2FuOyBtYWtlIGxp
c3RgOiBsaXN0IGFsbCB0YXJnZXRzCgkjIDQuIHJ1biBgbWFrZSByZXNjYW5gOiBjbGVhciBh
bGwgYXV4IGZpbGUgbWFrZSBkZXBzCgkjCgouUEhPTlk6IHRyZWUKdHJlZToKCSMKCSMgUFJP
SkVDVCBUUkVFCgkjIyMjIyMjIyMjIyMjIwoJIyA8d29ya2luZ19kaXI+CgkjIHwtIG1hcmt5
LnB5ICAgICAgICAgICAgLSBtYXJreSBleGVjdXRhYmxlCgkjIHwtIE1ha2VmaWxlICAgICAg
ICAoKikgLSBtYXJreSBNYWtlZmlsZQoJIyB8LSBwYW5kb2MtcnVuICAgICAgKCopIC0gcGFu
ZG9jIHdyYXBwZXIKCSMgfC0gbWQvICAgICAgICAgICAgICgqKSAtIHVzZXIgTWFya2Rvd24g
ZGlyCgkjIHwgIHwtICoubWQgICAgICAgICAgICAgLSB1c2VyIE1hcmtkb3duIHRleHQKCSMg
fC0gZGF0YS8gICAgICAgICAgICgqKSAtIHVzZXIgZGF0YSBkaXIKCSMgfCAgfC0gKi4qICAg
ICAgICAgICAgICAgIHVzZXIgZGF0YSBmaWxlcwoJIyB8LSBidWlsZC8gICAgICAgICAgKCop
IC0gYnVpbGQgTWFya2Rvd24gZGlyCgkjIHwgIHwtICoucHkgICAgICAgICAoKikgLSBtYXJr
eSBQeXRob24gY29kZQoJIyB8ICB8LSAqLm1ha2UgICAgICAgKCopIC0gTWFrZWZpbGUgcnVs
ZXMKCSMgfCAgfC0gKi5odG1sLm1kICAgICgqKSAtIE1hcmtkb3duIGZvciBodG1sIGZvcm1h
dAoJIyB8ICB8LSAqLnBkZi5tZCAgICAgKCopIC0gTWFya2Rvd24gZm9yIHBkZiBmb3JtYXQK
CSMgfC0gaHRtbC8qLmh0bWwgICAgICgqKSAtIHJlbmRlcmVkIGh0bWwgZGlyCgkjIHwtIHBk
Zi8qLnBkZiAgICAgICAoKikgLSByZW5kZXJlZCBwZGYgZGlyCgkjCgkjICgqKSBkaXJlY3Rv
cmllcy9maWxlcyBhcmUgYXV0by1nZW5lcmF0ZWQgdXNpbmcKCSMgICAgYC4vbWFya3kucHkg
LS1pbml0OyBtYWtlIHNjYW47IG1ha2UgYWxswrQKCSMKCi5QSE9OWTogaHR0cGQKaHR0cGQ6
CgljZCBodG1sICYmIHB5dGhvbiAtbSBodHRwLnNlcnZlcgoKLlBIT05ZOiBzY2FuCnNjYW46
CgkuL21hcmt5LnB5IC0tc2NhbgoKLlBIT05ZOiByZXNjYW4KcmVzY2FuOgoJLi9tYXJreS5w
eSAtLXNjYW4gLS1mb3JjZQoKYWxsX3F1aWV0IDo9ICQoZmlsdGVyIHF1aWV0LCQoTUFLRUNN
REdPQUxTKSkKLlBIT05ZOiBxdWlldApxdWlldDoKCSMgZW5hYmxlIC4vbWFya3kgLS1xdWll
dCBbLi4uXQoKIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMj
IyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjCgptYXJreV9hbGlhczo9Ci1pbmNsdWRlIGJ1
aWxkLyoubWFrZSBidWlsZC8qKi8qLm1ha2UKCiMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMj
IyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIwoKLlBIT05Z
OiBsaW5rCmJ1aWxkOiAkKGZvcmVhY2ggaSwkKG1hcmt5X2FsaWFzKSxidWlsZC8kKGkpKQoK
LlBIT05ZOiBodG1sCmh0bWw6ICQoZm9yZWFjaCBpLCQobWFya3lfYWxpYXMpLGh0bWwvJChp
KSkKCi5QSE9OWTogcGRmCnBkZjogJChmb3JlYWNoIGksJChtYXJreV9hbGlhcykscGRmLyQo
aSkpCgouUEhPTlk6IHRleAp0ZXg6ICQoZm9yZWFjaCBpLCQobWFya3lfYWxpYXMpLHRleC8k
KGkpKQoKLlBIT05ZOiBhdXgKYXV4OiAkKGZvcmVhY2ggaSwkKG1hcmt5X2FsaWFzKSxhdXgv
JChpKSkKCi5QSE9OWTogY2xlYW4KY2xlYW46CglybSAtcmYgLi9idWlsZC8qIC4vaHRtbC8q
IC4vcGRmLyoKCi5QSE9OWTogYWxsCmFsbDogaHRtbCBwZGYKCi5QSE9OWTogbGlzdApsaXN0
OgoJIwoJIyBtYXJreSBUQVJHRVRTCgkjIyMjIyMjIyMjIyMjIyMKCSMgbWFrZSBzY2FuLzxB
TElBUz4gIC0gY3JlYXRlIE1ha2VmaWxlIGBidWlsZC88QUxJQVM+Lm1ha2VgCgkjIG1ha2Ug
YnVpbGQvPEFMSUFTPiAtIGJ1aWxkIGBidWlsZC88QUxJQVM+LntodG1sLHBkZn0ubWQscHlg
CgkjIG1ha2UgdGV4LzxBTElBUz4gICAtIGJ1aWxkIGBidWlsZC88QUxJQVM+LnRleGAKCSMg
bWFrZSBodG1sLzxBTElBUz4gIC0gYnVpbGQgYGh0bWwvPEFMSUFTPi5odG1sYAoJIyBtYWtl
IHBkZi88QUxJQVM+ICAgLSBidWlsZCBgcGRmLzxBTElBUz4ucGRmYAoJIyBtYWtlIGF1eC88
QUxJQVM+ICAgLSBydW4gYXV4IGNvbW1hbmRzIGZvciA8QUxJQVM+CgkjIG1ha2UgY2xlYW4v
PEFMSUFTPiAtIGNsZWFuIGZpbGVzLCBrZWVwOmBtYWtlLGh0bWwscGRmLHRleGAKCSMKCSMg
PEFMSUFTPgoJIyMjIyMjIyMjCgkjJChtYXJreV9hbGlhcykK
'''
pack_pandoc_run = '''
IyEvYmluL2Jhc2gKClsgJCMgPT0gMCBdICYmIGVjaG8gIiIiCiMgVXNhZ2U6ICQwOiA8Rk9S
TUFUPiA8SU5GSUxFPiA8T1VURklMRT4KIyBFeGFtcGxlOgojICQwIGh0bWwgYnVpbGQvZmls
ZS5odG1sLm1kIGh0bWwvZmlsZS5odG1sCiMgJDAgcGRmIGJ1aWxkL2ZpbGUucGRmLm1kIHBk
Zi9maWxlLnBkZgoiIiIgJiYgZXhpdCAxCgpQQU5ET0M9cGFuZG9jCgpNREVYVD1cCmFsbF9z
eW1ib2xzX2VzY2FwYWJsZStcCmludHJhd29yZF91bmRlcnNjb3JlcytcCmVzY2FwZWRfbGlu
ZV9icmVha3MrXApzcGFjZV9pbl9hdHhfaGVhZGVyK1wKbGlzdHNfd2l0aG91dF9wcmVjZWRp
bmdfYmxhbmtsaW5lK1wKaW5saW5lX2NvZGVfYXR0cmlidXRlcytcCnN0cmlrZW91dCtcCnlh
bWxfbWV0YWRhdGFfYmxvY2srXApwaXBlX3RhYmxlcytcCmxpbmVfYmxvY2tzK1wKaW1wbGlj
aXRfZmlndXJlcytcCmFiYnJldmlhdGlvbnMrXAppbmxpbmVfbm90ZXMrXApicmFja2V0ZWRf
c3BhbnMrXApuYXRpdmVfZGl2cytcCm5hdGl2ZV9zcGFucytcCmZvb3Rub3RlcwoKClBET1BU
PSIiIgotLXRhYmxlLW9mLWNvbnRlbnRzCi0tbnVtYmVyLXNlY3Rpb25zCiIiIgoKaWYgWyAk
MSA9PSBodG1sIF0gOyB0aGVuCiRQQU5ET0MgIiQyIiBcCi0tZmlsdGVyIHBhbmRvYy14bm9z
IFwKLS1jaXRlcHJvYyBcCi0tZnJvbT1tYXJrZG93biskTURFWFQgXAotLXRvPWh0bWw1IFwK
LS1zZWxmLWNvbnRhaW5lZCBcCi0tb3V0cHV0PSIkMyIgXAotLXJlc291cmNlLXBhdGg9Ii4v
YnVpbGQvIiBcCiRQRE9QVApmaQoKaWYgWyAkMSA9PSBwZGYgXSA7IHRoZW4KJFBBTkRPQyAi
JDIiIFwKLS1maWx0ZXIgcGFuZG9jLXhub3MgXAotLWNpdGVwcm9jIFwKLS1mcm9tPW1hcmtk
b3duK3Jhd19odG1sKyRNREVYVCBcCi0tdG89bGF0ZXggXAotLW91dHB1dD0iJDMiIFwKLS1y
ZXNvdXJjZS1wYXRoPSIuL2J1aWxkLyIgXAotLXBkZi1lbmdpbmU9eGVsYXRleCBcCiRQRE9Q
VApmaQoKaWYgWyAkMSA9PSB0ZXggXSA7IHRoZW4KJFBBTkRPQyAiJDIiIFwKLS1maWx0ZXIg
cGFuZG9jLXhub3MgXAotLWNpdGVwcm9jIFwKLS1mcm9tPW1hcmtkb3duK3Jhd190ZXgrJE1E
RVhUIFwKLS10bz1sYXRleCBcCi0tb3V0cHV0PSIkMyIgXAotLXJlc291cmNlLXBhdGg9Ii4v
YnVpbGQvIiBcCiRQRE9QVApmaQo=
'''
pack_marky_md = '''
LS0tCnRpdGxlOiAiYG1hcmt5YCBEb2N1bWVudGF0aW9uICIKdGl0bGUtLXBkZjogIi0tIGBw
ZGZgIgp0aXRsZS0taHRtbDogIi0tIGBodG1sYCIKYXV0aG9yOiBsZWhtYW5uNwpiaWJsaW9n
cmFwaHk6IGRhdGEvbWFya3kuYmliCmhlYWRlci1pbmNsdWRlcy0tcGRmOiA+CiAgIFxoeXBl
cnNldHVwe2NvbG9ybGlua3M9ZmFsc2UsCiAgIGFsbGJvcmRlcmNvbG9ycz17MCAwIDB9LAog
ICBwZGZib3JkZXJzdHlsZT17L1MvVS9XIDF9fQpoZWFkZXItaW5jbHVkZXMtLWh0bWw6ID4K
ICAgPHN0eWxlPiogeyBib3gtc2l6aW5nOiBib3JkZXItYm94OyB9IGJvZHkgeyBtYXgtd2lk
dGg6IDkwdncgIWltcG9ydGFudDsgfTwvc3R5bGU+Cnhub3MtY2xldmVyZWY6IHRydWUKeG5v
cy1jYXBpdGFsaXNlOiB0cnVlCmZvbnRzaXplOiAxMXB0CgotLS0KPD8KY29sID0gZm10Y29k
ZSgKCWh0bWw9IjxzcGFuIHN0eWxlPSdjb2xvcjp7MX07Jz57MH08L3NwYW4+IiwKCXBkZj1y
Ilx0ZXh0Y29sb3J7e3sxfX19e3t7MH19fSIKKQpkZWYgdGV4dF9wcm9jKGNtZCwgY3JvcD1U
cnVlKToKCWltcG9ydCBzdWJwcm9jZXNzIGFzIHNwCgl0ZXh0ID0gIiIKCWZvciBpIGluIHNw
LmNoZWNrX291dHB1dChjbWQuc3BsaXQoKSkuZGVjb2RlKCJ1dGYtOCIpLnNwbGl0KCJcbiIp
OgoJCWlmIG5vdCBjcm9wOgoJCQl0ZXh0ICs9IGkgKyAiXG4iCgkJZWxpZiBpLnN0YXJ0c3dp
dGgoIiMgIik6CgkJCXRleHQgKz0gaVsyOl0gKyAiXG4iCgkJZWxpZiBpID09ICIjIjoKCQkJ
dGV4dCArPSAiXG4iCgkJZWxpZiBpLnN0YXJ0c3dpdGgoIiMiKToKCQkJdGV4dCArPSBpICsg
IlxuIgoJcmV0dXJuIHRleHQKdmVyc2lvbiA9IHRleHRfcHJvYygicHl0aG9uIG1hcmt5LnB5
IC0tdmVyc2lvbiIsIGNyb3A9RmFsc2UpLnN0cmlwKCkKPz4KLS0tCgo+ICoqQWJzdHJhY3Qq
KiAtLSBgbWFya3lgIGlzIGEgcHJlcHJvY2Vzc29yIHdpdGggYW4gZWFzeSBhbmQgaW50dWl0
aXZlCj4gc3ludGF4IGZvciBleGVjdXRpb24gb2YgZW1iZWRkZWQge3tjb2woInB5aG9uIiwi
Ymx1ZSIpfX0gY29kZSBkdXJpbmcgcmVuZGVyaW5nCj4gYGh0bWxgIGFuZCBgcGRmYCBkb2N1
bWVudHMgZnJvbSBNYXJrZG93biB0ZXh0Lgo+IFRoaXMgZG9jdW1lbnQgaXMgY3JlYXRlZCB1
c2luZyBgbWFya3lgLCB2ZXJzaW9uICp7e3ZlcnNpb259fSouCj4gRm9yIG1vcmUgaW5mb3Jt
YXRpb24gcGxlYXNlIHJlZmVyIHRvIHRoZQo+IFtgbWFya3lgIHJlcG9zaXRvcnldKGh0dHBz
Oi8vZ2l0aHViLmNvbS9sZWhtYW5uNy9tYXJreSkuCgotLS0KCiMgYG1hcmt5YCBEeW5hbWlj
IE1hcmtkb3duCgpgbWFya3lgIGlzIGEgTWFya2Rvd24gcHJlcHJvY2Vzc29yIHdoaWNoIHRy
YW5zZm9ybXMgYSBNYXJrZG93biBkb2N1bWVudAp1c2luZyBweXRob24uIGBtYXJreWAgaW1w
bGVtZW50cyB0aHJlZSBzdGF0ZW1lbnRzIHdpdGggZXh0cmVtZWx5IGVhc3kKYW5kIGludHVp
dGl2ZSBzeW50YXgsIHdoaWNoIGFyZSBlbWJlZGRlZCBkaXJlY3RseSBpbiB0aGUgTWFya2Rv
d24gdGV4dDoKCjEuIGA8XD8uLi4/XD5gOiBQeXRob24gY29kZSBibG9jay4KMi4gYHtcey4u
Ln1cfWA6IGBmYC1zdHJpbmcgb3V0cHV0IGludG8gTWFya2Rvd24uCjMuIGBfX18oKWA6IEZ1
bmN0aW9uIGZvciBvdXRwdXQgaW50byBNYXJrZG93bi4KClVzaW5nIGA8XD8uLi4/XD5gIGFu
ZCBge1x7Li4ufVx9YCBweXRob24gY29kZSBhbmQgYGZgLXN0cmluZyBvdXRwdXQKYXJlIGVt
YmVkZGVkIGRpcmVjdGx5IGluc2lkZSB0aGUgTWFya2Rvd24gdGV4dC4KCiMjIyMgRXhhbXBs
ZSAxOiBJbmxpbmUgRm9ybWF0dGVkIE91cHV0IHstfQo8PyEKeCA9IDEyMy40NQpMRUcgPSBs
YW1iZGEgdiwgdzogImxlc3NlciIgaWYgdiA8IHcgZWxzZSAiZXF1YWwgb3IgZ3JlYXRlciIK
Pz4KYGBgcGhwCjxcP3t7X19fKGNvZGU9VHJ1ZSl9fT9cPgpgYGAKYGBgbWFya2Rvd24KVGhp
cyBpcyBhbiBleGFtcGxlIHdpdGggYSB2YWx1ZSB4PXtce3g6LjNmfVx9LAp3aGljaCBpcyB7
XHtMRUcoeCwgMTAwKX1cfSB0aGFuIDEwMC4KYGBgCiMjIyMgUnVuIGFuZCBPdXRwdXQgey19
CmBgYG1hcmtkb3duClRoaXMgaXMgYW4gZXhhbXBsZSB3aXRoIGEgdmFsdWUgeD17e3g6LjNm
fX0sCndoaWNoIGlzIHt7TEVHKHgsIDEwMCl9fSB0aGFuIDEwMC4KYGBgCgpVc2luZyB0aGUg
YF9fXygpYCBmdW5jdGlvbiB0ZXh0IGlzIGdlbmVyYXRlZCBmcm9tIHB5dGhvbgphbGdvcml0
aG1zIGFuZCBkeW5hbWljYWxseSBpbnNlcnRlZCBpbnRvIHRoZSByZXN1bHRpbmcgTWFya2Rv
d24uCgojIyMjIEV4YW1wbGUgMjogRHluYW1pYyBUZXh0IGZyb20gQ29kZSB7LX0KYGBgcGhw
CjxcP3t7X19fKGNvZGU9VHJ1ZSl9fT9cPgpgYGAKIyMjIyBSdW4gYW5kIE91dHB1dCB7LX0K
YGBgbWFya2Rvd24KPD8hCmZvciBpIGluIHJhbmdlKDMpOgoJX19fKGYie2krMX0uIGBpID0g
e2l9YCIsICJhYmNkZWZnaGlqIlswOihpKzEpKjNdKQo/PgpgYGAKClB5dGhvbiBjb2RlLCB3
aGljaCBpcyBlbWJlZGRlZCBpbiB0aGUgTWFya2Rvd24gdGV4dApmb2xsb3dzIHRoZSBQeXRo
b24gaW5kZW50YXRpb24gc3RhbmRhcmQuIE1hcmtkb3duCnRleHQgaXMgaW50ZWdyYXRlZCBp
bnRvIHRoZSBwcm9ncmFtIGZsb3cgd2hlbiBiZWluZwppbnNlcnRlZCBpbiBweXRob24gc3Rh
dGVtZW50cyBhY2NvcmRpbmdseS4KCiMjIyMgRXhhbXBsZSAzOiBUZXh0IGluIENvbmRpdGlv
biB7LX0KYGBgcGhwClRoaXMgaXMgdGhlIGZpcnN0IGxpbmUuCjxcPwppZiBGYWxzZToKCT9c
PlRoaXMgTGluZSBpcyAqKm5vdCoqIHNob3duLjxcPwplbHNlOgoJP1w+VGhpcyBMaW5lIGlz
IHNob3duLjxcPwo/XD4KVGhpcyBpcyB0aGUgbGFzdCBsaW5lLgpgYGAKIyMjIyBSdW4gYW5k
IE91dHB1dCB7LX0KYGBgbWFya2Rvd24KVGhpcyBpcyB0aGUgZmlyc3QgbGluZS4KPD8KaWYg
RmFsc2U6Cgk/PlRoaXMgTGluZSBpcyAqKm5vdCoqIHNob3duLjw/CmVsc2U6Cgk/PlRoaXMg
TGluZSBpcyBzaG93bi48Pwo/PgpUaGlzIGlzIHRoZSBsYXN0IGxpbmUuCmBgYAoKIyMjIyBF
eGFtcGxlIDQ6IFRleHQgaW4gUHJvZ3JhbSBGbG93IHstfQpgYGBwaHAKPFw/CmZvciBpIGlu
IHJhbmdlKDMpOgoJP1w+e1x7aSsxfVx9LiBgaSA9IHtce2l9XH1gIGluIHRoaXMgaXRlcmF0
aW9uLgo8XD8KP1w+CmBgYAojIyMjIFJ1biBhbmQgT3V0cHV0IHstfQpgYGBtYXJrZG93bgo8
Pwpmb3IgaSBpbiByYW5nZSgzKToKCT8+e3tpKzF9fS4gYGkgPSB7e2l9fWAgaW4gdGhpcyBp
dGVyYXRpb24uCjw/Cj8+CmBgYAoKIyMgQSBGaXJzdCBgbWFya3lgIEV4YW1wbGUKCmBtYXJr
eWAgY29tYmluZXMgcHl0aG9uIGV4cHJlc3Npb25zIHdpdGggTWFya2Rvd24sIGZvciBkeW5h
bWljIGNyZWF0aW9uCm9mIHRleHQuIEluIHRoZSBmb2xsb3dpbmcsIHR3byBpbi1kZXB0aCBl
eGFtcGxlcyBvZiBgbWFya3lgIGFyZSBwcmVzZW50ZWQuCgojIyMjIEV4YW1wbGUgMTogYG1h
cmt5YCBTeW50YXggey19Cjw/IQp4ID0gMTIzCnkgPSA0NQpkZWYgYWJjX2Z1bih2LCBhLCBi
LCBjKToKCXJldHVybiBhIGlmIHYgPCAxMDAgZWxzZSBiIGlmIHYgPT0gMTAwIGVsc2UgYwpM
RUcgPSBsYW1iZGEgdjogYWJjX2Z1bih2LCAibGVzc2VyIiwgImVxdWFsIiwgImdyZWF0ZXIi
KQo/PgpgYGBwaHAKPFw/e3tfX18oY29kZT1UcnVlKX19P1w+CmBgYApgYGBtYXJrZG93bgpU
aGlzIGlzIGFuIGV4YW1wbGUgd2l0aCBhIHZhbHVlIHg9e1x7eH1cfSwgd2hpY2ggaXMKe1x7
TEVHKHgpfVx9IHRoYW4gMTAwLiBUaGVyZSBpcyBhbm90aGVyIHZhbHVlIHk9e1x7eX1cfSwK
d2hpY2ggaXMge1x7TEVHKHkpfVx9IHRoYW4gMTAwLiBCb3RoIHZhbHVlcyB0b2dldGhlcgph
cmUgeCt5PXtce3greX1cfS4KYGBgCiMjIyMgUnVuIGFuZCBPdXRwdXQgey19CmBgYG1hcmtk
b3duClRoaXMgaXMgYW4gZXhhbXBsZSB3aXRoIGEgdmFsdWUgeD17e3h9fSwgd2hpY2ggaXMK
e3tMRUcoeCl9fSB0aGFuIDEwMC4gVGhlcmUgaXMgYW5vdGhlciB2YWx1ZSB5PXt7eX19LAp3
aGljaCBpcyB7e0xFRyh5KX19IHRoYW4gMTAwLiBCb3RoIHZhbHVlcyB0b2dldGhlcgphcmUg
eCt5PXt7eCt5fX0uCmBgYAoKVGhlIGZvbGxvd2luZyBleGFtcGxlIGNvbnRhaW5zIG1ldGEg
ZGF0YSBpbiB0aGUgZnJvbnQgbWF0dGVyCmFuZCAgY2FuIGJlIHJlbmRlcmVkIGludG8gYHBk
ZmAgYW5kIGBodG1sYCBieSBqdXN0IGNhbGxpbmcKYG1ha2UgcGRmL2ZpbGVgIG9yIGBtYWtl
IGh0bWwvZmlsZWAuCgojIyMjIEV4YW1wbGUgMjogYG1kL2ZpbGUubWRgIHstfQpgYGBwaHAK
LS0tCnRpdGxlOiBBbiBFeGFtcGxlCi0tLQo8XD8KZGVmIGNhcF9maXJzdChpKToKCXJldHVy
biAiICIuam9pbihbaVswXS51cHBlcigpICsgaVsxOl0gZm9yIGkgaW4gaS5zcGxpdCgpXSkK
Zm9yIGkgaW4gWyJ2ZXJ5IiwgIm5vdCBzbyJdOgoJP1w+Cioqe1x7Y2FwX2ZpcnN0KGkpfVx9
IFNlY3Rpb24qKgoKVG8gZGF5IGlzIGEge1x7aX1cfSB2ZXJ5IG5pY2UgZGF5LgpUaGUgc3Vu
IGlzIHNoaW5pbmcge1x7aX1cfSBicmlnaHQgYW5kCnRoZSBiaXJkcyBhcmUgc2luZ2luZyB7
XHtpfVx9IGxvdWQgYW5kCmZseSB7XHtpfVx9IGhpZ2ggaW4gdGhlIHtce2l9XH0gYmx1ZSBz
a3kuCgk8XD8KP1w+CmBgYAojIyMjIE91dHB1dCBgYnVpbGQvZmlsZS5tZGAgey19CmBgYG1h
cmtkb3duCi0tLQp0aXRsZTogQW4gRXhhbXBsZQotLS0KPD8KZGVmIGNhcF9maXJzdChpKToK
CXJldHVybiAiICIuam9pbihbaVswXS51cHBlcigpICsgaVsxOl0gZm9yIGkgaW4gaS5zcGxp
dCgpXSkKZm9yIGkgaW4gWyJ2ZXJ5IiwgIm5vdCBzbyJdOgoJPz4KKip7e2NhcF9maXJzdChp
KX19IFNlY3Rpb24qKgoKVG8gZGF5IGlzIGEge3tpfX0gdmVyeSBuaWNlIGRheS4KVGhlIHN1
biBpcyBzaGluaW5nIHt7aX19IGJyaWdodCBhbmQKdGhlIGJpcmRzIGFyZSBzaW5naW5nIHt7
aX19IGxvdWQgYW5kCmZseSB7e2l9fSBoaWdoIGluIHRoZSB7e2l9fSBibHVlIHNreS4KCTw/
Cj8+CmBgYAoKIyMgSG93IGRvZXMgYG1hcmt5YCB3b3JrIGludGVybmFsbHk/CgpgbWFya3lg
IHVzZXMgYW4gZXh0cmVtZWx5IHNpbXBsZSBtZWNoYW5pc20gZm9yIGdlbmVyYXRpbmcgYSBw
eXRob24gcHJvZ3JhbW0KZnJvbSB0aGUgTWFya2Rvd24gdGV4dC4gVXNpbmcgdGhlIGA8XD8u
Li4/XD5gIGFuZCBge1x7Li4ufVx9YCBzdGF0ZW1lbnQsClB5dGhvbiBjb2RlIGlzIGVtYmVk
ZGVkIGludG8gdGhlIE1hcmtkb3duIHRleHQgYW5kIHRyYW5zbGF0ZWQgaW50byBhIHNlcmll
cwpvZiBjYWxscyB0byB0aGUgYF9fXygpYCBmdW5jdGlvbiB1c2luZyBgZmAtc3RyaW5ncyBh
cyBhcmd1bWVudHMsIHdoZXJlCnB5dGhvbiB2YXJpYWJsZXMgYXJlIHJlZmVyZW5jZWQuIFRo
aXMgcmVzdWx0cyBpbnRvIGEgcHl0aG9uIHByb2dyYW0Kd2hpY2ggY2FuIGdlbmVyYXRlIE1h
cmtkb3duIHRleHQgYWxnb3JpdGhtaWNhbGx5LgoKIyMjIyBFeGFtcGxlOiBgbWQvZmlsZS5t
ZGAgey19CmBgYHBocAoqIFRoaXMgaXMge2ZpcnN0fS4gPFw/CnggPSAxICMgdGhpcyBpcyBj
b2RlCmZvciBpIGluIHJhbmdlKDMpOgoJaWYgeDoKCQk/XD4Ke1x7aSsxfVx9LiBUaGUgdmFs
dWUgaXMge1x7XHt4fVx9XH0uCjxcPwoJZWxzZToKCQk/XD57XHtpKzF9XH0uIFRoZSB2YWx1
ZSBpcyB6ZXJvLgo8XD8KCXggPSAwCj9cPiogVGhpcyBpcyBsYXN0LgpgYGAKVGhlIGZpbGUg
cHJvZHVjZXMgdGhlIGZvbGxvd2luZyBNYXJrZG93biBvdXRwdXQuCgojIyMjIE91dHB1dDog
TWFya2Rvd24gey19CmBgYGJhc2gKKiBUaGlzIGlzIHtmaXJzdH0uIDw/CnggPSAxICMgdGhp
cyBpcyBjb2RlCmZvciBpIGluIHJhbmdlKDMpOgoJaWYgeDoKCQk/Pgp7e2krMX19LiBUaGUg
dmFsdWUgaXMge3t7eH19fS4KPD8KCWVsc2U6CgkJPz57e2krMX19LiBUaGUgdmFsdWUgaXMg
emVyby4KPD8KCXggPSAwCj8+KiBUaGlzIGlzIGxhc3QuCmBgYAoKYG1hcmt5YCB0cmFuc2Zv
cm1zIHRoZSBNYXJrZG93biBpbnRvIFB5dGhvbiBzb3VyY2UgY29kZS4KRXhlY3V0aW9uIG9m
IHRoZSBQeXRob24gc291cmNlIGNvZGUgeWllbGRzIHRoZSBuZXcgTWFya2Rvd24gdGV4dC4K
CiMjIyMgT3V0cHV0OiBgYnVpbGQvZmlsZS5weWAgey19CmBgYHB5dGhvbgpfX18ocmYiIiIq
IFRoaXMgaXMge1x7Zmlyc3R9XH0uICIiIiwgX19fKTsKeCA9IDEgIyB0aGlzIGlzIGNvZGUK
Zm9yIGkgaW4gcmFuZ2UoMyk6CglpZiB4OgoJCV9fXyhyZiIiIgp7aSsxfS4gVGhlIHZhbHVl
IGlzIHtce1x7eH1cfVx9LgoiIiIsIF9fXyk7CgllbHNlOgoJCV9fXyhyZiIiIntpKzF9LiBU
aGUgdmFsdWUgaXMgemVyby4KIiIiLCBfX18pOwoJeCA9IDAKX19fKHJmIiIiKiBUaGlzIGlz
IGxhc3QuCiIiIiwgX19fKTsKYGBgCgojIFF1aWNrIFN0YXJ0CgojIyBgbWFya3lgIERlcGVu
ZGVuY2llcwoKYG1hcmt5YCBkZXBlbmRzIG9uIGBwYW5kb2NgIGFuZCBgcHl5YW1sYC4gYHBh
bmRvY2AgaXMgdXNlZCBmb3IgcmVuZGVyaW5nCnRoZSBNYXJrZG93biBpbnRvIGBodG1sYCBh
bmQgYHBkZmAuIGBtYXJreWAgdXNlcwpbcGFuZG9jXShodHRwczovL3d3dy5wYW5kb2Mub3Jn
LykgZm9yIHJlbmRlcmluZyBgaHRtbGAgYW5kIGBwZGZgLgpgcGFuZG9jPj0yLjEwYCByZWxl
YXNlcyBjYW4gYmUgZm91bmQKW2hlcmVdKGh0dHBzOi8vZ2l0aHViLmNvbS9qZ20vcGFuZG9j
L3JlbGVhc2VzKS4KVGhlIG90aGVyIHBhY2thZ2VzIGNhbiBiZSBpbnN0YWxsZWQgd2l0aCBg
cGlwYC4KCmBgYGJhc2gKcGlwIGluc3RhbGwgcGFuZG9jLWZpZ25vcwpwaXAgaW5zdGFsbCBw
YW5kb2MtZXFub3MKcGlwIGluc3RhbGwgcGFuZG9jLXNlY25vcwpwaXAgaW5zdGFsbCBwYW5k
b2MtdGFibGVub3MKcGlwIGluc3RhbGwgcGFuZG9jLXhub3MKcGlwIGluc3RhbGwgcHl5YW1s
CmBgYAoKIyMgYG1hcmt5YCBXb3JrZmxvdwoKV29ya2Zsb3cgZm9yIGNyZWF0aW5nIGBodG1s
YCBvciBgcGRmYCB1c2luZyBgbWFya3lgIGJ5Cmludm9jYXRpb24gb2YgYG1ha2Ugc2NhbmAg
YW5kIGBtYWtlIGFsbGAuCgoqbWFrZSp8MS4gKndyaXRlKiAgfCAgfDIuICpidWlsZCogICAg
ICAgICAgfCAgfDMuICpyZW5kZXIqCi0tLS0tLXwtLS0tLS0tLS0tLS18LS18LS0tLS0tLS0t
LS0tLS0tLS0tLS18LS18LS0tLS0tLS0tLS0tLS0tLQpgcGRmYCB8ICAgICAgICAgICAgfCAg
fGBidWlsZC9maWxlLmh0bWwubWRgfC0+fGBodG1sL2ZpbGUuaHRtbGAKYC1gICAgfGBtZC9m
aWxlLm1kYHwtPnwgICAgICAgICAgICAgICAgICAgIHwgIHwKYGhmbWxgfCAgICAgICAgICAg
IHwgIHxgYnVpbGQvZmlsZS5wZGYubWRgIHwtPnxgcGRmL2ZpbGUucGRmYAoKMS4gKip3cml0
ZSoqOiB1c2VyIHdyaXRlcyBhIE1hcmtkb3duIHRleHQgZmlsZSBhbmQgcGxhY2VzIGl0IGlu
IGBtZC8qLm1kYApkaXJlY3Rvcnkgd2l0aCB0aGUgZXh0ZW5zaW9uIGAubWRgLgoyLiAqKmJ1
aWxkKio6IGBtYXJreWAgdHJhbnNmb3JtcyB0aGUgZmlsZXMgaW4gYG1kLyoubWRgIGludG8g
cmVndWxhciBNYXJrZG93biB0ZXh0CmFuZCBwbGFjZXMgdGhlIHRyYW5zZm9ybWVkIGZpbGVz
IGluIGBidWlsZC9gLgozLiAqKnJlbmRlcioqOiB0aGUgcmVndWxhciBNYXJrZG93biB0ZXh0
IGluIHRoZSBmaWxlcyBgYnVpbGQvKi5tZGAgaXMgcmVuZGVyZWQgaW50bwpgaHRtbGAgYW5k
IGBwZGZgIHVzaW5nIGBwYW5kb2NgLgoKVGhlIHRocmVlIHN0ZXBzIGFyZSBpbXBsZW1lbnRl
ZCBpbiBhIE1ha2VmaWxlLgoKIyMgRG93bmxvYWQgYW5kIEluaXRpYWxpemUKCmBtYXJreWAg
aXMgc3VwcGxpZWQgYXMgYSBzaW5nbGUtZmlsZSBzY3JpcHQgd2hpY2ggYXV0b21hdGljYWxs
eQpzZXRzIHVwIHRoZSBwcm9qZWN0IHN0cnVjdHVyZSBjb250YWluaW5nIGFsbCBzY3JpcHRz
CnJlcXVpcmVkIGZvciBwcm9jZXNzaW5nIGFuZCByZW5kZXJpbmcgTWFya2Rvd24uCgpGb3Ig
ZXhhbXBsZSwgZG93bmxvYWQgYG1hcmt5YCBmcm9tIGdpdGh1Yi4KYGBgYmFzaApnaXQgY2xv
bmUgaHR0cHM6Ly9sZWhtYW5uNy5naXRodWIuY29tL21hcmt5LmdpdApjZCBtYXJreQpgYGAK
CkFmdGVyIGRvd25sb2FkLCB0aGUgYG1hcmt5YCBlbnZpcm9ubWVudCBpcyBpbml0aWFsaXpl
ZCB1c2luZyBgbWFya3lgLgpgYGBiYXNoCi4vbWFya3kucHkgLS1pbml0CiMgbWtkaXIgYnVp
bGQvCiMgbWtkaXIgZGF0YQojIG1rZGlyIG1kLwojIFdSSVRFIE1ha2VmaWxlCiMgV1JJVEUg
cGFuZG9jLXJ1bgojIFdSSVRFIG1kL21hcmt5Lm1kCiMgV1JJVEUgLmdpdGlnbm9yZQojIFVT
QUdFCm1ha2UgaGVscApgYGAKCiMjIGBtYXJreWAgRW52aXJvbm1lbnQKCkR1cmluZyBpbml0
aWFsaXphdGlvbiwgYG1hcmt5YCBjcmVhdGVzIGRpcmVjdG9yaWVzIGFuZCBmaWxlcy4KQWZ0
ZXIgaW5pdGlhbGl6YXRpb24sIHRoZSBmb2xsb3dpbmcgc3RydWN0dXJlIGlzIGF1dG8tZ2Vu
ZXJhdGVkCmluIHRoZSBwcm9qZWN0IGRpcmVjdG9yeS4gYG1hcmt5YCBzaG93cyB0aGUgcHJv
amVjdCBzdHJ1Y3R1cmUKd2hlbiBpbnZva2luZyBgbWFrZSB0cmVlYC4KYGBgYmFzaAo8Pwpf
X18odGV4dF9wcm9jKCJtYWtlIHRyZWUiKSkKPz4KYGBgCgpUaGUgc2NyaXB0IGBwYW5kb2Mt
cnVuYCBjYW4gYmUgYWRqdXN0ZWQgaW4gY2FzZSBzcGVjaWZpYwpgcGFuZG9jYCBvcHRpb25z
IGFyZSByZXF1aXJlZCBmb3IgcmVuZGVyaW5nIHRoZSBgaHRtbGAgYW5kIGBwZGZgIGRvY3Vt
ZW50cy4KCiMjIERvY3VtZW50IFJlbmRlcmluZwoKQnkgaW52b2tpbmcgYG1ha2UgYWxsYCBh
bGwgZmlsZXMgYG1kLyoubWRgIGFyZSB0cmFuc2Zvcm1lZAppbnRvIGNvcnJlc3BvbmRpbmcg
YGh0bWwvKi5odG1sYCBhbmQgYHBkZi8qLnBkZmAgZmlsZXMuIEJ5Cmludm9raW5nIGBtYWtl
IGh0dHBkYCBhIHB5dGhvbiB3ZWIgc2VydmVyIGlzIHN0YXJ0ZWQgaW4gYGh0bWwvYC4KCkFs
bCB1c2VyLWdlbmVyYXRlZCBNYXJrZG93biBjb250ZW50IGdvZXMgaW50byBgbWQvKmAgdXNl
ci1nZW5lcmF0ZWQKZGF0YSBmaWxlcyBnbyBpbnRvIGBkYXRhLypgLgoKKipBVFRFTlRJT046
KiogVGhlIGZpbGVzIGluIHRoZSBkaXJlY3RvcmllcyBgYnVpbGQvKmAgYXJlCioqYXV0by1n
ZW5lcmF0ZWQqKi4gQWxsIHVzZXIgZmlsZXMgaGF2ZSB0byBiZSBwbGFjZWQgaW5zaWRlIHRo
ZQpkaXJlY3RvcnkgYG1kLypgLiBJbnZva2luZyBgbWFrZSBjbGVhbmAgd2lsbCAqKmRlbGV0
ZSBhbGwgZmlsZXMqKgppbiBgaHRtbC9gLCBgYnVpbGQvYCBhbmQgYHBkZi9gLgoKIyMgYG1h
cmt5YCBNYWtlZmlsZSBUYXJnZXRzCgpgbWFya3lgIG1hbmFnZXMgYWxsIGZpbGVzIHVzaW5n
IE1ha2VmaWxlIHRhcmdldHMuIE1ha2VmaWxlIHRhcmdldHMKYXJlIGluaXRpYWxpemVkIHVz
aW5nIGBtYWtlIHNjYW5gIGFuZCBzaG93biB1c2luZyBgbWFrZSBsaXN0YC4KYGBgYmFzaAo8
PwpfX18odGV4dF9wcm9jKCJtYWtlIGxpc3QiKSkKPz4KYGBgCgojIyBJbnRlZ3JhdGVkIERv
Y3VtZW50YXRpb24KCmBtYXJreWAgaGFzIGFuIGludGVncmF0ZWQgZW52aXJvbm1lbnQuIFVz
aW5nIGBtYWtlIGhlbHBgIGRpc3BsYXlzCmEgc2hvcnQgaW5mbyBhYm91dCB0aGUgYG1hcmt5
YCBkZXBlbmRlbmNpZXMsIG1ha2UgdGFyZ2V0cyBhbmQKZXhhbXBsZXMuCmBgYGJhc2gKPD8K
X19fKHRleHRfcHJvYygibWFrZSBoZWxwIikpCj8+CmBgYAoKIyBgbWFya3lgIEZlYXR1cmVz
CgpJbiBvcmRlciB0byBxdWljayBzdGFydCBhIG5ldyBNYXJrZG93biBwcm9qZWN0LCBqdXN0
IGxpbmsgdGhlCmBtYXJreS5weWAgZXhlY3V0YWJsZSBpbiB0aGUgcHJvamVjdCBkaXIgb3Ig
Y2xvbmUgdGhlIGdpdCBhcwpkZXNjcmliZWQgYWJvdmUsIGFuZCBpbml0aWFsaXplIHRoZSBl
bnZpcm9ubWVudCB1c2luZyBgLS1pbml0YC4KYGBgYmFzaApta2RpciBteV9wcm9qZWN0CmNk
IG15X3Byb2plY3QKbG4gLXMgfi9tYXJreS9tYXJreS5weSAuCiMgLi4uIG9yIGdpdCBjbG9u
ZSAuLi4KLi9tYXJreS5weSAtLWluaXQKYGBgCgpOb3cgYG1hcmt5YCBpcyByZWFkeSBmb3Ig
b3BlcmF0aW9uLiBQbGFjZSBhIG5ldyBmaWxlIGluIGBtZC9maWxlLm1kYAphbmQgcnVuIHRo
ZSBmb2xsb3dpbmcgY29tbWFuZHMuCmBgYGJhc2gKdG91Y2ggbWQvZmlsZS5tZAptYWtlIHNj
YW4KIyBXUklURSBidWlsZC9maWxlLm1ha2UKYGBgCgpgbWFya3lgIGRpc2NvdmVycyB0aGUg
bmV3IGRvY3VtZW50IHdoZW4gaW52b2tpbmcgYG1ha2Ugc2NhbmAuCmBtYXJreWAgYWxzbyBy
ZW5kZXJzIGBodG1sYCBhbmQgYHBkZmAgdXNpbmcgbWFrZSB0YXJnZXRzLgpgYGBiYXNoCm1h
a2UgaHRtbC9maWxlCm1ha2UgcGRmL2ZpbGUKYGBgCgojIyBNZXRhIERhdGEgaW4gRnJvbnQg
TWF0dGVyCgpJZiBkb2N1bWVudCBzdGFydHMgd2l0aCBgLS0tYCwgeWFtbCBpcyB1c2VkIHRv
IHBhcnNlCnRoZSBmcm9udCBtYXR0ZXIgYmxvY2sgZGVsaW1pdGVkIGJ5IGAtLS1gLgpBbGwg
bWV0YSBkYXRhIGtleXMgd2lsbCBiZSBleHBvc2VkIGludG8gdGhlIHB5dGhvbiBzY29wZSBh
cyBhIGxvY2FsCnZhcmlhYmxlLCB1bmxlc3MgdGhlIHZhcmlhYmxlIGFscmVhZHkgZXhpc3Rz
LgoKIyMjIyBFeGFtcGxlIHstfQpgYGBwaHAKLS0tCnRpdGxlOiAiUHJpbWUgTnVtYmVycyIK
YXV0aG9yOiAuLi4KZGF0ZTogLi4uCm5tYXg6IDIwCi0tLQpUaGUgdGl0bGUgb2YgdGhpcyBk
b2N1bWVudCBpcyB7XHt0aXRsZX1cfS4KTGlzdCBvZiBwcmltZSBudW1iZXJzIHNtYWxsZXIg
dGhhbiB7XHtubWF4fVx9Ogo8XD8KZm9yIGkgaW4gcmFuZ2UoMiwgbm1heCk6CglwcmltID0g
VHJ1ZQoJZm9yIGogaW4gcmFuZ2UoMiwgaSk6CgkJaWYgaSAlIGogPT0gMDoKCQkJcHJpbSA9
IEZhbHNlCgkJCWJyZWFrCglpZiBwcmltOgoJCT9cPiogcHJpbWUgbnVtYmVyOiB7XHtpfVx9
CmBgYAojIyMjIE91dHB1dCB7LX0KYGBgbWFya2Rvd24KLS0tCnRpdGxlOiAiUHJpbWUgTnVt
YmVycyIKYXV0aG9yOiAuLi4KZGF0ZTogLi4uCm5tYXg6IDIwCi0tLQpUaGUgdGl0bGUgb2Yg
dGhpcyBkb2N1bWVudCBpcyBQcmltZSBOdW1iZXJzLgpMaXN0IG9mIHByaW1lIG51bWJlcnMg
c21hbGxlciB0aGFuIDIwOgoqIHByaW1lIG51bWJlcjogMgoqIHByaW1lIG51bWJlcjogMwoq
IHByaW1lIG51bWJlcjogNQoqIHByaW1lIG51bWJlcjogNwoqIHByaW1lIG51bWJlcjogMTEK
KiBwcmltZSBudW1iZXI6IDEzCiogcHJpbWUgbnVtYmVyOiAxNwpgYGAKCiMjIElubGluZSBG
b3JtYXR0ZWQgT3V0cHV0CgpQeXRob24gbG9jYWwgdmFyaWFibGVzIGFuZCB2YXJpYWJsZXMg
ZnJvbSBtZXRhIGRhdGEgaW4gZnJvbnQgbWF0dGVyCmNhbiBiZSBhY2Nlc3NlZCBkaXJldGx5
IGZyb20gdGhlIG1hcmtkb3duIHRleHQuClRoZSBge1x7Li4ufVx9YCBzdGF0ZW1lbnQgdXNl
cyBzeW50YXggc2ltaWxhciB0byBweXRob24gYGZgLXN0cmluZ3MgZm9yCmZvcm1hdHRlZCBv
dXRwdXQgb2YgdmFyaWFibGVzIGFuZCByZXN1bHRzIG9mIGV4cHJlc3Npb25zIGludG8gTWFy
a2Rvd24KdGV4dC4gVGhlIGBtYXJreWAgb3BlcmF0b3IgYHtcezxleHByZXNzaW9uPls6PGZv
cm1hdD5dfVx9YCB1c2VzIHRoZQpzeW50YXggb2YgW2BmYC1zdHJpbmdzXShodHRwczovL2Rv
Y3MucHl0aG9uLm9yZy8zL3JlZmVyZW5jZS9sZXhpY2FsX2FuYWx5c2lzLmh0bWwjZi1zdHJp
bmdzKS4KCiMjIyMgRXhhbXBsZSAxIHstfQpgYGBiYXNoClRpdGxlIG9mIHRoaXMgZG9jdW1l
bnQgaXMge1x7dGl0bGV9XH0gYW5kIGZvbnQgc2l6ZSBpcyB7XHtmb250c2l6ZX1cfS4KYHhg
IGlzIHtce3h9XH0gYW5kIHtceyIsIi5qb2luKFtzdHIoaSkgZm9yIGkgaW4gcmFuZ2UoeC0x
MCx4KV0pfVx9LgpgYGAKIyMjIyBPdXRwdXQgey19Cj4gVGl0bGUgb2YgdGhpcyBkb2N1bWVu
dCBpcyB7e3RpdGxlfX0gYW5kIGZvbnQgc2l6ZSBpcyB7e2ZvbnRzaXplfX0uCj4gYHhgIGlz
IHt7eH19IGFuZCB7eyIsIi5qb2luKFtzdHIoaSkgZm9yIGkgaW4gcmFuZ2UoeC0xMCx4KV0p
fX0uCgojIyMjIEV4YW1wbGUgMiB7LX0KPD8hCnggPSBpbnQoMSkKeSA9IGZsb2F0KDIuMykK
eiA9IDAKYSA9IFsxLCAyLCAzXQpiID0gKDQsIDUpCj8+CmBgYHB5dGhvbgp7e19fXyhjb2Rl
PVRydWUsIGNyb3A9VHJ1ZSl9fQpgYGAKYGBgbWFya2Rvd24KVGhpcyBpcyBhIHBhcmFncmFw
aCBhbmQgeCBpcyB7XHt4OjAzZH1cfSBhbmQgeSBpcyB7XHt5Oi4yZn1cfS4KT3RoZXIgY29u
dGVudCBpczogYSA9IHtce2F9XH0sIGIgPSB7XHtifVx9LgpgYGAKIyMjIyBPdXRwdXQgey19
Cj4gVGhpcyBpcyBhIHBhcmFncmFwaCBhbmQgeCBpcyB7e3g6MDNkfX0gYW5kIHkgaXMge3t5
Oi4yZn19Lgo+IE90aGVyIGNvbnRlbnQgaXM6IGEgPSB7e2F9fSwgYiA9IHt7Yn19LgoKIyMg
RW1iZWRkaW5nIFB5dGhvbiBDb2RlCgpQeXRob24gY29kZSBibG9ja3MgYXJlIGVtYmVkZGVk
IGludG8gTWFya2Rvd24gdXNpbmcgYDxcPy4uLj9cPmAgYW5kIGB7XHsuLi59XH1gLgpBbGwg
Y29kZSBibG9ja3Mgc3BhbiBvbmUgbGFyZ2Ugc2NvcGUgc2hhcmluZyBmdW5jdGlvbnMgYW5k
IGxvY2FsCnZhcmlhYmxlcy4gTWV0YSBkYXRhIGlzIGltcG9ydGVkIGZyb20gTWFya2Rvd24g
ZnJvbnQgbWF0dGVyIGFzIGxvY2FsCnZhcmlhYmxlcyBpbiB0aGUgcHl0aG9uIHNjb3BlLiBU
aGUgYGltcG9ydGAgc3RhdGVtZW50IGNhbiBiZSB1c2VkIGluCnB5dGhvbiBjb2RlIGluIG9y
ZGVyIHRvIGFjY2VzcyBpbnN0YWxsZWQgcHl0aG9uIHBhY2thZ2VzIGFzIHVzdWFsLgoKIyMj
IFZpc2libGUgQ29kZQoKVXNpbmcgYDxcPyEuLi4/XD5gIGNvZGUgaXMgZXhlY3V0ZWQgYW5k
IHN0b3JlZC4KVGhlIHRleHQgb2YgdGhlIGxhc3QgYDxcPyEuLi4/XD5gIGJsb2NrIGNhbiBi
ZQphY2Nlc3NlZCBhbmQgcGxhY2VkIHZpYSBge1x7X19fKGNvZGU9VHJ1ZSl9XH1gLgoKIyMj
IyBFeGFtcGxlIHstfQpgYGBweXRob24KPFw/IQp4ID0gNDIgIyB2aXNpYmxlIGNvZGUKcHJp
bnQoIkhlbGxvIGNvbnNvbGUhIikKP1w+Cntce19fXyhjb2RlPVRydWUpfVx9CmBgYAoKIyMj
IyBSdW4gYW5kIE91dHB1dCB7LX0KPD8hCnggPSA0MiAjIHZpc2libGUgY29kZQpwcmludCgi
SGVsbG8gY29uc29sZSEiKQo/PgpgYGBweXRob24Ke3tfX18oY29kZT1UcnVlLCBjcm9wPVRy
dWUpfX0KYGBgCgoqKkFUVEVOVElPTjoqKiBVc2luZyB0aGUgYHByaW50KClgIGZ1bmN0aW9u
IHRoZSB0ZXh0IHdpbGwgYmUgcHJpbnRlZAp0byB0aGUgY29uc29sZSBhbmQgKipub3QqKiBp
bnNpZGUgdGhlIHJlc3VsdGluZyBNYXJrZG93biB0ZXh0LgoKIyMjIEhpZGRlbiBDb2RlCgpV
c2luZyBgPFw/Li4uP1w+YCBjb2RlIGlzIGV4ZWN1dGVkIGJ1dCBub3Qgc2hvd24gaW4gTWFy
a2Rvd24uCgojIyMjIEV4YW1wbGUgey19CmBgYHB5dGhvbgo8XD97e19fXyhjb2RlPVRydWUp
fX0/XD4KYGBgCiMjIyMgUnVuIGFuZCBPdXRwdXQgey19CmBgYHB5dGhvbgo8PyEKeCA9IDQx
ICMgaGlkZGVuIGNvZGUKX19fKGYiT3V0cHV0IHRvIE1hcmtkb3duLiB4ID0ge3h9ISIpCj8+
CmBgYAoKKipBVFRFTlRJT046KiogVXNpbmcgdGhlIGBfX18oKWAgZnVuY3Rpb24gdGhlIHRl
eHQgd2lsbCBiZSBwcmludGVkCmluc2lkZSB0aGUgcmVzdWx0aW5nIE1hcmtkb3duIHRleHQg
KiphbmQgbm90Kiogb24gdGhlIGNvbnNvbGUuCgojIyMgRXJyb3IgTWVzc2FnZXMKCmBtYXJr
eWAgc2hvd3MgZXJyb3IgbWVzc2FnZXMgZGlyZWN0bHkgaW5zaWRlIHRoZSBNYXJrZG93biB0
ZXh0LgoKIyMjIyBFeGFtcGxlIDE6IGBtZC9maWxlLm1kYCB7LX0KYGBgc2NhbGEKICAgMSAg
LS0tCiAgIDIgIHRpdGxlOiAiU3ludGF4IEVycm9yIgogICAzICAtLS0KICAgNCAgPFw/CiAg
IDUgIHggPSAxCiAgIDYgID9cPgogICA3ICBUaGUgdmFsdWUgeCBpcyB7XHt5fVx9LgpgYGAK
IyMjIyBSdW4gYW5kIE91dHB1dDogYG1ha2UgYnVpbGQvZmlsZWAgey19CmBgYGJhc2gKPCEt
LSBydW4gbWQvZmlsZS5tZCAtLSE+CjwhLS0gcnVuIGJ1aWxkL2ZpbGUucHkgLS0hPgo8IS0t
IFBZVEhPTiBFUlJPUgogIEZpbGUgIm1kL2ZpbGUubWQiLCBsaW5lIDcsIGluIDxtb2R1bGU+
CiAgICBUaGUgdmFsdWUgeCBpcyB7XHt5fVx9LgogIEVycm9yIDxjbGFzcyAnTmFtZUVycm9y
Jz4gOiBuYW1lICd5JyBpcyBub3QgZGVmaW5lZAotLSE+CmBgYAoKIyMjIyBFeGFtcGxlIDI6
IGBtZC9maWxlLm1kYCB7LX0KYGBgc2NhbGEKICAgMSAgLS0tCiAgIDIgIHRpdGxlOiAiSW50
ZW5kYXRpb24gRXJyb3IiCiAgIDMgIC0tLQogICA0ICA8XD8KICAgNSAgZm9yIGkgaW4gcmFu
Z2UoMyk6CiAgIDYgICAgICBpZiBpICUgMjoKICAgNyAgICAgID9cPiogZXZlbiBsaXN0IGl0
ZW0KICAgOCAgPFw/CiAgIDkgICAgICBlbHNlOgogIDEwICAgICAgICAgID9cPiogb2RkIGxp
c3QgaXRlbQpgYGAKIyMjIyBSdW4gYW5kIE91dHB1dDogYG1ha2UgYnVpbGQvZmlsZWAgey19
CmBgYGJhc2gKPCEtLSBydW4gbWQvZmlsZS5tZCAtLSE+CjwhLS0gcnVuIGJ1aWxkL2ZpbGUu
cHkgLS0hPgo8IS0tIFBZVEhPTiBFUlJPUgogIEVycm9yIDxjbGFzcyAnSW5kZW50YXRpb25F
cnJvcic+IDogZXhwZWN0ZWQgYW4gaW5kZW50ZWQgYmxvY2sKICAgICAgICA/XD4qIGV2ZW4g
bGlzdCBpdGVtICAgICAgICAgKG1kL2ZpbGUubWQsIGxpbmUgNykKLS0hPgpgYGAKCiMjIFRo
ZSBgX19fKClgIEZ1bmN0aW9uCgpVc2luZyB0aGUgYHByaW50KClgIHN0YXRlbWVudCB0aGUg
dGV4dCB3aWxsIGJlIHByaW50ZWQgdG8gdGhlIGNvbnNvbGUuCldoZW4gdXNpbmcgdGhlIGBf
X18oKWAgc3RhdGVtZW50IG5ldyBNYXJrZG93biB0ZXh0IGlzCmluc2VydGVkIGR5bmFtaWNh
bGx5IGludG8gdGhlIGRvY3VtZW50IGR1cmluZyBwcmVwcm9jZXNzaW5nLgoKIyMjIyBFeGFt
cGxlOiBMaW5lIEJyZWFrIHstfQpgYGBweXRob24KPFw/e3tfX18oY29kZT1UcnVlKX19P1w+
CmBgYAojIyMjIFJ1biBhbmQgT3V0cHV0IHstfQpgYGBiYXNoCjw/IQp4ID0gNDAgIyBoaWRk
ZW4gY29kZQpfX18oIk91dHB1dCBpbiAiLCBfX18pCl9fXygic2luZ2xlIGxpbmUhICIsIF9f
XykKX19fKGYieCA9IHt4fSIpCj8+CmBgYAoKIyMjIyBFeGFtcGxlOiBTaGlmdCwgQ3JvcCwg
UmV0dXJuIHstfQpgYGBweXRob24KPFw/e3tfX18oY29kZT1UcnVlKX19P1w+CmBgYAojIyMj
IFJ1biBhbmQgT3V0cHV0IHstfQpgYGBiYXNoCjw/IQpyZXN1bHQgPSBfX18oIiIiCiAgICog
dGV4dCBpcyBjcm9wcGVkIGFuZCBzaGlmdGVkCiAgICAgICAgICogc2hpZnQgYW5kIGNyb3AK
ICAgICAgICAgICAgKiBjYW4gYmUgY29tYmluZWQKICAgICAgICAgICogcmV0dXJuaW5nIHRo
ZSByZXN1bHQKIiIiLCBzaGlmdD0iIyMjIyMjIyMiLCBjcm9wPVRydWUsIHJldD1UcnVlKQpf
X18ocmVzdWx0KQo/PgpgYGAKCiMjIEFsZ29yaXRobWljIFRhYmxlIEV4YW1wbGUKCkB0Ymw6
YWxndCBpcyBnZW5lcmF0ZWQgdXNpbmcgdGhlIGZvbGxvd2luZyBweXRob24gY2xvZGUgYmxv
Y2suCgo8PyEKbiA9IDUKdGFibGUgPSAiIgpkZWMgPSBbIiolcyoiLCAiKiolcyoqIiwgIn5+
JXN+fiIsICJgJXNgIiwKICAgICAgIHIiJFx0aW1lc14lcyQiLCAiJFxpbmZ0eV8lcyQiXQp0
YWJsZSArPSAifCIuam9pbigiWCIqbikgKyAiXG4iICsgInwiLmpvaW4oIi0iKm4pICsgIlxu
Igpmb3IgaSBpbiByYW5nZShuKToKCWZpbGwgPSBbY2hyKG9yZCgiQSIpKygyKmkrMyprKSUy
NikgZm9yIGsgaW4gcmFuZ2UoaSsxKV0KCWZpbGwgPSBbZGVjWyhsK2kpJWxlbihkZWMpXSVr
IGZvciBsLCBrIGluIGVudW1lcmF0ZShmaWxsKV0KCXRleHQgPSBsaXN0KCIwIikqbgoJdGV4
dFsobj4+MSktKGk+PjEpOihuPj4xKSsoaT4+MSldID0gZmlsbAoJdGFibGUgKz0gInwiLmpv
aW4odGV4dCkgKyAiXG4iCj8+CmBgYHB5dGhvbgp7e19fXyhjb2RlPVRydWUsIGNyb3A9VHJ1
ZSl9fQpgYGAKCnt7dGFibGV9fQoKVGFibGU6IFRhYmxlIGlzIGdlbmVyYXRlZCB1c2luZyBj
b2RlIGFuZCB0aGUgYF9fXygpYCBzdGF0ZW1lbnQuIHsjdGJsOmFsZ3R9CgojIyBGb3JtYXQg
TGluayBFeHRlbnNpb24KCldoZW4gd3JpdGluZyBtdWx0aXBsZSBkb2N1bWVudHMsIG9mdGVu
IGRvY3VtZW50cyBhcmUgcmVmZXJlbmNlZApiZXR3ZWVuIGVhY2ggb3RoZXIgdXNpbmcgbGlu
a3MuIEluIG9yZGVyIHRvIHJlZmVyIHRvIGV4dGVybmFsCmBodG1sYCBhbmQgYHBkZmAgZG9j
dW1lbnRzIHRoZSBNYXJrZG93biBsaW5rIHN0YXRlbWVudCBpcyB1c2VkLgpgYGBtZApbTGlu
ayBDYXB0aW9uXShwYXRoL3RvL2ZpbGUuaHRtbCkKW0xpbmsgQ2FwdGlvbl0ocGF0aC90by9m
aWxlLnBkZikKYGBgCk9uZSBsaW5rIHN0YXRlbWVudCBjYW5ub3QgYmUgdXNlZCBmb3IgcmVu
ZGVyaW5nIGBodG1sYCBhbmQgYHBkZmAKd2l0aCBjb25zaXN0ZW50IHBhdGhzLiBVc2luZyB0
aGUgYG1hcmt5YCBmb3JtYXQgbGluawogYC5cPz8/YCBmaWxlIGV4dGVuc2lvbiByZXN1bHRz
IGluIGNvbnNpc3RlbnQgbGlua3MgZm9yIGBodG1sYCBhbmQKYHBkZmAgZG9jdW1lbnRzLgoK
IyMjIyBFeGFtcGxlIHstfQpgYGBtZApbTGluayB0byB0aGlzIERvY3VtZW50XShtYXJreS5c
Pz8/KQpgYGAKIyMjIyBPdXRwdXQgey19Cj4gW0xpbmsgdG8gdGhpcyBEb2N1bWVudF0obWFy
a3kuPz8/KQoKIyMgRm9ybWF0IENvZGVzCgpPZnRlbiB3aGVuIHdyaXRpbmcgbWFya2Rvd24g
Zm9yIGBodG1sYCBhbmQgYHBkZmAgZG9jdW1lbnRzLCB0aGUKb3V0cHV0IG5lZWRzIHRvIGJl
IHR3ZWFrZWQgYWNjb3JkaW5nbHkuCmBtYXJreWAgc3VwcG9ydHMgZm9ybWF0IHNwZWNpZmlj
IHR3ZWFraW5nIGJ5IGluamVjdGluZwpyYXcgYGh0bWxgIG9yIGB0ZXhgIGNvZGUgaW50byBN
YXJrZG93biB1c2luZyBmb3JtYXQgY29kZXMuCgpJbiBvcmRlciB0byBpbmplY3QgZm9ybWF0
IHNwZWNpZmljIGNvZGUgdGhlIGBmbXRjb2RlYCBjbGFzcyBpcyB1c2VkLgpUaGUgYGZtdGNv
ZGVgIGNsYXNzIG1hbmFnZXMgaW5qZWN0aW9uIG9mIGBodG1sYCBhbmQgYHRleGAgY29kZQpk
ZXBlbmRpbmcgb24gdGhlIG91dHB1dCBmb3JtYXQuCgoqKkFUVEVOVElPTjoqKiBgdGV4YCBw
YWNrYWdlcyBoYXZlIHRvIGJlIGluY2x1ZGVkIGZvciBgcGRmYCBhcyB3ZWxsIGFzCkphdmFT
Y3JpcHQgYW5kIHN0eWxlIHNoZWV0cyBmb3IgYGh0bWxgIHVzaW5nIHRoZSBtZXRhIGRhdGEg
ZmllbGRzCmBoZWFkZXItaW5jbHVkZXMtLXBkZmAgYW5kIGBoZWFkZXItaW5jbHVkZXMtLWh0
bWxgIHJlc3BlY3RpdmVseS4KCiMjIyMgRXhhbXBsZTogYGZtdGNvZGVgIHstfQo8PyEKRiA9
IGZtdGNvZGUoaHRtbD0iSDxzdXA+VDwvc3VwPjxzdWI+TTwvc3ViPkwiLCBwZGY9ciJcTGFU
ZVgiKQo/PgpgYGBweXRob24Ke3tfX18oY29kZT1UcnVlLCBjcm9wPVRydWUpfX0KYGBgCmBg
YG1hcmtkb3duCkludm9jYXRpb24gb2YgZm9ybWF0IGNvZGUgcmVzdWx0cyBpbjoge1x7Rigp
fVx9LgpgYGAKIyMjIyBPdXRwdXQgey19Cj4gSW52b2NhdGlvbiBvZiBmb3JtYXQgY29kZSBy
ZXN1bHRzIGluOiB7e0YoKX19LgoKIyMjIyBFeGFtcGxlOiBDb2xvciB7LX0KPD8hCkMgPSBs
YW1iZGEgY29sb3I6IGZtdGNvZGUoCglodG1sPSI8c3BhbiBzdHlsZT0nY29sb3I6JXM7Jz57
MH08L3NwYW4+IiAlIGNvbG9yLAoJcGRmPXIiXHRleHRjb2xvcnt7JXN9fXt7ezB9fX0iICUg
Y29sb3IKKQpCID0gQygiYmx1ZSIpClIgPSBDKCJyZWQiKQo/PgpgYGBweXRob24Ke3tfX18o
Y29kZT1UcnVlLCBjcm9wPVRydWUpfX0KYGBgCmBgYG1hcmtkb3duClRleHQgd2l0aCB7XHtC
KCJibHVlIil9XH0gYW5kIHtce1IoIlJFRCIpfVx9LgpgYGAKIyMjIyBPdXRwdXQgey19Cj4g
VGV4dCB3aXRoIHt7QigiYmx1ZSIpfX0gYW5kIHt7UigiUkVEIil9fS4KCgojIyMjIEV4YW1w
bGU6IENsYXNzZXMgey19Cjw/IQpjbGFzcyBjb2xvcjoKCWRlZiBfX2luaXRfXyhzZWxmLCBj
b2xvcik6CgkJc2VsZi5jb2xvciA9IGNvbG9yCglkZWYgdXBwZXIoc2VsZiwgeCk6CgkJcmV0
dXJuIHNlbGYudGV4dCh4LnVwcGVyKCkpCglkZWYgbG93ZXIoc2VsZiwgeCk6CgkJcmV0dXJu
IHNlbGYudGV4dCh4Lmxvd2VyKCkpCgpjbGFzcyBodG1sKGNvbG9yKToKCWRlZiB0ZXh0KHNl
bGYsIHgpOgoJCXJldHVybiBmIjxzcGFuIHN0eWxlPSdjb2xvcjp7c2VsZi5jb2xvcn07Jz57
eH08L3NwYW4+IgoKY2xhc3MgcGRmKGNvbG9yKToKCWRlZiB0ZXh0KHNlbGYsIHgpOgoJCXJl
dHVybiByZiJcdGV4dGNvbG9ye3t7c2VsZi5jb2xvcn19fXt7e3h9fX0iCgpDQyA9IGxhbWJk
YSB4OiBmbXRjb2RlKGh0bWw9aHRtbCh4KSwgcGRmPXBkZih4KSkKQkIgPSBDQygiYmx1ZSIp
ClJSID0gQ0MoInJlZCIpCj8+CmBgYHB5dGhvbgp7e19fXyhjb2RlPVRydWUsIGNyb3A9VHJ1
ZSl9fQpgYGAKYGBgbWFya2Rvd24KVGV4dCB3aXRoIHtce0JCLnVwcGVyKCJibHVlIil9XH0g
YW5kIHtce1JSLmxvd2VyKCJSRUQiKX1cfS4KYGBgCiMjIyMgT3V0cHV0IHstfQo+IFRleHQg
d2l0aCB7e0JCLnVwcGVyKCJibHVlIil9fSBhbmQge3tSUi5sb3dlcigiUkVEIil9fS4KCiMj
IE1hcmtkb3duIEluY2x1ZGUKClRoZSBgbWFya3lgIGluY2x1ZGUgc3RhdGVtZW50IGBfX18o
ZmlsZSlgIEZvciBpbmNsdXNpb24gb2YgdGV4dCBmcm9tCm90aGVyIGZpbGVzIGNhbiBiZSB1
c2VkIHRvIGluY2x1ZGUgdGV4dCBpbnRvIGBodG1sYCBhbmQgYHBkZmAgZG9jdW1lbnRzLgpg
YGBweXRob24KPFw/Cl9fXyhmaWxlPSJpbmNsdWRlLm1kIiwgX19tYXJreV9fPUZhbHNlLCBy
YXc9RmFsc2UsIGF1eD1GYWxzZSwgY21kPU5vbmUpCj9cPgpgYGAKCmBfX18oZmlsZSlgIHN1
cHBvcnRzIGZvbGxvd2luZyBvcHRpb25zLgoqIGBfX21hcmt5X19gOiBjb250cm9scyB3aGV0
aGVyIHRoZSBpbmNsdWRlIGZpbGUgaXMgcHJvY2Vzc2VkIGFzIGBtYXJreWAKc2NyaXB0IChg
VHJ1ZWApIG9yIGFzIGEgYG1hcmt5YCBtb2R1bGUgKGBGYWxzZWAsIGRlZmF1bHQpLgoqIGBy
YXdgOiBjb250cm9scyB3aGV0aGVyIHRoZSBpbmNsdWRlIGZpbGUgaXMgaW5jbHVkZWQgYXMt
aXMgKGBUcnVlYCkKb3IgcHJvY2Vzc2VkIHZpYSBgbWFya3lgIChgRmFsc2VgLCBkZWZhdWx0
KS4KKiBgYXV4YDogZGlzYWJsZXMgcHJvY2Vzc2luZyBvZiB0aGUgZmlsZSBpZiBgVHJ1ZWAs
IChkZWZhdWx0OiBgRmFsc2VgKS4KKiBgY21kYDogY29tbWFuZCBvciBjYWxsYWJsZSBmb3Ig
YnVpbGR1bmcgYXV4IGZpbGUsIHdoaWNoIHdpbGwgYmUgaW52b2tlZApvbmx5IGlmIGF1eCBm
aWxlIGRvZXMgbm90IGV4aXN0LgoKSW5jbHVkZSBmaWxlcyBhbmQgYXV4IGZpbGVzIG11c3Qg
ZXhpc3QgZHVyaW5nIHByb2Nlc3NpbmcsIG90aGVyd2lzZQpgbWFya3lgIHdpbGwgZmFpbC4g
Q29tbWFuZHMgZm9yIG1ha2luZyBhdXggZmlsZXMgYWxzbyBjYW4gYmUgYWNjZXNzZWQKdmlh
IE1ha2VmaWxlIHRhcmdldHMsIHNlZSBgbWFrZSBoZWxwYCBvciBgbWFrZSBsaXN0YC4KCldo
ZW4gc2NyaXB0IG1vZGUgaXMgYWN0aXZhdGVkIChgX19tYXJreV9fPVRydWVgKSB0aGVuIHRo
ZSAqbW9kdWxlIGNvZGUqCmFzIHdlbGwgYXMgdGhlICpzY3JpcHQgY29kZSogYXJlIGV4ZWN1
dGVkLiBIb3dldmVyLCBpZiBtb2R1bGUgbW9kZSBpcwphY3RpdmF0ZWQgKGBfX21hcmt5X189
RmFsc2VgKSwgb25seSB0aGUgKm1vZHVsZSBjb2RlKiBpcyBwcm9jZXNzZWQuCgpgYGBwaHAK
LS0tCnRpdGxlOiBUZXN0Ci0tLQo8XD8KIyBtYXJreSBtb2R1bGUgY29kZQo/XD4KYG1hcmt5
YCBtb2R1bGUgb3V0cHV0CjxcPwppZiBfX21hcmt5X186CgkjIG1hcmt5IHNjcmlwdCBjb2Rl
Cgk/XD5gbWFya3lgIHNjcmlwdCBvdXRwdXQ8XD8KP1w+CmBgYAoKIyBNZXRhIERhdGEgaW4g
RnJvbnQgTWF0dGVyCgpNZXRhIGRhdGEgaXMgYW5ub3RhdGVkIGluIHRoZSBmcm9udCBtYXR0
ZXIgb2YgYSBNYXJrZG93biB0ZXh0IGRvY3VtZW50LgpUaGUgZnJvbnQgbWF0dGVyIG11c3Qg
c3RhcnQgaW4gdGhlIGZpcnN0IGxpbmUgd2l0aCBgLS0tYCBhbmQgcHJlY2VkZXMgYWxsCm90
aGVyIHRleHQgYmVpbmcgZmVuY2VkIGJ5IGAtLS1gLiBUaGUgbWV0YSBkYXRhIGlzIGluIGB5
YW1sYCBmb3JtYXQuClRoZSBgeWFtbGAgYmxvY2sgaXMgcGFyc2VkIHVzaW5nIGBweXRob24t
cHl5YW1sYC4gQWxsIG1ldGEKZGF0YSBpcyBpbXBvcnRlZCBpbnRvIHRoZSBwcmVwcm9jZXNz
ZWQgZG9jdW1lbnQuCgojIyBQYW5kb2MgRnJvbnQgTWF0dGVyCgojIyMjIEV4YW1wbGUgey19
CmBgYHlhbWwKLS0tCnRpdGxlOiBNeSBEb2N1bWVudApkYXRlOiAyMDIyLTAxLTAxCmF1dGhv
cjogLi4uCmxpbmstY2l0YXRpb25zOiB0cnVlCmJpYmxpb2dyYXBoeTogZGF0YS9tYXJreS5i
aWIKaGVhZGVyLWluY2x1ZGVzOiA+CiAgIFxoeXBlcnNldHVwe2NvbG9ybGlua3M9ZmFsc2Us
CiAgIGFsbGJvcmRlcmNvbG9ycz17MCAwIDB9LAogICBwZGZib3JkZXJzdHlsZT17L1MvVS9X
IDF9XH0KeG5vcy1jbGV2ZXJlZjogdHJ1ZQp4bm9zLWNhcGl0YWxpc2U6IHRydWUKZm9udHNp
emU6IDExcHQKLS0tCmBgYApUaGUgbWV0YSBkYXRhIGZpZWxkcwpbYHRpdGxlYCwgYGRhdGVg
LCBgYXV0aG9yYF0oaHR0cHM6Ly9wYW5kb2Mub3JnL01BTlVBTC5odG1sI21ldGFkYXRhLXZh
cmlhYmxlcyksCltgbGluay1jaXRhdGlvbnNgXShodHRwczovL3BhbmRvYy5vcmcvTUFOVUFM
Lmh0bWwjb3RoZXItcmVsZXZhbnQtbWV0YWRhdGEtZmllbGRzKSwKW2BiaWJsaW9ncmFwaHlg
XShodHRwczovL3BhbmRvYy5vcmcvTUFOVUFMLmh0bWwjY2l0YXRpb24tcmVuZGVyaW5nKSBh
bmQKW2BoZWFkZXItaW5jbHVkZXNgXShodHRwczovL3BhbmRvYy5vcmcvTUFOVUFMLmh0bWwj
dmFyaWFibGVzLXNldC1hdXRvbWF0aWNhbGx5KQphcmUgcHJvY2Vzc2VkIGJ5IGBwYW5kb2Ng
IGR1cmluZyBkb2N1bWVudCByZW5kZXJpbmcuIGBmb250c2l6ZWAgYWRqdXN0cyB0aGUKZm9u
dCBzaXplIGluIFtgaHRtbGBdKGh0dHBzOi8vcGFuZG9jLm9yZy9NQU5VQUwuaHRtbCN2YXJp
YWJsZXMtZm9yLWh0bWwpCmFuZCBbYHBkZmBdKGh0dHBzOi8vcGFuZG9jLm9yZy9NQU5VQUwu
aHRtbCN2YXJpYWJsZXMtZm9yLWxhdGV4KSBkb2N1bWVudHMuClRoZSBgeG5vcy1jbGV2ZXJl
ZmAgYW5kIGB4bm9zLWNhcGl0YWxpc2VgCmZpZWxkcyBhcmUgdXNlZCBieSB0aGUgW2BwYW5k
b2MteG5vc2BdKGh0dHBzOi8vZ2l0aHViLmNvbS90b21kdWNrL3BhbmRvYy14bm9zKQpleHRl
bnNpb25zIGZvciByZWZlcmVuY2luZwpbZmlndXJlc10oaHR0cHM6Ly9naXRodWIuY29tL3Rv
bWR1Y2svcGFuZG9jLWZpZ25vcyNjdXN0b21pemF0aW9uKSwKW3RhYmxlc10oaHR0cHM6Ly9n
aXRodWIuY29tL3RvbWR1Y2svcGFuZG9jLXRhYmxlbm9zI2N1c3RvbWl6YXRpb24pLApbc2Vj
dGlvbnNdKGh0dHBzOi8vZ2l0aHViLmNvbS90b21kdWNrL3BhbmRvYy1zZWNub3MjY3VzdG9t
aXphdGlvbikgYW5kCltlcXVhdGlvbnNdKGh0dHBzOi8vZ2l0aHViLmNvbS90b21kdWNrL3Bh
bmRvYy1lcW5vcyNjdXN0b21pemF0aW9uKS4KCiMjIFVwZGF0ZSBNZXRhIERhdGEKClRoZSBm
cm9udCBtYXR0ZXIgc2VjdGlvbiBjb250YWlucyBtZXRhIGRhdGEgb2YgdGhlIGRvY3VtZW50
LgptZXRhIGRhdGEga2V5cyBjYW4gYmUgdXBkYXRlZCBmcm9tIGNvZGUgYmxvY2tzIHVzaW5n
CmBfX18obWV0YT1kaWN0KCkpYC4KCiMjIyMgRXhhbXBsZTogYG1kL2ZpbGUubWRgIHstfQpg
YGBwaHAKLS0tCnRpdGxlOiBNeSBEb2N1bWVudApkYXRlOiAidW5rbm93biIKLS0tCjxcP3t7
X19fKGNvZGU9VHJ1ZSl9fT9cPgpgYGAKPD8hCmltcG9ydCBkYXRldGltZQp0b2RheSA9IGRh
dGV0aW1lLmRhdGUudG9kYXkoKS5zdHJmdGltZSgiJUIgJWQsICVZIikKX19fKG1ldGE9ZGlj
dChkYXRlPXRvZGF5LCB2ZXJzaW9uPSIxLjAiKSkKPz4KIyMjIyBPdXRwdXQgey19CmBgYHBo
cAotLS0KdGl0bGU6IE15IERvY3VtZW50CmRhdGU6ICJ7e3RvZGF5fX0iCnZlcnNpb246ICIx
LjAiCi0tLQpgYGAKCiMjIGBtYXJreWAgRm9ybWF0IEZpZWxkcwoKIyMjIyBFeGFtcGxlOiBg
bWQvZmlsZS5tZGAgey19CmBgYHlhbWwKLS0tCmhlYWRlci1pbmNsdWRlcy0tcGRmOiA+CiAg
XGh5cGVyc2V0dXB7CiAgY29sb3JsaW5rcz1mYWxzZSwKICBhbGxib3JkZXJjb2xvcnM9ezAg
MCAwfSwKICBwZGZib3JkZXJzdHlsZT17L1MvVS9XIDF9XH0KaGVhZGVyLWluY2x1ZGVzLS1o
dG1sOiA+CiAgPHN0eWxlPiogeyBib3gtc2l6aW5nOiBib3JkZXItYm94OyB9PC9zdHlsZT4K
LS0tCmBgYAoKVGhlIHBhbmRvYyBgaGVhZGVyLWluY2x1ZGVzYCBmaWVsZCBpcyB1c2VkIGZv
ciBgcGRmYCBhbmQgYGh0bWxgIGRvY3VtZW50cywKdGhlcmVmb3JlIGl0IG11c3QgY29udGFp
biBjb3JyZXNwb25kaW5nIHRleCBhbmQgYGh0bWxgIGNvZGUuCgpUaGUgZmllbGQgYGhlYWRl
ci1pbmNsdWRlc2AgZW5kaW5nIHdpdGggYC0tcGRmYCBvciBgLS1odG1sYApzcGVjaWZpZXMg
Y29ycmVzcG9uZGluZyBvcHRpb25zIGZvciB0aGUgZ2VuZXJhdGlvbiBvZiBgcGRmYCBhbmQg
YGh0bWxgCmRvY3VtZW50cy4gRHVyaW5nIG1ha2UsIGBtYXJreWAgc2NhbnMgYWxsIG1ldGEg
ZGF0YSBmaWVsZHMsIGFuZApmaWVsZHMgd2hpY2ggZW5kIHdpdGggYC0tcGRmYCBhbmQgYC0t
aHRtbGAgYXJlIHNlbGVjdGVkIGFuZCBmb3J3YXJkZWQKdG8gYHBhbmRvY2AgYmFzZWQgb24g
dGhlIGZvcm1hdCB0byBiZSByZW5kZXJlZC4KCkFmdGVyIGJ1aWxkIGBtYWtlIGJ1aWxkL2Zp
bGVgIHRoZSBtZXRhIGRhdGEgZmllbGQgYGhlYWRlci1pbmNsdWRlc2AKaXMgcHJlc2VudCBp
biB0aGUgZmlsZXMgYGJ1aWxkL2ZpbGUuaHRtbC5tZGAgYW5kYGJ1aWxkL2ZpbGUucGRmLm1k
YAphY2NvcmRpbmdseS4KCiMjIyMgRXhhbXBsZTogYGJ1aWxkL2ZpbGUuaHRtbC5tZGAgey19
CmBgYHlhbWwKLS0tCmhlYWRlci1pbmNsdWRlczogPgogIDxzdHlsZT4qIHsgYm94LXNpemlu
ZzogYm9yZGVyLWJveDsgfTwvc3R5bGU+Ci0tLQpgYGAKIyMjIyBFeGFtcGxlOiBgYnVpbGQv
ZmlsZS5wZGYubWRgIHstfQpgYGB5YW1sCi0tLQpoZWFkZXItaW5jbHVkZXM6ID4KICBcaHlw
ZXJzZXR1cHsKICBjb2xvcmxpbmtzPWZhbHNlLAogIGFsbGJvcmRlcmNvbG9ycz17MCAwIDB9
LAogIHBkZmJvcmRlcnN0eWxlPXsvUy9VL1cgMX1cfQotLS0KYGBgCgojIFNjaWVudGlmaWMg
V3JpdGluZyBpbiBNYXJrZG93bgoKW01hcmtkb3duXShodHRwczovL3BhbmRvYy5vcmcvTUFO
VUFMLmh0bWwjcGFuZG9jcy1tYXJrZG93bikgaXMgYSBtYXJrdXAKbGFuZ3VhZ2UgZm9yIHRl
Y2huaWNhbCB3cml0aW5nLCB3aXRoIGVtcGhhc2lzIG9uIHJlYWRhYmlsaXR5LiBNYXJrZG93
bgpjYW4gYmUgcmVuZGVyZWQgaW4gbWFueSBmb3JtYXRzIGluY2x1ZGluZyBgaHRtbGAgYW5k
IGBwZGZgIGJ5IHVzaW5nCltgcGFuZG9jYF0oaHR0cHM6Ly9wYW5kb2Mub3JnLykgZm9yIGV4
YW1wbGUuCgpVc2luZyB2YXJpb3VzIE1hcmtkb3duIGV4dGVuc2lvbnMgb2YgYHBhbmRvY2Ag
YSBzdWZmaWNpZW50IHN0cnVjdHVyZSBmb3IKd3JpdGluZyBzY2llbnRpZmljIGRvY3VtZW50
cyBpcyByZWZsZWN0ZWQgdXNpbmcgTWFya2Rvd24gc3ludGF4LgpgbWFya3lgIGJ5IGRlZmF1
bHQgdXNlcyB0aGUgZm9sbG93aW5nIGBwYW5kb2NgIE1hcmtkb3duIGV4dGVuc2lvbnMuCiog
cGFyc2luZyBleHRlbnNpb25zCgkqIFthbGxfc3ltYm9sc19lc2NhcGFibGVdKGh0dHBzOi8v
cGFuZG9jLm9yZy9NQU5VQUwuaHRtbCNleHRlbnNpb24tYWxsX3N5bWJvbHNfZXNjYXBhYmxl
KQoJKiBbaW50cmF3b3JkX3VuZGVyc2NvcmVzXShodHRwczovL3BhbmRvYy5vcmcvTUFOVUFM
Lmh0bWwjZXh0ZW5zaW9uLWludHJhd29yZF91bmRlcnNjb3JlcykKCSogW2VzY2FwZWRfbGlu
ZV9icmVha3NdKGh0dHBzOi8vcGFuZG9jLm9yZy9NQU5VQUwuaHRtbCNleHRlbnNpb24tZXNj
YXBlZF9saW5lX2JyZWFrcykKCSogW3NwYWNlX2luX2F0eF9oZWFkZXJdKGh0dHBzOi8vcGFu
ZG9jLm9yZy9NQU5VQUwuaHRtbCNleHRlbnNpb24tc3BhY2VfaW5fYXR4X2hlYWRlcikKCSog
W2xpc3RzX3dpdGhvdXRfcHJlY2VkaW5nX2JsYW5rbGluZV0oaHR0cHM6Ly9wYW5kb2Mub3Jn
L01BTlVBTC5odG1sI2V4dGVuc2lvbi1saXN0c193aXRob3V0X3ByZWNlZGluZ19ibGFua2xp
bmUpCiogc3R5bGluZyBleHRlbnNpb25zCgkqIFtpbmxpbmVfY29kZV9hdHRyaWJ1dGVzXSho
dHRwczovL3BhbmRvYy5vcmcvTUFOVUFMLmh0bWwjZXh0ZW5zaW9uLWlubGluZV9jb2RlX2F0
dHJpYnV0ZXMpCgkqIFtzdHJpa2VvdXRdKGh0dHBzOi8vcGFuZG9jLm9yZy9NQU5VQUwuaHRt
bCNleHRlbnNpb24tc3RyaWtlb3V0KQoJKiBbYnJhY2tldGVkX3NwYW5zXShodHRwczovL3Bh
bmRvYy5vcmcvTUFOVUFMLmh0bWwjZXh0ZW5zaW9uLWJyYWNrZXRlZF9zcGFucykKKiBzdHJ1
Y3R1cmluZyBleHRlbnNpb25zCgkqIFt5YW1sX21ldGFkYXRhX2Jsb2NrXShodHRwczovL3Bh
bmRvYy5vcmcvTUFOVUFMLmh0bWwjZXh0ZW5zaW9uLXlhbWxfbWV0YWRhdGFfYmxvY2spCgkq
IFtwaXBlX3RhYmxlc10oaHR0cHM6Ly9wYW5kb2Mub3JnL01BTlVBTC5odG1sI2V4dGVuc2lv
bi1waXBlX3RhYmxlcykKCSogW2xpbmVfYmxvY2tzXShodHRwczovL3BhbmRvYy5vcmcvTUFO
VUFMLmh0bWwjZXh0ZW5zaW9uLWxpbmVfYmxvY2tzKQoJKiBbaW1wbGljaXRfZmlndXJlc10o
aHR0cHM6Ly9wYW5kb2Mub3JnL01BTlVBTC5odG1sI2V4dGVuc2lvbi1pbXBsaWNpdF9maWd1
cmVzKQoJKiBbZm9vdG5vdGVzXShodHRwczovL3BhbmRvYy5vcmcvTUFOVUFMLmh0bWwjZXh0
ZW5zaW9uLWZvb3Rub3RlcykKCSogW2FiYnJldmlhdGlvbnNdKGh0dHBzOi8vcGFuZG9jLm9y
Zy9NQU5VQUwuaHRtbCNleHRlbnNpb24tYWJicmV2aWF0aW9ucykKCSogW2lubGluZV9ub3Rl
c10oaHR0cHM6Ly9wYW5kb2Mub3JnL01BTlVBTC5odG1sI2V4dGVuc2lvbi1pbmxpbmVfbm90
ZXMpCiogY29kZSBpbmplY3Rpb24KCSogW3Jhd19odG1sXShodHRwczovL3BhbmRvYy5vcmcv
TUFOVUFMLmh0bWwjZXh0ZW5zaW9uLXJhd19odG1sKQoJKiBbcmF3X3RleF0oaHR0cHM6Ly9w
YW5kb2Mub3JnL01BTlVBTC5odG1sI2V4dGVuc2lvbi1yYXdfdGV4KQoJKiBbbmF0aXZlX2Rp
dnNdKGh0dHBzOi8vcGFuZG9jLm9yZy9NQU5VQUwuaHRtbCNleHRlbnNpb24tbmF0aXZlX2Rp
dnMpCgkqIFtuYXRpdmVfc3BhbnNdKGh0dHBzOi8vcGFuZG9jLm9yZy9NQU5VQUwuaHRtbCNl
eHRlbnNpb24tbmF0aXZlX3NwYW5zKQoKYHBhbmRvY2Agc3VwcG9ydHMKW2VxdWF0aW9uc10o
aHR0cHM6Ly9wYW5kb2Mub3JnL01BTlVBTC5odG1sI2V4dGVuc2lvbi10ZXhfbWF0aF9kb2xs
YXJzKQpyZW5kZXJlZCBpbmxpbmUgYW5kIHNpbmdsZS1saW5lIGluIHRleC1zdHlsZSB1c2lu
ZyBgJC4uLiRgIGFuZCBgJCQuLi4kJGAsCltiaWJsaW9ncmFwaHldKGh0dHBzOi8vcGFuZG9j
Lm9yZy9NQU5VQUwuaHRtbCNjaXRhdGlvbnMpCnVzaW5nIHRoZSBgLS1jaXRlcHJvY2Agb3B0
aW9uLApbc2VjdGlvbiBudW1iZXJpbmddKGh0dHBzOi8vcGFuZG9jLm9yZy9NQU5VQUwuaHRt
bCNleHRlbnNpb24taGVhZGVyX2F0dHJpYnV0ZXMpCnVzaW5nIHRoZSBgLS1udW1iZXItc2Vj
dGlvbnNgIG9wdGlvbiBhbmQKW3RhYmxlIG9mIGNvbnRlbnRzXShodHRwczovL3BhbmRvYy5v
cmcvTUFOVUFMLmh0bWwjb3B0aW9uLS10b2MpCnVzaW5nIHRoZSBgLS10YWJsZS1vZi1jb250
ZW50c2Agb3B0aW9uLgoKYHBhbmRvY2Agc3VwcG9ydHMgW2B4bm9zYF0oaHR0cHM6Ly9naXRo
dWIuY29tL3RvbWR1Y2svcGFuZG9jLXhub3MpIGZpbHRlcnMKZm9yIHJlZmVyZW5jaW5nIGRv
Y3VtZW50IGNvbnRlbnQgbGlrZQpbZmlndXJlc10oaHR0cHM6Ly9naXRodWIuY29tL3RvbWR1
Y2svcGFuZG9jLWZpZ25vcyN1c2FnZSksCltlcXVhdGlvbnNdKGh0dHBzOi8vZ2l0aHViLmNv
bS90b21kdWNrL3BhbmRvYy1lcW5vcyN1c2FnZSksClt0YWJsZXNdKGh0dHBzOi8vZ2l0aHVi
LmNvbS90b21kdWNrL3BhbmRvYy10YWJsZW5vcyN1c2FnZSksCltzZWN0aW9uc10oaHR0cHM6
Ly9naXRodWIuY29tL3RvbWR1Y2svcGFuZG9jLXNlY25vcyN1c2FnZSkKYnkgdXNpbmcgdGhl
IGAtLWZpbHRlciBwYW5kb2MteG5vc2Agb3B0aW9uLgpgeG5vc2AgaW50ZWdyYXRlcyBjbGV2
ZXIgcmVmZXJlbmNlcywgd2hpY2ggbWVhbnMgIkZpZy4iLCAiU2VjLiIsICJFcS4iCmFuZCAi
VGFiLiIgYXJlIGFkZGVkIGF1dG9tYXRpY2FsbHkgdG8gdGhlIGNvcnJlc3BvbmRpbmcgZWxl
bWVudC4KSWYgdGhlIHByZWZpeCBpcyB0byBiZSBvbWl0dGVkLCB0aGUgcmVmZXJlbmNlIGlz
IHdyaXR0ZW4gYXMKYFwhQHJlZjpsYWJlbGAuCgojIyMjIEV4YW1wbGUgey19CmBgYG1kCiMj
IFJlZmVyZW5jZWQgU2VjdGlvbiB7I3NlYzpsYWJlbH0KClRoaXMgaXMgYSByZWZlcmVuY2Ug
dG8gQHNlYzpsYWJlbC4KCiFbVGhpcyBpcyB0aGUgY2FwdGlvbl0oZGF0YTppbWFnZS9wbmc7
YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TClVoRVVnQUFBQVVBQUFBRkNBWUFBQUNOYnlibEFB
QUFIRWxFUVZRSTEyUDQvLzgvdzM4R0lBWERJQktFMERICnhnbGpOQkFBTzlUWEwwWTRPSHdB
QUFBQkpSVTVFcmtKZ2dnPT0peyNmaWc6bGFiZWx9CgpUaGlzIGlzIGEgcmVmZXJlbmNlIHRv
IEBmaWc6bGFiZWwuCgpBICB8QiAgfEMgIHxECi0tLXwtLS18LS0tfC0tLQowMDB8MTExfDQ0
NHw1NTUKMjIyfDMzM3w2NjZ8Nzc3CgpUYWJsZTogVGhpcyBpcyB0aGUgY2FwdGlvbiB7I3Ri
bDpsYWJlbH0KClRoaXMgaXMgYSByZWZlcmVuY2UgdG8gQHRibDpsYWJlbC4KCiQkXG1ib3h7
ZX1ee1xtYm94e2l9XHBpfSsxPTAkJHsjZXE6bGFiZWx9CgpUaGlzIGlzIGEgcmVmZXJlbmNl
IHRvIEBlcTpsYWJlbC4KClRoaXMgaXMgYSBjaXRhdGlvbiBbQE11bGxlcjE5OTNdLgpgYGAK
ClRoZSBmaWxlIGBtYXJreS5iaWJgIGlzIHNwZWNpZmllZCBpbiB0aGUgbWV0YSBkYXRhIGlu
IHRoZSBmcm9udAptYXR0ZXIgb2YgdGhlIE1hcmtkb3duIHRleHQuCgojIyBSZWZlcmVuY2Vk
IFNlY3Rpb24geyNzZWM6bGFiZWx9CgpUaGlzIGlzIGEgcmVmZXJlbmNlIHRvIEBzZWM6bGFi
ZWwuCgohW1RoaXMgaXMgdGhlIGNhcHRpb25dKGRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJP
UncwS0dnb0FBQUFOU1VoRVVnQUFBQVVBQUFBRkNBWUFBQUNOYnlibEFBQUFIRWxFUVZRSTEy
UDQvLzgvdzM4R0lBWERJQktFMERIeGdsak5CQUFPOVRYTDBZNE9Id0FBQUFCSlJVNUVya0pn
Z2c9PSl7I2ZpZzpsYWJlbH0KClRoaXMgaXMgYSByZWZlcmVuY2UgdG8gQGZpZzpsYWJlbC4K
CkEgIHxCICB8QyAgfEQKLS0tfC0tLXwtLS18LS0tCjAwMHwxMTF8NDQ0fDU1NQoyMjJ8MzMz
fDY2Nnw3NzcKClRhYmxlOiBUaGlzIGlzIHRoZSBjYXB0aW9uLiB7I3RibDpsYWJlbH0KClRo
aXMgaXMgYSByZWZlcmVuY2UgdG8gQHRibDpsYWJlbC4KCiQkXG1ib3h7ZX1ee2lccGl9KzE9
MCQkeyNlcTpsYWJlbH0KClRoaXMgaXMgYSByZWZlcmVuY2UgdG8gQGVxOmxhYmVsLgoKVGhp
cyBpcyBhIGNpdGF0aW9uIFtATXVsbGVyMTk5M10uCgotLS0KCipUaGFua3MgZm9yIHJlYWRp
bmcsIHBsZWFzZSB0cnkqIGBtYXJreWAuCgotLS0KCiMgUmVmZXJlbmNlcwo=
'''
pack_marky_bib = '''
QGFydGljbGV7TXVsbGVyMTk5MywKICAgIGF1dGhvciAgPSB7UGV0ZXIgTXVsbGVyfSwKICAg
IHRpdGxlICAgPSB7VGhlIHRpdGxlIG9mIHRoZSB3b3JrfSwKICAgIGpvdXJuYWwgPSB7VGhl
IG5hbWUgb2YgdGhlIGpvdXJuYWx9LAogICAgeWVhciAgICA9IHsxOTkzfSwKICAgIG51bWJl
ciAgPSB7Mn0sCiAgICBwYWdlcyAgID0gezIwMS0yMTN9LAogICAgbW9udGggICA9IHs3fSwK
ICAgIG5vdGUgICAgPSB7QW4gb3B0aW9uYWwgbm90ZX0sCiAgICB2b2x1bWUgID0gezR9Cn0K
'''
pack__gitignore = '''
YnVpbGQvCmh0bWwvCnBkZi8K
'''

###!!!:::marky_pack_data:::!!!###
########################################################################
# SECTION IS AUTO-PACKAGED USING ./marky.py --pack --force
########################################################################

########################################################################

def _marky_front_join(y, text):
	return """---\n%s\n---\n%s""" % (
		yaml.dump(y, allow_unicode=True, default_flow_style=False),
		text
	)

def _marky_front_split(t):
	global _MARKY_EXEC_GLOBALS
	global _MARKY_EXEC_QUIET
	if not t.startswith("---\n"):
		return dict(), t, 0
	y = t.split("---\n")[1]
	meta_lines = len(y.split("\n")) + 2
	mark = "---\n".join(t.split("---\n")[2:])
	_marky_print_mark("---\n" + y + "---")
	data = dict()
	try:
		data = yaml.safe_load(y)
	except Exception as ex:
		print("# YAML ERROR", type(ex), str(ex))
		sys.exit(1)
	return data, mark, meta_lines

########################################################################

def _marky_print_mesg(*args):
	print("<!--", *args, "--!>")

def _marky_print_mark(*args, end="\n"):
	if not _MARKY_EXEC_QUIET: print(*args, end=end, flush=True)

def _marky_print_trace(ex, mlines, code):
	print("# TRACEBACK")
	import traceback
	traceback.print_tb(ex.__traceback__)
	print(dir(ex), ex.args, ex.__dict__)
	if hasattr(ex, "filename") and ex.filename == "<string>":
		print("# ERROR LOCATION")
		code = code.split("\n")
		print(len(code))
		for i in range(max(0, ex.lineno-5), min(len(code), ex.lineno+5)):
			print("*" if i + 1 == ex.lineno else " ", "%03d" % i, code[i])
	print("# PYTHON ERROR")
	print(type(ex), str(ex))

def _marky_file_mtime_older(f1, f2):
	return os.path.getmtime(f1) < os.path.getmtime(f2)

def _marky_file_mtime_newer(f1, f2):
	return os.path.getmtime(f1) > os.path.getmtime(f2)

def _marky_file_make_basename(f):
	return "/".join(".".join(f.split(".")[0:-1]).split("/")[1:])

def _marky_mdtext_print(*args, sep=" ", shift="", crop=False, ret=False, code=False, text=False, pop=True,
	file=None, __marky__=False, raw=False, aux=False, cmd=None, meta=None):
	# MD output: args, sep=" ", shift="", crop=False, ret=False
	# MD code output: code=False, pop=True
	# MD include: file, __marky__, raw, aux
	global _MARKY_EXEC_QUIET
	global _MARKY_EXEC_TEXT
	global _MARKY_EXEC_APPEND
	global _MARKY_PASTE_CODE
	global _MARKY_PASTE_TEXT
	global _MARKY_COMMAND_LIST
	global _MARKY_META_DICT
	if not meta is None:
		_MARKY_META_DICT.update(meta)
	if text:
		text = _MARKY_EXEC_TEXT[_MARKY_PASTE_TEXT:]
		if pop: _MARKY_PASTE_TEXT = len(_MARKY_EXEC_TEXT)
		return _marky_mdtext_print(text, shift=shift, crop=crop, ret=True)
	if code:
		if len(_MARKY_PASTE_CODE) == 0: return ""
		code = _MARKY_PASTE_CODE[0]
		if pop: _MARKY_PASTE_CODE = _MARKY_PASTE_CODE[1:]
		return _marky_mdtext_print(code, shift=shift, crop=crop, ret=True)
	if not file is None:
		if aux:
			if not os.path.exists(file):
				if cmd is None or len(cmd.strip()) == 0:
					_marky_print_mesg("aux file not found:", file)
					sys.exit(1)
				_marky_print_mesg("run aux cmd for", file, ":", cmd)
				if callable(cmd):
					cmd()
				elif type(cmd) is str:
					os.system(cmd)
				else:
					_marky_print_mesg("ERROR", "___(file, cmd=...) has wrong value:", cmd)
					sys.exit(1)
				if not os.path.exists(file):
					_marky_print_mesg("aux file not found:", file)
					sys.exit(1)
			else:
				_marky_print_mesg("aux file exists:", file)
			_MARKY_INCLUDE_LIST.append(file)
			_MARKY_COMMAND_LIST.append("" if cmd is None or len(str(cmd).strip()) == 0 else cmd)
		elif raw:
			if not os.path.exists(file):
				print("# ERROR", "no such file", file)
				sys.exit(1)
			_marky_mdtext_print(open(file, "r").read(), _marky_mdtext_print)
		else:
			_marky_run(file, _marky_file_make_basename(file), __marky__)
		return
	if len(args) == 0:
		if _MARKY_EXEC_APPEND == False: _MARKY_EXEC_TEXT += "\n"
		_MARKY_EXEC_APPEND = False
	else:
		if ret: return _marky_mdtext_ret(args[0], shift, crop)
		if crop or shift != "":
			_marky_mdtext_crop(args[0], shift, crop)
			if args[-1] == _marky_mdtext_print:
				_MARKY_EXEC_APPEND = True
			return
		exec_append_new = False
		if args[-1] == _marky_mdtext_print:
			exec_append_new = True
			args = args[0:-1]
		text = sep.join([str(i) for i in args])
		if _MARKY_EXEC_APPEND and len(_MARKY_EXEC_TEXT) > 0:
			_MARKY_EXEC_TEXT += text
		else:
			_MARKY_EXEC_TEXT += "\n" + text
		_MARKY_EXEC_APPEND = exec_append_new
		_marky_print_mark(text, end="" if _MARKY_EXEC_APPEND else "\n")

def _marky_mdtext_crop(arg, shift, crop):
	global _MARKY_EXEC_TEXT
	global _MARKY_EXEC_APPEND
	if not type(arg) is str:
		arg = str(arg)
	arg = arg.split("\n")
	if crop:
		if len(arg[0].strip()) == 0:
			arg = arg[1:]
		if len(arg[-1].strip()) == 0:
			arg = arg[:-1]
	n = len(arg[0]) - len(arg[0].lstrip())
	for i in arg:
		if crop and len(i[0:n].lstrip()) == 0:
			i = i[n:]
		_MARKY_EXEC_TEXT += "\n" + shift + i

def _marky_mdtext_ret(arg, shift="", crop=True):
	if not type(arg) is str:
		arg = str(arg)
	text = []
	arg = arg.split("\n")
	if crop:
		if len(arg[0].strip()) == 0:
			arg = arg[1:]
		if len(arg[-1].strip()) == 0:
			arg = arg[:-1]
	n = len(arg[0]) - len(arg[0].lstrip())
	for i in arg:
		if crop and len(i[0:n].lstrip()) == 0:
			i = i[n:]
		text.append(shift + i)
	return "\n".join(text)

########################################################################

class _marky_fmtcall:
	def __init__(self, name, fmtc):
		self.name = name
		self.fmtc = fmtc
	def __call__(self, *args, **kwargs):
		text = "<<?html "
		f = getattr(self.fmtc.html, self.name)
		if callable(f):
			v = f(*args, **kwargs)
			if type(v) is str: text += v
		elif type(f) is str:
			text += f.format(*args, **kwargs)
		text += " html?>>"
		text += "<<?pdf "
		f = getattr(self.fmtc.pdf, self.name)
		if callable(f):
			v = f(*args, **kwargs)
			if type(v) is str: text += v
		elif type(f) is str:
			text += f.format(*args, **kwargs)
		text += " pdf?>>"
		return text

class _marky_fmtcode:
	def __init__(self, pdf=None, html=None):
		if not html is None: self.html = html
		if not pdf is None: self.pdf = pdf
	def __call__(self, *args, **kwargs):
		text = "<<?html "
		f = self.html
		if callable(f):
			v = f(*args, **kwargs)
			if type(v) is str: text += v
		elif type(f) is str:
			text += f.format(*args, **kwargs)
		text += " html?>>"
		text += "<<?pdf "
		f = self.pdf
		if callable(f):
			v = f(*args, **kwargs)
			if type(v) is str: text += v
		elif type(f) is str:
			text += f.format(*args, **kwargs)
		text += " pdf?>>"
		return text
	def __getattr__(self, name):
		return _marky_fmtcall(name, self)

########################################################################

def _marky_rebrace(t):
	t = t.replace("{{", "<<brace?")
	t = t.replace("}}", "?brace>>")
	t = t.replace("{", "{{")
	t = t.replace("}", "}}")
	t = t.replace("<<brace?", "{")
	t = t.replace("?brace>>", "}")
	return t

def _marky_code_text(t, fstring=True):
	if fstring:
		if not '"""' in t and not t.endswith('"'):
			return '___(rf"""' + _marky_rebrace(t) + '""", ___); '
		elif not "'''" in t and not t.endswith("'"):
			return "___(rf'''" + _marky_rebrace(t) + "''', ___); "
		else:
			print("# ERROR", "python code contains \"\"\" as well as '''.")
			sys.exit(1)
	else:
		if not '"""' in t and not t.endswith('"'):
			return '___(r"""' + t + '""", ___); '
		elif not "'''" in t and not t.endswith("'"):
			return "___(r'''" + t + "''', ___); "
		else:
			print("# ERROR", "python code contains \"\"\" as well as '''.")
			sys.exit(1)

def _marky_paste_code(t):
	global _MARKY_PASTE_CODE
	if t.startswith("!"):
		t = t[1:]
		_MARKY_PASTE_CODE.append(t)
	return t

def _marky_meta_merge(old, front):
	global _MARKY_EXEC_GLOBALS
	meta = {}
	meta.update(old)
	try:
		for k, v in front.items():
			x = k.split("--")
			if "--" in k and x[-1] in _MARKY_FORMAT:
				if k in meta:
					if type(v) is list:
						_marky_print_mesg("field link, merge yaml list %s" % k)
						meta[k].extend(v)
					if type(v) is dict:
						_marky_print_mesg("field link, merge yaml dict %s" % k)
						meta[k].update(v)
					if type(v) is str:
						_marky_print_mesg("field link, merge yaml str %s" % k)
						meta[k] += " " + v
					else:
						_marky_print_mesg("field exists, skip yaml %s %s" % (str(type(v)), k))
				else:
					_marky_print_mesg("field link, set yaml %s" % k)
					meta[k] = v
			else:
				if k in meta:
					_marky_print_mesg("field exists, skip yaml %s" % k)
				else:
					meta[k] = v
				k = k.replace("-", "_")
				if k in _MARKY_EXEC_GLOBALS:
					_marky_print_mesg("field exists, skip local %s" % k)
				else:
					_MARKY_EXEC_GLOBALS[k] = v
	except Exception as ex:
		print("# META MERGE ERROR", type(ex), str(ex))
		sys.exit(1)
	return meta

def _marky_run(fname, inbase, run=True):
	global _MARKY_EXEC_GLOBALS
	global _MARKY_META_DICT
	global _MARKY_INCLUDE_LIST
	_MARKY_INCLUDE_LIST.append(fname)
	_marky_print_mesg("run %s" % fname)
	with open(fname, "r") as h:
		front, t, meta_lines = _marky_front_split(h.read())
	_MARKY_META_DICT = _marky_meta_merge(_MARKY_META_DICT, front)
	p = 0
	r = "\n"*(meta_lines-1)
	while True:
		p0 = t.find("<?", p)
		p1 = t.find("?>", p)
		if p0 > -1:
			if p1 < p0:
				print(t[max(0, p0-250):p0+2])
				print("# ERROR", "?> before <?", r"... (can use <\? and ?\> for escaping)")
				if "<!?" in t:
					print("# there is <!? in text, did you mean: <?!")
				sys.exit(1)
			if p0 > 0: r += _marky_code_text(t[p:p0])
			p1 = t.find("?>", p0)
			if p1 > -1:
				code = t[p0+2:p1]
				r += _marky_paste_code(code)
				p = p1 + 2
			else:
				print("# ERROR", "missing ?>")
				sys.exit(1)
		else:
			r += _marky_code_text(t[p:])
			break
	for a, b, c, count in [
		("", "<%s?", "", 1),
		("", "?%s>", "", 1),
		("", "{%s", "{", 3),
		("}", "%s}", "", 3)
	]:
		for j in reversed(range(1, count+1)):
			for i in range(3):
				X = "\\"*(i + 1)
				Y = "\\"*(i + 0)
				r = r.replace(a + (b % X)*j + c, a + (b % Y)*j + c)
	open(_MARKY_BUILD_DIR + inbase + ".py", "w").write(r)
	old_MARKY_EXEC_GLOBALS = _MARKY_EXEC_GLOBALS["__marky__"]
	_MARKY_EXEC_GLOBALS["__marky__"] = run
	_marky_print_mesg("run %s" % (_MARKY_BUILD_DIR + inbase + ".py"))
	try:
		exec(r, _MARKY_EXEC_GLOBALS, None)
	except Exception as ex:
		import traceback
		exc_type, exc_value, exc_traceback = sys.exc_info()
		tblist = traceback.extract_tb(exc_traceback)
		if len(tblist) > 1:
			tbstr = traceback.format_tb(exc_traceback)
			tblist = tblist[1:]
			tbstr = tbstr[1:]
			tbstr[0] = tbstr[0].replace("<string>", fname) + ("    %s\n" % (t.split("\n")[tblist[0].lineno-meta_lines]))
			exstr = str(ex)
		else:
			tbstr = []
			exstr = str(ex).replace("<string>", fname)
			if hasattr(ex, "lineno"): exstr += ("\n    %s" % (t.split("\n")[ex.lineno-meta_lines]))
		print("<!-- PYTHON ERROR\n")
		if len(tbstr) > 0: print("\n".join(tbstr))
		print("  Error", type(ex), ":", exstr, "\n")
		print("--!>")
		sys.exit(1)
	_MARKY_EXEC_GLOBALS["__marky__"] = old_MARKY_EXEC_GLOBALS

########################################################################

def _marky_meta_link(front, link):
	flink = {}
	try:
		for k, v in front.items():
			if "--" in k: continue
			if not k in flink:
				flink[k] = v
			else:
				_marky_print_mesg(" exists, skip yaml %s" % k)
		for k, v in front.items():
			if not "--" in k: continue
			x = k.split("--")
			if x[-1] in _MARKY_FORMAT:
				if x[-1] == link:
					k = "--".join(x[0:-1])
					if k in flink:
						_marky_print_mesg("field link, merge yaml %s" % k)
						if type(v) is list: flink[k].extend(v)
						if type(v) is dict: flink[k].update(v)
						if type(v) is str: flink[k] += " " + v
						else: flink[k] = v
					else:
						_marky_print_mesg("field link, set yaml %s" % k)
						flink[k] = v
	except Exception as ex:
		print("# META LINK ERROR", type(ex), str(ex))
		sys.exit(1)
	return flink

def _marky_link(front, md_text, link):
	md_text = md_text.replace(".???", "." + link)
	md_text = md_text.replace(r".\???", r".???")
	md_text = md_text.replace(r".\\???", r".\???")
	lsep = 3
	len_args = len(link) + 1
	c = 0
	newtext = ""
	p = md_text.find("<<?")
	while p >= 0:
		q = md_text.find("?>>", p + lsep)
		if q > 0:
			newtext += md_text[c:p]
			expr = md_text[p+lsep:q]
			if expr.startswith(link) and expr.endswith(link):
				newtext += expr[len_args:-len_args]
			c = q + lsep
			p = md_text.find("<<?", c)
		else:
			p = md_text.find("<<?", p + lsep)
	newtext += md_text[c:]
	flink = _marky_meta_link(front, link)
	return _marky_front_join(flink, newtext)

def _marky_write_build(inbase, outdir, front, mark):
	os.makedirs(_MARKY_BUILD_DIR + outdir, exist_ok=True)
	if not mark is None:
		open(_MARKY_BUILD_DIR + inbase + ".md", "w").write(_marky_front_join(front, mark))
		for fmt in _MARKY_FORMAT:
			open(_MARKY_BUILD_DIR + inbase + "." + fmt + ".md", "w").write(_marky_link(front, mark, fmt))
	inname = inbase.replace(".", "__").replace("/", "__")
	newltab = "\n\t"
	with open(_MARKY_BUILD_DIR + inbase + ".make", "w") as fhnd:
		fhnd.write(f"""# auto-generated
marky_dep_{inname}:={" ".join(list(set(_MARKY_INCLUDE_LIST[1:])))}

marky_alias:=$(marky_alias) {inbase}

.PHONY: scan/{inbase}
scan/{inbase}:
	./marky.py --base="{inbase}" --scan

{_MARKY_BUILD_DIR+inbase}.md: {_MARKY_MD_DIR+inbase}.md $(marky_dep_{inname})
	mkdir -p "{_MARKY_BUILD_DIR+outdir}"
	ln -snf ../{_MARKY_DATA_DIR} {_MARKY_BUILD_DIR+_MARKY_DATA_DIR}
	ln -snf ../{_MARKY_DATA_DIR} {_MARKY_MD_DIR+_MARKY_DATA_DIR}
	./marky.py --base="{inbase}" $(if $(all_quiet),--quiet,)

.PHONY: build/{inbase}
build/{inbase}: {_MARKY_BUILD_DIR+inbase}.md

.PHONY: aux/{inbase}
aux/{inbase}:
	{newltab.join([i for i in _MARKY_COMMAND_LIST if i != ""])}

.PHONY: clean/{inbase}
clean/{inbase}:
	rm -rf "{_MARKY_BUILD_DIR+inbase}.make"
	rm -rf "{_MARKY_BUILD_DIR+inbase}.md"
	rm -rf "{_MARKY_BUILD_DIR+inbase}.html.md"
	rm -rf "{_MARKY_BUILD_DIR+inbase}.pdf.md"
	rm -rf "{_MARKY_BUILD_DIR+inbase}.py"
	rm -rf "{_MARKY_BUILD_DIR+inbase}.tex"
"""
		)
		if "pdf" in _MARKY_FORMAT:
			fhnd.write(f"""
{_MARKY_BUILD_DIR+inbase}.tex: {_MARKY_BUILD_DIR+inbase}.pdf.md {_MARKY_MD_DIR+inbase}.md
	mkdir -p "{_MARKY_BUILD_DIR+outdir}"
	./pandoc-run tex {_MARKY_BUILD_DIR+inbase}.pdf.md {_MARKY_BUILD_DIR+inbase}.tex

.PHONY: tex/{inbase}
tex/{inbase}: {_MARKY_BUILD_DIR+inbase}.tex
"""
			)
		for fmt in _MARKY_FORMAT:
			fhnd.write(f"""
{_MARKY_BUILD_DIR+inbase}.{fmt}.md: {_MARKY_BUILD_DIR+inbase}.md

{fmt}/{inbase}.{fmt}: {_MARKY_BUILD_DIR+inbase}.{fmt}.md {_MARKY_MD_DIR+inbase}.md
	mkdir -p "{fmt}/{outdir}"
	./pandoc-run {fmt} {_MARKY_BUILD_DIR+inbase}.{fmt}.md {fmt}/{inbase}.{fmt}

.PHONY: {fmt}/{inbase}
{fmt}/{inbase}: {fmt}/{inbase}.{fmt}
"""
			)
		fmt_list = [f"{i}/{inbase}" for i in _MARKY_FORMAT]
		fhnd.write(f"""
.PHONY: all/{inbase}
all/{inbase}: {" ".join(fmt_list)}
"""
		)

########################################################################

def _marky_pack_b64enc(x, n=72):
	x = base64.b64encode(bytes(x, "utf-8")).decode("ascii")
	return "\n".join([x[i:i+n] for i in range(0, len(x), n)])

def _marky_pack_b64dec(x):
	return base64.b64decode(bytes(x.replace("\n", ""), "ascii")).decode("utf-8")

def _marky_load_pack(i):
	return _marky_pack_b64dec(eval("pack_" + i.split("/")[-1].replace(".", "_").replace("-", "_")))

def _marky_pack_write_file(fname, force=False):
	if not os.path.exists(fname) or force:
		print("# WRITE", fname)
		open(fname, "w").write(_marky_load_pack("./" + fname))
	else:
		print("# EXISTS", fname)

def _marky_store_pack(i, ftext):
	return "pack_%s = '''\n%s\n'''\n" % (i.split("/")[-1].replace(".", "_").replace("-", "_"), _marky_pack_b64enc(ftext))

def _marky_pack_read_file(fname):
	return _marky_store_pack("./" + fname, open(fname, "r").read())

########################################################################

_MARKY_FORMAT = ["html", "pdf"]
_MARKY_BUILD_DIR = "build/"  #< WITH trailing /
_MARKY_MD_DIR = "md/"  #< WITH trailing /
_MARKY_DATA_DIR = "data" #< no trailing /
_MARKY_PACK_DIRS = [
	_MARKY_BUILD_DIR,
	_MARKY_DATA_DIR,
	_MARKY_MD_DIR
]
_MARKY_PACK_FILES = [
	"Makefile",
	"pandoc-run",
	"md/marky.md",
	"data/marky.bib",
	".gitignore"
]
_MARKY_EXEC_QUIET = False
_MARKY_EXEC_TEXT = ""
_MARKY_EXEC_APPEND = False
_MARKY_EXEC_GLOBALS = dict()
_MARKY_EXEC_GLOBALS["___"] = _marky_mdtext_print
_MARKY_EXEC_GLOBALS["fmtcode"] = _marky_fmtcode
_MARKY_EXEC_GLOBALS["__marky__"] = True
_MARKY_META_DICT = dict()
_MARKY_INCLUDE_LIST = list()
_MARKY_PASTE_CODE = list()
_MARKY_PASTE_TEXT = 0
_MARKY_BUILD_PYTHON = None
_MARKY_COMMAND_LIST = list()

########################################################################

if __name__ == "__main__":

	parser = argparse.ArgumentParser(add_help=False)

	parser.add_argument("--version", action='store_true', help="version is v" + ".".join([str(i) for i in _MARKY_VERSION]))
	parser.add_argument("--help", action='store_true', help="show this help message")
	parser.add_argument("--base", type=str, default="", help="path to input markdown text")
	parser.add_argument("--init", action='store_true', help="create dirs (" + ", ".join(_MARKY_PACK_DIRS) + ") and files (" + ", ".join(_MARKY_PACK_FILES) + ")")
	parser.add_argument("--Makefile", action='store_true', help="write marky Makefile, overwite if existing")
	parser.add_argument("--pandoc-run", action='store_true', help="write marky pandoc-run script, overwite if existing")
	parser.add_argument("--force", action='store_true', help="force overwrite of files for --init/--pack")
	parser.add_argument("--pack", action='store_true', help="pack files (" + ", ".join(_MARKY_PACK_FILES) + ") into marky.py.pack source")
	parser.add_argument("--scan", action='store_true', help="create build/*.make from md/*.md")
	parser.add_argument("--quiet", action='store_true', help="do not show Markdown output")

	# ~ args, uargs = parser.parse_known_args()
	args = parser.parse_args()

	# ~ sys.path.append("/".join(sys.argv[0].split("/")[0:-1]))

########################################################################

	if args.version:
		print(".".join([str(i) for i in _MARKY_VERSION]))
		sys.exit(0)

	if args.help or len(sys.argv) == 1:
		parser.print_help()
		sys.exit(0)

	if args.Makefile or args.pandoc_run:
		unpack_files = list()
		if args.Makefile: unpack_files.append("Makefile")
		if args.pandoc_run: unpack_files.append("pandoc-run")
		for i in unpack_files:
			_marky_pack_write_file(i, True)
		sys.exit(0)

	if args.init:
		for i in _MARKY_PACK_DIRS:
			if not os.path.exists(i):
				print("# MKDIR", i)
				os.mkdir(i)
			else:
				print("# EXISTS", i)
		for i in _MARKY_PACK_FILES:
			_marky_pack_write_file(i, args.force)
		print("# USAGE")
		print("make help")
		sys.exit(0)

	if args.pack:
		print("# PACK", ", ".join(_MARKY_PACK_FILES))
		marky_text = open(sys.argv[0], "r").read()
		head, src, tail = tuple(marky_text.split("\n###!!!:::marky_pack_data:::!!!###\n"))
		src = "".join([_marky_pack_read_file(i) for i in _MARKY_PACK_FILES])
		marky_text = "\n###!!!:::marky_pack_data:::!!!###\n".join([head, src, tail])
		open(sys.argv[0] + ".pack", "w").write(marky_text)
		if args.force:
			print("# UPDATE OF `marky` FORCED")
			print("# -----------------------")
			print("# mv marky.py.pack marky.py")
			print("# chmod 775 marky.py")
			os.replace("marky.py.pack", "marky.py")
			os.chmod("marky.py", 0o775)
		else:
			print("# MANUAL UPDATE NEEDED")
			print("# --------------------")
			print("mv marky.py.pack marky.py")
			print("chmod +x marky.py")
		sys.exit(0)

	if args.scan:
		if len(args.base.strip()) > 0:
			outdir = "/".join(args.base.split("/")[0:-1])
			print("# WRITE", _MARKY_BUILD_DIR + args.base + ".make")
			_marky_write_build(args.base, outdir, None, None)
		else:
			for i in glob.glob("md/**/*.md", recursive=True):
				inbase = i[3:-3]
				outdir = "/".join(inbase.split("/")[0:-1])
				if os.path.exists(_MARKY_BUILD_DIR + inbase + ".make") and not args.force:
					# ~ print("# EXISTS", _MARKY_BUILD_DIR + inbase + ".make")
					pass
				else:
					print("# WRITE", _MARKY_BUILD_DIR + inbase + ".make")
					_marky_write_build(inbase, outdir, None, None)
		sys.exit(0)

	if args.force:
		print("# ERROR", "--force can only be used with --pack/--init/--scan")
		sys.exit(1)

	if args.quiet:
		_MARKY_EXEC_QUIET = True

########################################################################

	infile = _MARKY_MD_DIR + args.base + ".md"
	if len(args.base) == 0:
		print("# ERROR", "empty base: use --base file.md")
		sys.exit(1)
	if not os.path.exists(infile):
		print("# ERROR", "wrong base %s: file not found %s" % (args.base, infile))
		sys.exit(1)
	inbase = args.base
	outdir = "/".join(inbase.split("/")[0:-1])

	if os.path.exists(_MARKY_BUILD_DIR):
		_marky_run(infile, inbase)
		_marky_write_build(inbase, outdir, _MARKY_META_DICT, _MARKY_EXEC_TEXT)
	else:
		print("# ERROR", "no build dir: mkdir build")
		sys.sys.exit(1)
